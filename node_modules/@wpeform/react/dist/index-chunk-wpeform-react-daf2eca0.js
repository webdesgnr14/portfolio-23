import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import * as React$2 from 'react';
import React__default, { createContext, useState as useState$1, useEffect, useContext, useMemo, useRef, forwardRef, lazy, Suspense, createElement, useCallback as useCallback$1, useLayoutEffect as useLayoutEffect$1, Component } from 'react';
import styled, { css, useTheme, ServerStyleSheet, StyleSheetManager, ThemeProvider, keyframes, createGlobalStyle } from 'styled-components';
import { renderToString } from 'react-dom/server';
import 'react-is';
import { parse } from 'query-string';
import { config, animated, useSpring, useTransition } from '@react-spring/web';
import { useInView } from 'react-intersection-observer';
import createHook from 'zustand';
import { dom } from '@fortawesome/fontawesome-svg-core';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { createPortal } from 'react-dom';

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i$2 = 0; i$2 < 256; ++i$2) {
  byteToHex.push((i$2 + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

const shadowContext = createContext(false);
function LinkAssets(props) {
    const { cssHandles } = props;
    const [assets, setAssets] = useState$1([]);
    useEffect(() => {
        const cssAssets = [];
        if (cssHandles && typeof window !== 'undefined') {
            cssHandles.forEach(handle => {
                const link = document.querySelector(`#${handle}-css`);
                if (link) {
                    const href = link.getAttribute('href');
                    if (href) {
                        cssAssets.push({
                            id: handle,
                            href,
                            media: link.getAttribute('media') ?? 'all',
                        });
                    }
                }
            });
        }
        setAssets(cssAssets);
    }, [cssHandles]);
    return (jsx(Fragment, { children: assets.map(asset => (jsx("link", { rel: "stylesheet", href: asset.href, media: asset.media }, asset.id))) }, void 0));
}
function LinkAllAssets(props) {
    const { body = false, head = true } = props;
    const [assets, setAssets] = useState$1([]);
    useEffect(() => {
        const currentAssets = [];
        let links;
        const query = 'link[rel="stylesheet"]';
        if (head && body) {
            links = document.querySelectorAll(query);
        }
        else if (head) {
            links = document.head.querySelectorAll(query);
        }
        else {
            links = document.body.querySelectorAll(query);
        }
        if (links.length) {
            links.forEach(link => {
                const href = link.getAttribute('href');
                if (href) {
                    currentAssets.push({
                        id: link.getAttribute('id') ?? v4(),
                        href,
                        media: link.getAttribute('media') ?? 'all',
                    });
                }
            });
        }
        setAssets(currentAssets);
    }, [body, head]);
    return (jsx(Fragment, { children: assets.map(asset => (jsx("link", { rel: "stylesheet", href: asset.href, media: asset.media }, asset.id))) }, void 0));
}
function useIsShadow() {
    return useContext(shadowContext);
}
function CustomGlobalStyles() {
    const { customCSS, customStyleLinks } = typeof WPEFormGraphQLApp !== 'undefined'
        ? WPEFormGraphQLApp
        : { customCSS: undefined, customStyleLinks: undefined };
    return (jsxs(Fragment, { children: [customCSS ? (jsx("style", { type: "text/css", 
                // eslint-disable-next-line react/no-danger
                dangerouslySetInnerHTML: { __html: customCSS } }, void 0)) : null, customStyleLinks
                ? customStyleLinks.map(link => (jsx("link", { rel: "stylesheet", href: link }, link)))
                : null] }, void 0));
}
function Shadow(props) {
    const { children, inShadow, cssHandles } = props;
    // lazy load injecting custom style sheets because we don't want
    // errors in rehydration
    const [injectCustomStyles, setInjectCustomStyles] = useState$1(false);
    useEffect(() => {
        setInjectCustomStyles(true);
    }, []);
    return (jsxs(shadowContext.Provider, Object.assign({ value: inShadow }, { children: [injectCustomStyles ? (jsxs(Fragment, { children: [jsx(CustomGlobalStyles, {}, void 0), inShadow ? jsx(LinkAssets, { cssHandles: cssHandles }, void 0) : null] }, void 0)) : null, children] }), void 0));
}
Shadow.LinkAllAssets = LinkAllAssets;

var React$1 = React__default;
var useState = React$1.useState;
var useCallback = React$1.useCallback;
var useLayoutEffect = React$1.useLayoutEffect;

function getSize(el) {
  if (!el) {
    return {
      width: 0,
      height: 0
    }
  }

  return {
    width: el.offsetWidth,
    height: el.offsetHeight
  }
}

function useComponentSize(ref) {
  var _useState = useState(getSize(ref ? ref.current : {}));
  var ComponentSize = _useState[0];
  var setComponentSize = _useState[1];

  var handleResize = useCallback(
    function handleResize() {
      if (ref.current) {
        setComponentSize(getSize(ref.current));
      }
    },
    [ref]
  );

  useLayoutEffect(
    function() {
      if (!ref.current) {
        return
      }

      handleResize();

      if (typeof ResizeObserver === 'function') {
        var resizeObserver = new ResizeObserver(function() {
          handleResize();
        });
        resizeObserver.observe(ref.current);

        return function() {
          resizeObserver.disconnect(ref.current);
          resizeObserver = null;
        }
      } else {
        window.addEventListener('resize', handleResize);

        return function() {
          window.removeEventListener('resize', handleResize);
        }
      }
    },
    [ref.current]
  );

  return ComponentSize
}

var componentSize = useComponentSize;

var classnames = {exports: {}};

/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

(function (module) {
/* global define */

(function () {

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString === Object.prototype.toString) {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				} else {
					classes.push(arg.toString());
				}
			}
		}

		return classes.join(' ');
	}

	if (module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else {
		window.classNames = classNames;
	}
}());
}(classnames));

var classNames = classnames.exports;

function _extends$3() {
  _extends$3 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$3.apply(this, arguments);
}

function _assertThisInitialized$3(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf$2(o, p) {
  _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$2(o, p);
}

function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$2(subClass, superClass);
}

function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$2(o);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$2()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf$2(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf$2(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf$2(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

/**
 * Create an error file out of errors.md for development and a simple web link to the full errors
 * in production mode.
 * @private
 */


var PolishedError = /*#__PURE__*/function (_Error) {
  _inheritsLoose$1(PolishedError, _Error);

  function PolishedError(code) {
    var _this;

    {
      _this = _Error.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + code + " for more information.") || this;
    }

    return _assertThisInitialized$3(_this);
  }

  return PolishedError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

function colorToInt(color) {
  return Math.round(color * 255);
}

function convertToInt(red, green, blue) {
  return colorToInt(red) + "," + colorToInt(green) + "," + colorToInt(blue);
}

function hslToRgb(hue, saturation, lightness, convert) {
  if (convert === void 0) {
    convert = convertToInt;
  }

  if (saturation === 0) {
    // achromatic
    return convert(lightness, lightness, lightness);
  } // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV


  var huePrime = (hue % 360 + 360) % 360 / 60;
  var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
  var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  var red = 0;
  var green = 0;
  var blue = 0;

  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }

  var lightnessModification = lightness - chroma / 2;
  var finalRed = red + lightnessModification;
  var finalGreen = green + lightnessModification;
  var finalBlue = blue + lightnessModification;
  return convert(finalRed, finalGreen, finalBlue);
}

var namedColorMap = {
  aliceblue: 'f0f8ff',
  antiquewhite: 'faebd7',
  aqua: '00ffff',
  aquamarine: '7fffd4',
  azure: 'f0ffff',
  beige: 'f5f5dc',
  bisque: 'ffe4c4',
  black: '000',
  blanchedalmond: 'ffebcd',
  blue: '0000ff',
  blueviolet: '8a2be2',
  brown: 'a52a2a',
  burlywood: 'deb887',
  cadetblue: '5f9ea0',
  chartreuse: '7fff00',
  chocolate: 'd2691e',
  coral: 'ff7f50',
  cornflowerblue: '6495ed',
  cornsilk: 'fff8dc',
  crimson: 'dc143c',
  cyan: '00ffff',
  darkblue: '00008b',
  darkcyan: '008b8b',
  darkgoldenrod: 'b8860b',
  darkgray: 'a9a9a9',
  darkgreen: '006400',
  darkgrey: 'a9a9a9',
  darkkhaki: 'bdb76b',
  darkmagenta: '8b008b',
  darkolivegreen: '556b2f',
  darkorange: 'ff8c00',
  darkorchid: '9932cc',
  darkred: '8b0000',
  darksalmon: 'e9967a',
  darkseagreen: '8fbc8f',
  darkslateblue: '483d8b',
  darkslategray: '2f4f4f',
  darkslategrey: '2f4f4f',
  darkturquoise: '00ced1',
  darkviolet: '9400d3',
  deeppink: 'ff1493',
  deepskyblue: '00bfff',
  dimgray: '696969',
  dimgrey: '696969',
  dodgerblue: '1e90ff',
  firebrick: 'b22222',
  floralwhite: 'fffaf0',
  forestgreen: '228b22',
  fuchsia: 'ff00ff',
  gainsboro: 'dcdcdc',
  ghostwhite: 'f8f8ff',
  gold: 'ffd700',
  goldenrod: 'daa520',
  gray: '808080',
  green: '008000',
  greenyellow: 'adff2f',
  grey: '808080',
  honeydew: 'f0fff0',
  hotpink: 'ff69b4',
  indianred: 'cd5c5c',
  indigo: '4b0082',
  ivory: 'fffff0',
  khaki: 'f0e68c',
  lavender: 'e6e6fa',
  lavenderblush: 'fff0f5',
  lawngreen: '7cfc00',
  lemonchiffon: 'fffacd',
  lightblue: 'add8e6',
  lightcoral: 'f08080',
  lightcyan: 'e0ffff',
  lightgoldenrodyellow: 'fafad2',
  lightgray: 'd3d3d3',
  lightgreen: '90ee90',
  lightgrey: 'd3d3d3',
  lightpink: 'ffb6c1',
  lightsalmon: 'ffa07a',
  lightseagreen: '20b2aa',
  lightskyblue: '87cefa',
  lightslategray: '789',
  lightslategrey: '789',
  lightsteelblue: 'b0c4de',
  lightyellow: 'ffffe0',
  lime: '0f0',
  limegreen: '32cd32',
  linen: 'faf0e6',
  magenta: 'f0f',
  maroon: '800000',
  mediumaquamarine: '66cdaa',
  mediumblue: '0000cd',
  mediumorchid: 'ba55d3',
  mediumpurple: '9370db',
  mediumseagreen: '3cb371',
  mediumslateblue: '7b68ee',
  mediumspringgreen: '00fa9a',
  mediumturquoise: '48d1cc',
  mediumvioletred: 'c71585',
  midnightblue: '191970',
  mintcream: 'f5fffa',
  mistyrose: 'ffe4e1',
  moccasin: 'ffe4b5',
  navajowhite: 'ffdead',
  navy: '000080',
  oldlace: 'fdf5e6',
  olive: '808000',
  olivedrab: '6b8e23',
  orange: 'ffa500',
  orangered: 'ff4500',
  orchid: 'da70d6',
  palegoldenrod: 'eee8aa',
  palegreen: '98fb98',
  paleturquoise: 'afeeee',
  palevioletred: 'db7093',
  papayawhip: 'ffefd5',
  peachpuff: 'ffdab9',
  peru: 'cd853f',
  pink: 'ffc0cb',
  plum: 'dda0dd',
  powderblue: 'b0e0e6',
  purple: '800080',
  rebeccapurple: '639',
  red: 'f00',
  rosybrown: 'bc8f8f',
  royalblue: '4169e1',
  saddlebrown: '8b4513',
  salmon: 'fa8072',
  sandybrown: 'f4a460',
  seagreen: '2e8b57',
  seashell: 'fff5ee',
  sienna: 'a0522d',
  silver: 'c0c0c0',
  skyblue: '87ceeb',
  slateblue: '6a5acd',
  slategray: '708090',
  slategrey: '708090',
  snow: 'fffafa',
  springgreen: '00ff7f',
  steelblue: '4682b4',
  tan: 'd2b48c',
  teal: '008080',
  thistle: 'd8bfd8',
  tomato: 'ff6347',
  turquoise: '40e0d0',
  violet: 'ee82ee',
  wheat: 'f5deb3',
  white: 'fff',
  whitesmoke: 'f5f5f5',
  yellow: 'ff0',
  yellowgreen: '9acd32'
};
/**
 * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.
 * @private
 */

function nameToHex(color) {
  if (typeof color !== 'string') return color;
  var normalizedColorName = color.toLowerCase();
  return namedColorMap[normalizedColorName] ? "#" + namedColorMap[normalizedColorName] : color;
}

var hexRegex = /^#[a-fA-F0-9]{6}$/;
var hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;
var reducedHexRegex = /^#[a-fA-F0-9]{3}$/;
var reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;
var rgbRegex = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i;
var rgbaRegex = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i;
var hslRegex = /^hsl\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i;
var hslaRegex = /^hsla\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i;
/**
 * Returns an RgbColor or RgbaColor object. This utility function is only useful
 * if want to extract a color component. With the color util `toColorString` you
 * can convert a RgbColor or RgbaColor object back to a string.
 *
 * @example
 * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1
 * const color1 = parseToRgb('rgb(255, 0, 0)');
 * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2
 * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');
 */

function parseToRgb(color) {
  if (typeof color !== 'string') {
    throw new PolishedError(3);
  }

  var normalizedColor = nameToHex(color);

  if (normalizedColor.match(hexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16)
    };
  }

  if (normalizedColor.match(hexRgbaRegex)) {
    var alpha = parseFloat((parseInt("" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[2], 16),
      green: parseInt("" + normalizedColor[3] + normalizedColor[4], 16),
      blue: parseInt("" + normalizedColor[5] + normalizedColor[6], 16),
      alpha: alpha
    };
  }

  if (normalizedColor.match(reducedHexRegex)) {
    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16)
    };
  }

  if (normalizedColor.match(reducedRgbaHexRegex)) {
    var _alpha = parseFloat((parseInt("" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));

    return {
      red: parseInt("" + normalizedColor[1] + normalizedColor[1], 16),
      green: parseInt("" + normalizedColor[2] + normalizedColor[2], 16),
      blue: parseInt("" + normalizedColor[3] + normalizedColor[3], 16),
      alpha: _alpha
    };
  }

  var rgbMatched = rgbRegex.exec(normalizedColor);

  if (rgbMatched) {
    return {
      red: parseInt("" + rgbMatched[1], 10),
      green: parseInt("" + rgbMatched[2], 10),
      blue: parseInt("" + rgbMatched[3], 10)
    };
  }

  var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));

  if (rgbaMatched) {
    return {
      red: parseInt("" + rgbaMatched[1], 10),
      green: parseInt("" + rgbaMatched[2], 10),
      blue: parseInt("" + rgbaMatched[3], 10),
      alpha: parseFloat("" + rgbaMatched[4])
    };
  }

  var hslMatched = hslRegex.exec(normalizedColor);

  if (hslMatched) {
    var hue = parseInt("" + hslMatched[1], 10);
    var saturation = parseInt("" + hslMatched[2], 10) / 100;
    var lightness = parseInt("" + hslMatched[3], 10) / 100;
    var rgbColorString = "rgb(" + hslToRgb(hue, saturation, lightness) + ")";
    var hslRgbMatched = rgbRegex.exec(rgbColorString);

    if (!hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, rgbColorString);
    }

    return {
      red: parseInt("" + hslRgbMatched[1], 10),
      green: parseInt("" + hslRgbMatched[2], 10),
      blue: parseInt("" + hslRgbMatched[3], 10)
    };
  }

  var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));

  if (hslaMatched) {
    var _hue = parseInt("" + hslaMatched[1], 10);

    var _saturation = parseInt("" + hslaMatched[2], 10) / 100;

    var _lightness = parseInt("" + hslaMatched[3], 10) / 100;

    var _rgbColorString = "rgb(" + hslToRgb(_hue, _saturation, _lightness) + ")";

    var _hslRgbMatched = rgbRegex.exec(_rgbColorString);

    if (!_hslRgbMatched) {
      throw new PolishedError(4, normalizedColor, _rgbColorString);
    }

    return {
      red: parseInt("" + _hslRgbMatched[1], 10),
      green: parseInt("" + _hslRgbMatched[2], 10),
      blue: parseInt("" + _hslRgbMatched[3], 10),
      alpha: parseFloat("" + hslaMatched[4])
    };
  }

  throw new PolishedError(5);
}

function rgbToHsl(color) {
  // make sure rgb are contained in a set of [0, 255]
  var red = color.red / 255;
  var green = color.green / 255;
  var blue = color.blue / 255;
  var max = Math.max(red, green, blue);
  var min = Math.min(red, green, blue);
  var lightness = (max + min) / 2;

  if (max === min) {
    // achromatic
    if (color.alpha !== undefined) {
      return {
        hue: 0,
        saturation: 0,
        lightness: lightness,
        alpha: color.alpha
      };
    } else {
      return {
        hue: 0,
        saturation: 0,
        lightness: lightness
      };
    }
  }

  var hue;
  var delta = max - min;
  var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);

  switch (max) {
    case red:
      hue = (green - blue) / delta + (green < blue ? 6 : 0);
      break;

    case green:
      hue = (blue - red) / delta + 2;
      break;

    default:
      // blue case
      hue = (red - green) / delta + 4;
      break;
  }

  hue *= 60;

  if (color.alpha !== undefined) {
    return {
      hue: hue,
      saturation: saturation,
      lightness: lightness,
      alpha: color.alpha
    };
  }

  return {
    hue: hue,
    saturation: saturation,
    lightness: lightness
  };
}

/**
 * Returns an HslColor or HslaColor object. This utility function is only useful
 * if want to extract a color component. With the color util `toColorString` you
 * can convert a HslColor or HslaColor object back to a string.
 *
 * @example
 * // Assigns `{ hue: 0, saturation: 1, lightness: 0.5 }` to color1
 * const color1 = parseToHsl('rgb(255, 0, 0)');
 * // Assigns `{ hue: 128, saturation: 1, lightness: 0.5, alpha: 0.75 }` to color2
 * const color2 = parseToHsl('hsla(128, 100%, 50%, 0.75)');
 */
function parseToHsl(color) {
  // Note: At a later stage we can optimize this function as right now a hsl
  // color would be parsed converted to rgb values and converted back to hsl.
  return rgbToHsl(parseToRgb(color));
}

/**
 * Reduces hex values if possible e.g. #ff8866 to #f86
 * @private
 */
var reduceHexValue = function reduceHexValue(value) {
  if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {
    return "#" + value[1] + value[3] + value[5];
  }

  return value;
};

function numberToHex(value) {
  var hex = value.toString(16);
  return hex.length === 1 ? "0" + hex : hex;
}

function colorToHex(color) {
  return numberToHex(Math.round(color * 255));
}

function convertToHex(red, green, blue) {
  return reduceHexValue("#" + colorToHex(red) + colorToHex(green) + colorToHex(blue));
}

function hslToHex(hue, saturation, lightness) {
  return hslToRgb(hue, saturation, lightness, convertToHex);
}

/**
 * Returns a string value for the color. The returned result is the smallest possible hex notation.
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: hsl(359, 0.75, 0.4),
 *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${hsl(359, 0.75, 0.4)};
 *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};
 * `
 *
 * // CSS in JS Output
 *
 * element {
 *   background: "#b3191c";
 *   background: "#b3191c";
 * }
 */
function hsl(value, saturation, lightness) {
  if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number') {
    return hslToHex(value, saturation, lightness);
  } else if (typeof value === 'object' && saturation === undefined && lightness === undefined) {
    return hslToHex(value.hue, value.saturation, value.lightness);
  }

  throw new PolishedError(1);
}

/**
 * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: hsla(359, 0.75, 0.4, 0.7),
 *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),
 *   background: hsla(359, 0.75, 0.4, 1),
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${hsla(359, 0.75, 0.4, 0.7)};
 *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};
 *   background: ${hsla(359, 0.75, 0.4, 1)};
 * `
 *
 * // CSS in JS Output
 *
 * element {
 *   background: "rgba(179,25,28,0.7)";
 *   background: "rgba(179,25,28,0.7)";
 *   background: "#b3191c";
 * }
 */
function hsla(value, saturation, lightness, alpha) {
  if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number' && typeof alpha === 'number') {
    return alpha >= 1 ? hslToHex(value, saturation, lightness) : "rgba(" + hslToRgb(value, saturation, lightness) + "," + alpha + ")";
  } else if (typeof value === 'object' && saturation === undefined && lightness === undefined && alpha === undefined) {
    return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : "rgba(" + hslToRgb(value.hue, value.saturation, value.lightness) + "," + value.alpha + ")";
  }

  throw new PolishedError(2);
}

/**
 * Returns a string value for the color. The returned result is the smallest possible hex notation.
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: rgb(255, 205, 100),
 *   background: rgb({ red: 255, green: 205, blue: 100 }),
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${rgb(255, 205, 100)};
 *   background: ${rgb({ red: 255, green: 205, blue: 100 })};
 * `
 *
 * // CSS in JS Output
 *
 * element {
 *   background: "#ffcd64";
 *   background: "#ffcd64";
 * }
 */
function rgb(value, green, blue) {
  if (typeof value === 'number' && typeof green === 'number' && typeof blue === 'number') {
    return reduceHexValue("#" + numberToHex(value) + numberToHex(green) + numberToHex(blue));
  } else if (typeof value === 'object' && green === undefined && blue === undefined) {
    return reduceHexValue("#" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));
  }

  throw new PolishedError(6);
}

/**
 * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.
 *
 * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: rgba(255, 205, 100, 0.7),
 *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),
 *   background: rgba(255, 205, 100, 1),
 *   background: rgba('#ffffff', 0.4),
 *   background: rgba('black', 0.7),
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${rgba(255, 205, 100, 0.7)};
 *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};
 *   background: ${rgba(255, 205, 100, 1)};
 *   background: ${rgba('#ffffff', 0.4)};
 *   background: ${rgba('black', 0.7)};
 * `
 *
 * // CSS in JS Output
 *
 * element {
 *   background: "rgba(255,205,100,0.7)";
 *   background: "rgba(255,205,100,0.7)";
 *   background: "#ffcd64";
 *   background: "rgba(255,255,255,0.4)";
 *   background: "rgba(0,0,0,0.7)";
 * }
 */
function rgba(firstValue, secondValue, thirdValue, fourthValue) {
  if (typeof firstValue === 'string' && typeof secondValue === 'number') {
    var rgbValue = parseToRgb(firstValue);
    return "rgba(" + rgbValue.red + "," + rgbValue.green + "," + rgbValue.blue + "," + secondValue + ")";
  } else if (typeof firstValue === 'number' && typeof secondValue === 'number' && typeof thirdValue === 'number' && typeof fourthValue === 'number') {
    return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : "rgba(" + firstValue + "," + secondValue + "," + thirdValue + "," + fourthValue + ")";
  } else if (typeof firstValue === 'object' && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {
    return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : "rgba(" + firstValue.red + "," + firstValue.green + "," + firstValue.blue + "," + firstValue.alpha + ")";
  }

  throw new PolishedError(7);
}

var isRgb = function isRgb(color) {
  return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
};

var isRgba = function isRgba(color) {
  return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && typeof color.alpha === 'number';
};

var isHsl = function isHsl(color) {
  return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');
};

var isHsla = function isHsla(color) {
  return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && typeof color.alpha === 'number';
};
/**
 * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.
 * This util is useful in case you only know on runtime which color object is
 * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: toColorString({ red: 255, green: 205, blue: 100 }),
 *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),
 *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),
 *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};
 *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};
 *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};
 *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};
 * `
 *
 * // CSS in JS Output
 * element {
 *   background: "#ffcd64";
 *   background: "rgba(255,205,100,0.72)";
 *   background: "#00f";
 *   background: "rgba(179,25,25,0.72)";
 * }
 */


function toColorString(color) {
  if (typeof color !== 'object') throw new PolishedError(8);
  if (isRgba(color)) return rgba(color);
  if (isRgb(color)) return rgb(color);
  if (isHsla(color)) return hsla(color);
  if (isHsl(color)) return hsl(color);
  throw new PolishedError(8);
}

// Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js
// eslint-disable-next-line no-unused-vars
// eslint-disable-next-line no-unused-vars
// eslint-disable-next-line no-redeclare
function curried(f, length, acc) {
  return function fn() {
    // eslint-disable-next-line prefer-rest-params
    var combined = acc.concat(Array.prototype.slice.call(arguments));
    return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);
  };
} // eslint-disable-next-line no-redeclare


function curry(f) {
  // eslint-disable-line no-redeclare
  return curried(f, f.length, []);
}

/**
 * Returns the complement of the provided color. This is identical to adjustHue(180, <color>).
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: complement('#448'),
 *   background: complement('rgba(204,205,100,0.7)'),
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${complement('#448')};
 *   background: ${complement('rgba(204,205,100,0.7)')};
 * `
 *
 * // CSS in JS Output
 * element {
 *   background: "#884";
 *   background: "rgba(153,153,153,0.7)";
 * }
 */

function complement(color) {
  if (color === 'transparent') return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends$3({}, hslColor, {
    hue: (hslColor.hue + 180) % 360
  }));
}

function guard(lowerBoundary, upperBoundary, value) {
  return Math.max(lowerBoundary, Math.min(upperBoundary, value));
}

/**
 * Returns a string value for the darkened color.
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: darken(0.2, '#FFCD64'),
 *   background: darken('0.2', 'rgba(255,205,100,0.7)'),
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${darken(0.2, '#FFCD64')};
 *   background: ${darken('0.2', 'rgba(255,205,100,0.7)')};
 * `
 *
 * // CSS in JS Output
 *
 * element {
 *   background: "#ffbd31";
 *   background: "rgba(255,189,49,0.7)";
 * }
 */

function darken(amount, color) {
  if (color === 'transparent') return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends$3({}, hslColor, {
    lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))
  }));
} // prettier-ignore


var curriedDarken = /*#__PURE__*/curry
/* ::<number | string, string, string> */
(darken);

/**
 * Decreases the intensity of a color. Its range is between 0 to 1. The first
 * argument of the desaturate function is the amount by how much the color
 * intensity should be decreased.
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: desaturate(0.2, '#CCCD64'),
 *   background: desaturate('0.2', 'rgba(204,205,100,0.7)'),
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${desaturate(0.2, '#CCCD64')};
 *   background: ${desaturate('0.2', 'rgba(204,205,100,0.7)')};
 * `
 *
 * // CSS in JS Output
 * element {
 *   background: "#b8b979";
 *   background: "rgba(184,185,121,0.7)";
 * }
 */

function desaturate(amount, color) {
  if (color === 'transparent') return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends$3({}, hslColor, {
    saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))
  }));
} // prettier-ignore


var curriedDesaturate = /*#__PURE__*/curry
/* ::<number | string, string, string> */
(desaturate);

/**
 * Returns a string value for the lightened color.
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: lighten(0.2, '#CCCD64'),
 *   background: lighten('0.2', 'rgba(204,205,100,0.7)'),
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${lighten(0.2, '#FFCD64')};
 *   background: ${lighten('0.2', 'rgba(204,205,100,0.7)')};
 * `
 *
 * // CSS in JS Output
 *
 * element {
 *   background: "#e5e6b1";
 *   background: "rgba(229,230,177,0.7)";
 * }
 */

function lighten(amount, color) {
  if (color === 'transparent') return color;
  var hslColor = parseToHsl(color);
  return toColorString(_extends$3({}, hslColor, {
    lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))
  }));
} // prettier-ignore


var curriedLighten = /*#__PURE__*/curry
/* ::<number | string, string, string> */
(lighten);

/**
 * Decreases the opacity of a color. Its range for the amount is between 0 to 1.
 *
 *
 * @example
 * // Styles as object usage
 * const styles = {
 *   background: transparentize(0.1, '#fff');
 *   background: transparentize(0.2, 'hsl(0, 0%, 100%)'),
 *   background: transparentize('0.5', 'rgba(255, 0, 0, 0.8)'),
 * }
 *
 * // styled-components usage
 * const div = styled.div`
 *   background: ${transparentize(0.1, '#fff')};
 *   background: ${transparentize(0.2, 'hsl(0, 0%, 100%)')},
 *   background: ${transparentize('0.5', 'rgba(255, 0, 0, 0.8)')},
 * `
 *
 * // CSS in JS Output
 *
 * element {
 *   background: "rgba(255,255,255,0.9)";
 *   background: "rgba(255,255,255,0.8)";
 *   background: "rgba(255,0,0,0.3)";
 * }
 */

function transparentize(amount, color) {
  if (color === 'transparent') return color;
  var parsedColor = parseToRgb(color);
  var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;

  var colorWithAlpha = _extends$3({}, parsedColor, {
    alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)
  });

  return rgba(colorWithAlpha);
} // prettier-ignore


var curriedTransparentize = /*#__PURE__*/curry
/* ::<number | string, string, string> */
(transparentize);

/**
 * Get a BEM compatible className given baseclass and modifiers.
 *
 * @param baseClass Main className.
 * @param modifiers Key=>Value pair of modifiers.
 * @param additionalClasses Additional classes we need to include.
 */
function getBemClassName(baseClass, modifiers, additionalClasses) {
    const modifierClassNames = {};
    if (modifiers) {
        Object.keys(modifiers).forEach(k => {
            modifierClassNames[`${baseClass}--${k}`] = !!modifiers[k];
        });
    }
    return classNames(baseClass, additionalClasses, modifierClassNames);
}
function getBemElement(baseClass, elm, additionalClasses) {
    return classNames(`${baseClass}__${elm}`, additionalClasses);
}
/**
 * See if current size of the container matches the breakpoint for the given
 * target.
 *
 * @param size Component size.
 * @param target Target size we are looking for.
 */
function useIsResponsiveBreakpoint(size, target) {
    const { breakpoints } = useTheme();
    if (target === 'mobile') {
        return true;
    }
    if (typeof target === 'number') {
        return size.width > target;
    }
    return size.width >= breakpoints[target];
}
/**
 * A hook to get breakpoint class names with BEM formatting. You need to pass
 * the size of the responsive container yourself.
 *
 * @param size component size.
 * @param baseClass base class for BEM.
 * @param additionalModifiers Extra modifiers for BEM classes.
 * @param additionalClasses Extra classNames.
 */
function useResponsiveClassNames(size, baseClass, additionalModifiers = {}, additionalClasses) {
    const { breakpoints } = useTheme();
    const modifiers = {
        ...additionalModifiers,
        'size-mobile': true,
        'size-tablet': size.width >= breakpoints.tablet,
        'size-desktop': size.width >= breakpoints.desktop,
        'size-desktopHd': size.width >= breakpoints.desktopHd,
    };
    return getBemClassName(baseClass, modifiers, additionalClasses);
}
/**
 * Given a number add the unit next to it so that it can be used as a CSS
 * value. Useful for creating font-size, padding, margin etc from numbers.
 *
 * @param size Font Size.
 * @param unit (Optional) CSS Unit, defaults to `'px'`.
 */
function numToCssSize(size, unit = 'px') {
    return `${size}${unit}`;
}
/**
 * Get multiple transition for CSS transition property.
 *
 * @param properties List of CSS Properties.
 * @param transition Transition value.
 */
function getMultipleTransition(properties, transition) {
    return properties.map(prop => `${prop} ${transition}`).join(', ');
}
function getMultipleTransitionsWithWillChange(properties, transition, additionalWillChanges) {
    const willChanges = [...properties];
    if (additionalWillChanges) {
        willChanges.push(...additionalWillChanges);
    }
    return `${getMultipleTransition(properties, transition)}; will-change: ${willChanges.join(', ')};`;
}
// General CSS Reset
const cssReset = css `
	box-sizing: border-box;
	*,
	*::before,
	*::after {
		box-sizing: border-box;
	}
	margin: 0;
	padding: 0;
	border: 0;
	outline: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
	background: transparent;
	line-height: 1.5;
	text-transform: none;
	background-color: transparent;

	&:focus {
		outline: 0;
	}
`;
// Text Input CSS Reset, use it with general cssReset
const inputCssReset = css `
	appearance: none;
	box-sizing: content-box;
`;
// TextArea CSS Reset, use it with general cssReset
css `
	overflow: auto;
	vertical-align: top;
	resize: vertical;
`;
// Prose CSS for instantly beautifying user content.
const proseCss = css `
	p,
	ul,
	ol,
	blockquote,
	li,
	strong,
	em,
	u,
	div.para {
		line-height: 1.5;
		font-size: inherit;
	}

	ul {
		list-style: disc;
	}
	ol {
		list-style: decimal;
	}

	blockquote {
		margin: 0 0 0.75em 0.75em;
		padding: 0.625em;
		border-left: 4px solid ${props => props.theme.borderColorSplit};
		font-style: italic;
	}

	/* Copy & Lists */
	p,
	div.para {
		margin: 0.75em 0 0 0;
		&:only-child {
			margin: 0;
		}
		&:first-child {
			margin-top: 0;
		}
	}
	ul,
	ol {
		margin: 0.75em 0 0.75em 2.5em;
		padding: 0;
	}

	div.para > div.para:last-child {
		margin: 0;
	}

	ul ul,
	ol ul,
	ul ol,
	ol ol {
		margin-top: 0;
		margin-bottom: 0;
	}
	blockquote {
		margin: 0.75em 0;
	}
	/* Headings */
	h1,
	h2,
	h3,
	h4,
	h5,
	h6 {
		margin: 0.6em 0 0 0;
		line-height: 1.2;
		clear: both;
	}
	h1 {
		font-size: ${props => numToCssSize(props.theme.fz.large5 / props.theme.fz.base, 'em')};
		line-height: 1.2;
	}
	h2 {
		font-size: ${props => numToCssSize(props.theme.fz.large3 / props.theme.fz.base, 'em')};
	}
	h3 {
		font-size: ${props => numToCssSize(props.theme.fz.large2 / props.theme.fz.base, 'em')};
	}
	h4 {
		font-size: ${props => numToCssSize(props.theme.fz.large1 / props.theme.fz.base, 'em')};
	}
	h5 {
		font-size: ${props => numToCssSize(props.theme.fz.small1 / props.theme.fz.base, 'em')};
	}
	h6 {
		font-size: ${props => numToCssSize(props.theme.fz.small2 / props.theme.fz.base, 'em')};
	}
	/* Tables */
	table {
		margin-top: ${props => numToCssSize(props.theme.gutter)};
		border-spacing: 0px;
		border-collapse: collapse;
		clear: both;
	}
	table td,
	table th {
		padding: 0;
		line-height: 1.5;
	}
	/* Code blocks */
	code {
		vertical-align: bottom;
		color: ${props => props.theme.textColorSecondary};
	}
	pre {
		max-height: 300px;
		width: 100%;
		overflow: auto;
		margin: 0.75em 0 0 0;
		color: ${props => props.theme.greyBgText};
		background-color: ${props => props.theme.greyDarkColor};
		padding: 0.3125em;
		tab-size: 2;
		a {
			color: ${props => props.theme.primaryBackgroundColor};
			&:hover {
				color: ${props => props.theme.primaryLightColor};
			}
		}
	}
	pre,
	pre code {
		color: ${props => props.theme.greyBgText};
		background-color: ${props => props.theme.greyDarkColor};
		font-family: ${props => props.theme.fontFamilyMono};
	}

	p,
	h1,
	h2,
	h3,
	h4,
	h5,
	h6,
	blockquote,
	table,
	pre {
		&:first-child {
			margin-top: 0;
		}
	}

	strong {
		font-weight: bold;
	}
	u {
		text-decoration: underline;
	}
	em {
		font-style: italic;
	}

	a {
		color: ${props => props.theme.linkColor};
		text-decoration: underline;
		&:hover {
			color: ${props => props.theme.primaryLightColor};
			text-decoration: none;
		}
	}
`;
/**
 * @link https://css-tricks.com/snippets/css/prevent-long-urls-from-breaking-out-of-container/
 */
const longWordBreakCss = css `
	overflow-wrap: break-word;
	word-wrap: break-word;
	word-break: break-word;
	hyphens: auto;
`;
const textEllipsisCss = css `
	max-width: ${props => props.maxWidth ?? '100%'};
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
`;
const userInputWhiteSpace = css `
	white-space: pre-wrap;
	overflow-wrap: break-word;
`;
/**
 * Get style value for alignment of an element.
 *
 * @param align Type of align.
 */
function getStyleWithAlignment(align) {
    if (align) {
        return {
            textAlign: align,
        };
    }
    return undefined;
}
/**
 * Get next even number for the given number.
 *
 * @param num Number to check.
 */
function getNextEvenNumber(num) {
    let evenNumber = Math.ceil(num);
    if (evenNumber % 2 !== 0) {
        evenNumber += 1;
    }
    return evenNumber;
}
const sharedScrollBarCss = css `
	&::-webkit-scrollbar-thumb {
		background-color: ${props => props.theme.borderColorSplit};
		&:hover,
		&:active {
			background-color: ${props => props.theme.borderColorBase};
		}
	}
`;
const sharedHorizontalScrollBarCss = css `
	overflow-x: scroll;
	&::-webkit-scrollbar {
		background-color: ${props => props.theme.backgroundHover};
		height: ${props => numToCssSize(props.theme.gutter / 2)};
	}
`;
const scrollBarHorizontalCss = css `
	${sharedHorizontalScrollBarCss}
	${sharedScrollBarCss};
`;
const sharedVerticalScrollBarCss = css `
	overflow-y: scroll;
	&::-webkit-scrollbar {
		background-color: ${props => props.theme.backgroundHover};
		width: ${props => numToCssSize(props.theme.gutter / 2)};
	}
`;
const scrollBarVerticalCss = css `
	${sharedVerticalScrollBarCss};
	${sharedScrollBarCss};
`;
css `
	overflow: scroll;
	&::-webkit-scrollbar {
		background-color: ${props => props.theme.backgroundHover};
		&:horizontal {
			height: ${props => numToCssSize(props.theme.gutter / 2)};
		}
		&:vertical {
			width: ${props => numToCssSize(props.theme.gutter / 2)};
		}
	}
	&::-webkit-scrollbar-corner {
		background-color: ${props => props.theme.backgroundHover};
	}
	${sharedScrollBarCss};
`;
const screenReaderTextCss = css `
	border: 0;
	clip: rect(1px, 1px, 1px, 1px);
	clip-path: inset(50%);
	height: 1px;
	margin: -1px;
	overflow: hidden;
	padding: 0;
	position: absolute;
	width: 1px;
	word-wrap: normal !important;
`;
const buttonResetCss = css `
	text-align: left;
	background: transparent;
	border: 0 none;
	outline: none;
	margin: 0;
	padding: 0;
	cursor: pointer;
	display: inline;
	font-style: normal;
	text-decoration: none;
	border-radius: 0;
`;
function useClampedSpringConfig(type) {
    const theme = useTheme();
    const config = type === 'slow'
        ? theme.springConfigSlow
        : type === 'general'
            ? theme.springConfigGeneral
            : theme.springConfigStiff;
    return useMemo(() => ({ ...config, clamp: true }), [config]);
}

/* tslint:disable */
/* eslint-disable */
// @generated
// This file was automatically generated and should not be edited.
//==============================================================
// START Enums and Input Objects
//==============================================================
/**
 * Button icon position.
 */
var ButtonIconPositionEnum;
(function (ButtonIconPositionEnum) {
    ButtonIconPositionEnum["AFTER"] = "AFTER";
    ButtonIconPositionEnum["BEFORE"] = "BEFORE";
})(ButtonIconPositionEnum || (ButtonIconPositionEnum = {}));
/**
 * Button open type.
 */
var ButtonOpenTypeEnum;
(function (ButtonOpenTypeEnum) {
    ButtonOpenTypeEnum["BLANK"] = "BLANK";
    ButtonOpenTypeEnum["POPUP"] = "POPUP";
    ButtonOpenTypeEnum["SELF"] = "SELF";
})(ButtonOpenTypeEnum || (ButtonOpenTypeEnum = {}));
/**
 * Possible action in conditional logic consequence.
 */
var ConsequenceActionEnum;
(function (ConsequenceActionEnum) {
    ConsequenceActionEnum["HIDE_FIELDS"] = "HIDE_FIELDS";
    ConsequenceActionEnum["HIDE_PAGES"] = "HIDE_PAGES";
    ConsequenceActionEnum["SET_VALUE_OF"] = "SET_VALUE_OF";
    ConsequenceActionEnum["SHOW_FIELDS"] = "SHOW_FIELDS";
    ConsequenceActionEnum["SHOW_PAGES"] = "SHOW_PAGES";
})(ConsequenceActionEnum || (ConsequenceActionEnum = {}));
/**
 * Dark theme mode.
 */
var DarkThemeModeEnum;
(function (DarkThemeModeEnum) {
    DarkThemeModeEnum["ALWAYS"] = "ALWAYS";
    DarkThemeModeEnum["AUTO"] = "AUTO";
    DarkThemeModeEnum["OFF"] = "OFF";
})(DarkThemeModeEnum || (DarkThemeModeEnum = {}));
/**
 * Possible comparison in conditional logic.
 */
var EventComparisonEnum;
(function (EventComparisonEnum) {
    EventComparisonEnum["CONTAINS"] = "CONTAINS";
    EventComparisonEnum["ENDS_WITH"] = "ENDS_WITH";
    EventComparisonEnum["EQUALS_TO"] = "EQUALS_TO";
    EventComparisonEnum["GREATER_THAN"] = "GREATER_THAN";
    EventComparisonEnum["LESS_THAN"] = "LESS_THAN";
    EventComparisonEnum["STARTS_WITH"] = "STARTS_WITH";
})(EventComparisonEnum || (EventComparisonEnum = {}));
/**
 * Possible comparison in conditional logic.
 */
var EventHasEnum;
(function (EventHasEnum) {
    EventHasEnum["LENGTH"] = "LENGTH";
    EventHasEnum["VALUE"] = "VALUE";
})(EventHasEnum || (EventHasEnum = {}));
/**
 * Event operation.
 */
var EventOperationEnum;
(function (EventOperationEnum) {
    EventOperationEnum["IS"] = "IS";
    EventOperationEnum["ISNOT"] = "ISNOT";
})(EventOperationEnum || (EventOperationEnum = {}));
/**
 * Relation logic with the next event in the logic chain.
 */
var EventRelationEnum;
(function (EventRelationEnum) {
    EventRelationEnum["AND"] = "AND";
    EventRelationEnum["OR"] = "OR";
})(EventRelationEnum || (EventRelationEnum = {}));
/**
 * Form element category.
 */
var FormElementCategoryEnum;
(function (FormElementCategoryEnum) {
    FormElementCategoryEnum["CHOICE"] = "CHOICE";
    FormElementCategoryEnum["DESIGN"] = "DESIGN";
    FormElementCategoryEnum["INPUT"] = "INPUT";
    FormElementCategoryEnum["SECURITY"] = "SECURITY";
})(FormElementCategoryEnum || (FormElementCategoryEnum = {}));
/**
 * Pagination restriction type of a form.
 */
var FormPaginationRestrictionEnum;
(function (FormPaginationRestrictionEnum) {
    FormPaginationRestrictionEnum["NEXT_ON_ALL_VALID"] = "NEXT_ON_ALL_VALID";
    FormPaginationRestrictionEnum["NONE"] = "NONE";
    FormPaginationRestrictionEnum["ONLY_WHEN_ALL_VALID"] = "ONLY_WHEN_ALL_VALID";
})(FormPaginationRestrictionEnum || (FormPaginationRestrictionEnum = {}));
/**
 * Form payment type.
 */
var FormPaymentTypeEnum;
(function (FormPaymentTypeEnum) {
    FormPaymentTypeEnum["ONETIME"] = "ONETIME";
    FormPaymentTypeEnum["SUBSCRIPTION"] = "SUBSCRIPTION";
})(FormPaymentTypeEnum || (FormPaymentTypeEnum = {}));
/**
 * Form payments coupon type.
 */
var FormPaymentsCouponTypeEnum;
(function (FormPaymentsCouponTypeEnum) {
    FormPaymentsCouponTypeEnum["PERCENTAGE"] = "PERCENTAGE";
    FormPaymentsCouponTypeEnum["VALUE"] = "VALUE";
})(FormPaymentsCouponTypeEnum || (FormPaymentsCouponTypeEnum = {}));
/**
 * Form settings background scroll.
 */
var FormSettingsBackgroundAttachmentEnum;
(function (FormSettingsBackgroundAttachmentEnum) {
    FormSettingsBackgroundAttachmentEnum["FIXED"] = "FIXED";
    FormSettingsBackgroundAttachmentEnum["LOCAL"] = "LOCAL";
    FormSettingsBackgroundAttachmentEnum["SCROLL"] = "SCROLL";
})(FormSettingsBackgroundAttachmentEnum || (FormSettingsBackgroundAttachmentEnum = {}));
/**
 * Form settings background origin.
 */
var FormSettingsBackgroundOriginAndClipEnum;
(function (FormSettingsBackgroundOriginAndClipEnum) {
    FormSettingsBackgroundOriginAndClipEnum["BORDER_BOX"] = "BORDER_BOX";
    FormSettingsBackgroundOriginAndClipEnum["CONTENT_BOX"] = "CONTENT_BOX";
    FormSettingsBackgroundOriginAndClipEnum["PADDING_BOX"] = "PADDING_BOX";
})(FormSettingsBackgroundOriginAndClipEnum || (FormSettingsBackgroundOriginAndClipEnum = {}));
/**
 * Form settings background repeat.
 */
var FormSettingsBackgroundRepeatEnum;
(function (FormSettingsBackgroundRepeatEnum) {
    FormSettingsBackgroundRepeatEnum["REPEAT_BOTH"] = "REPEAT_BOTH";
    FormSettingsBackgroundRepeatEnum["REPEAT_NONE"] = "REPEAT_NONE";
    FormSettingsBackgroundRepeatEnum["REPEAT_X"] = "REPEAT_X";
    FormSettingsBackgroundRepeatEnum["REPEAT_Y"] = "REPEAT_Y";
})(FormSettingsBackgroundRepeatEnum || (FormSettingsBackgroundRepeatEnum = {}));
/**
 * Form settings limit on login values.
 */
var FormSettingsLimitOnLoginEnum;
(function (FormSettingsLimitOnLoginEnum) {
    FormSettingsLimitOnLoginEnum["LOGGED_IN"] = "LOGGED_IN";
    FormSettingsLimitOnLoginEnum["LOGGED_OUT"] = "LOGGED_OUT";
    FormSettingsLimitOnLoginEnum["NONE"] = "NONE";
})(FormSettingsLimitOnLoginEnum || (FormSettingsLimitOnLoginEnum = {}));
/**
 * Alignment.
 */
var GenericAlignmentEnum;
(function (GenericAlignmentEnum) {
    GenericAlignmentEnum["CENTER"] = "CENTER";
    GenericAlignmentEnum["JUSTIFY"] = "JUSTIFY";
    GenericAlignmentEnum["LEFT"] = "LEFT";
    GenericAlignmentEnum["RIGHT"] = "RIGHT";
})(GenericAlignmentEnum || (GenericAlignmentEnum = {}));
/**
 * Generic size.
 */
var GenericSizeEnum;
(function (GenericSizeEnum) {
    GenericSizeEnum["DEFAULT"] = "DEFAULT";
    GenericSizeEnum["LARGE"] = "LARGE";
    GenericSizeEnum["SMALL"] = "SMALL";
})(GenericSizeEnum || (GenericSizeEnum = {}));
/**
 * Heading size.
 */
var HeadingSizeEnum;
(function (HeadingSizeEnum) {
    HeadingSizeEnum["SIZE1"] = "SIZE1";
    HeadingSizeEnum["SIZE2"] = "SIZE2";
    HeadingSizeEnum["SIZE3"] = "SIZE3";
    HeadingSizeEnum["SIZE4"] = "SIZE4";
    HeadingSizeEnum["SIZE5"] = "SIZE5";
    HeadingSizeEnum["SIZE6"] = "SIZE6";
})(HeadingSizeEnum || (HeadingSizeEnum = {}));
/**
 * Heading tag.
 */
var HeadingTagEnum;
(function (HeadingTagEnum) {
    HeadingTagEnum["H1"] = "H1";
    HeadingTagEnum["H2"] = "H2";
    HeadingTagEnum["H3"] = "H3";
    HeadingTagEnum["H4"] = "H4";
    HeadingTagEnum["H5"] = "H5";
    HeadingTagEnum["H6"] = "H6";
    HeadingTagEnum["P"] = "P";
})(HeadingTagEnum || (HeadingTagEnum = {}));
/**
 * Mask type.
 */
var MaskTypeEnum;
(function (MaskTypeEnum) {
    MaskTypeEnum["NONE"] = "NONE";
    MaskTypeEnum["PRESET"] = "PRESET";
    MaskTypeEnum["REGEXP"] = "REGEXP";
    MaskTypeEnum["STRING"] = "STRING";
})(MaskTypeEnum || (MaskTypeEnum = {}));
/**
 * Number comparison.
 */
var NumberComparisonEnum;
(function (NumberComparisonEnum) {
    NumberComparisonEnum["EQUALS_TO"] = "EQUALS_TO";
    NumberComparisonEnum["GREATER_THAN"] = "GREATER_THAN";
    NumberComparisonEnum["LESS_THAN"] = "LESS_THAN";
})(NumberComparisonEnum || (NumberComparisonEnum = {}));
/**
 * Possible columns for Option type elements.
 */
var OptionColumnEnum;
(function (OptionColumnEnum) {
    OptionColumnEnum["AUTO"] = "AUTO";
    OptionColumnEnum["FOUR"] = "FOUR";
    OptionColumnEnum["ONE"] = "ONE";
    OptionColumnEnum["THREE"] = "THREE";
    OptionColumnEnum["TWO"] = "TWO";
})(OptionColumnEnum || (OptionColumnEnum = {}));
/**
 * Pagination type for a collection.
 */
var PaginationTypeEnum;
(function (PaginationTypeEnum) {
    PaginationTypeEnum["CURSOR"] = "CURSOR";
    PaginationTypeEnum["OFFSET"] = "OFFSET";
})(PaginationTypeEnum || (PaginationTypeEnum = {}));
/**
 * Automatic prefil type of an EForm element.
 */
var PrefilEnum;
(function (PrefilEnum) {
    PrefilEnum["META"] = "META";
    PrefilEnum["NONE"] = "NONE";
    PrefilEnum["URL"] = "URL";
})(PrefilEnum || (PrefilEnum = {}));
/**
 * Redirect type.
 */
var RedirectTypeEnum;
(function (RedirectTypeEnum) {
    RedirectTypeEnum["CONDITIONAL"] = "CONDITIONAL";
    RedirectTypeEnum["FLAT"] = "FLAT";
    RedirectTypeEnum["NONE"] = "NONE";
    RedirectTypeEnum["PORTAL"] = "PORTAL";
    RedirectTypeEnum["SCOREPERCENTAGE"] = "SCOREPERCENTAGE";
    RedirectTypeEnum["SCORETOTAL"] = "SCORETOTAL";
    RedirectTypeEnum["SUBMISSION"] = "SUBMISSION";
})(RedirectTypeEnum || (RedirectTypeEnum = {}));
/**
 * Resource view mode. Mainly used to list forms and submissions filters under these modes.
 */
var ResourceViewModeEnum;
(function (ResourceViewModeEnum) {
    ResourceViewModeEnum["ALL"] = "ALL";
    ResourceViewModeEnum["OWNED"] = "OWNED";
    ResourceViewModeEnum["SHARED"] = "SHARED";
    ResourceViewModeEnum["TRASHED"] = "TRASHED";
})(ResourceViewModeEnum || (ResourceViewModeEnum = {}));
/**
 * Score from to type.
 */
var ScoreFromToTypeEnum;
(function (ScoreFromToTypeEnum) {
    ScoreFromToTypeEnum["PERCENTAGE"] = "PERCENTAGE";
    ScoreFromToTypeEnum["VALUE"] = "VALUE";
})(ScoreFromToTypeEnum || (ScoreFromToTypeEnum = {}));
/**
 * Score operation.
 */
var ScoreOperationEnum;
(function (ScoreOperationEnum) {
    ScoreOperationEnum["ADD"] = "ADD";
    ScoreOperationEnum["SUBTRACT"] = "SUBTRACT";
})(ScoreOperationEnum || (ScoreOperationEnum = {}));
/**
 * Select type.
 */
var SelectTypeEnum;
(function (SelectTypeEnum) {
    SelectTypeEnum["MULTIPLE"] = "MULTIPLE";
    SelectTypeEnum["SINGLE"] = "SINGLE";
})(SelectTypeEnum || (SelectTypeEnum = {}));
/**
 * Settings appearance layout.
 */
var SettingsAppearanceContainerLayoutEnum;
(function (SettingsAppearanceContainerLayoutEnum) {
    SettingsAppearanceContainerLayoutEnum["FIXED"] = "FIXED";
    SettingsAppearanceContainerLayoutEnum["FLUID"] = "FLUID";
})(SettingsAppearanceContainerLayoutEnum || (SettingsAppearanceContainerLayoutEnum = {}));
/**
 * Settings appearance control alignment.
 */
var SettingsAppearanceControlAlignmentEnum;
(function (SettingsAppearanceControlAlignmentEnum) {
    SettingsAppearanceControlAlignmentEnum["CENTER"] = "CENTER";
    SettingsAppearanceControlAlignmentEnum["LEFT"] = "LEFT";
    SettingsAppearanceControlAlignmentEnum["RIGHT"] = "RIGHT";
})(SettingsAppearanceControlAlignmentEnum || (SettingsAppearanceControlAlignmentEnum = {}));
/**
 * Settings appearance control layout.
 */
var SettingsAppearanceControlLayoutEnum;
(function (SettingsAppearanceControlLayoutEnum) {
    SettingsAppearanceControlLayoutEnum["HORIZONTAL"] = "HORIZONTAL";
    SettingsAppearanceControlLayoutEnum["INLINE"] = "INLINE";
    SettingsAppearanceControlLayoutEnum["VERTICAL"] = "VERTICAL";
})(SettingsAppearanceControlLayoutEnum || (SettingsAppearanceControlLayoutEnum = {}));
/**
 * Settings appearance control types.
 */
var SettingsAppearanceControlTypeEnum;
(function (SettingsAppearanceControlTypeEnum) {
    SettingsAppearanceControlTypeEnum["BOXY"] = "BOXY";
    SettingsAppearanceControlTypeEnum["MATERIAL"] = "MATERIAL";
})(SettingsAppearanceControlTypeEnum || (SettingsAppearanceControlTypeEnum = {}));
/**
 * Settings appearance progress bar position.
 */
var SettingsAppearanceProgressBarPositionEnum;
(function (SettingsAppearanceProgressBarPositionEnum) {
    SettingsAppearanceProgressBarPositionEnum["BOTTOM"] = "BOTTOM";
    SettingsAppearanceProgressBarPositionEnum["TOP"] = "TOP";
})(SettingsAppearanceProgressBarPositionEnum || (SettingsAppearanceProgressBarPositionEnum = {}));
/**
 * Submission stat interval.
 */
var SubmissionStatIntervalEnum;
(function (SubmissionStatIntervalEnum) {
    SubmissionStatIntervalEnum["DAY"] = "DAY";
    SubmissionStatIntervalEnum["MONTH"] = "MONTH";
    SubmissionStatIntervalEnum["WEEK"] = "WEEK";
})(SubmissionStatIntervalEnum || (SubmissionStatIntervalEnum = {}));
/**
 * Submit timer.
 */
var SubmitTimerEnum;
(function (SubmitTimerEnum) {
    SubmitTimerEnum["NONE"] = "NONE";
    SubmitTimerEnum["OVERALL"] = "OVERALL";
    SubmitTimerEnum["PAGE_SPECIFIC"] = "PAGE_SPECIFIC";
})(SubmitTimerEnum || (SubmitTimerEnum = {}));
/**
 * Possible comparison in conditional logic.
 */
var TrashEnum;
(function (TrashEnum) {
    TrashEnum["NOT_TRASHED"] = "NOT_TRASHED";
    TrashEnum["TRASHED"] = "TRASHED";
})(TrashEnum || (TrashEnum = {}));
/**
 * Validation filter type.
 */
var ValidationFilterTypeEnum;
(function (ValidationFilterTypeEnum) {
    ValidationFilterTypeEnum["ALL"] = "ALL";
    ValidationFilterTypeEnum["EMAIL"] = "EMAIL";
    ValidationFilterTypeEnum["INTEGER"] = "INTEGER";
    ValidationFilterTypeEnum["NOLETTER"] = "NOLETTER";
    ValidationFilterTypeEnum["NONUMBER"] = "NONUMBER";
    ValidationFilterTypeEnum["NUMBER"] = "NUMBER";
    ValidationFilterTypeEnum["PHONE"] = "PHONE";
    ValidationFilterTypeEnum["URL"] = "URL";
})(ValidationFilterTypeEnum || (ValidationFilterTypeEnum = {}));
/**
 * Width presets.
 */
var WidthPresetsEnum;
(function (WidthPresetsEnum) {
    WidthPresetsEnum["FULL"] = "FULL";
    WidthPresetsEnum["HALF"] = "HALF";
    WidthPresetsEnum["MANUAL"] = "MANUAL";
    WidthPresetsEnum["ONEFOURTH"] = "ONEFOURTH";
    WidthPresetsEnum["ONETHIRD"] = "ONETHIRD";
    WidthPresetsEnum["THREEFOURTH"] = "THREEFOURTH";
    WidthPresetsEnum["TWOTHIRD"] = "TWOTHIRD";
})(WidthPresetsEnum || (WidthPresetsEnum = {}));
//==============================================================
// END Enums and Input Objects
//==============================================================

const CONTROLCLASS$p = 'wpeform-responsive-container';
const responsiveContainerSizeContext = createContext({
    height: 0,
    width: 0,
});
function useContainerSize() {
    return useContext(responsiveContainerSizeContext);
}
const responsiveContainerRefContext = createContext({ current: null });
function useResponsiveContainerRef() {
    return useContext(responsiveContainerRefContext);
}
const responsiveOuterContainerRefContext = createContext({ current: null });
function useResponsiveOuterContainerRef() {
    return useContext(responsiveOuterContainerRefContext);
}
const responsiveWidthBase = css `
	max-width: 100%;
	width: 100%;
	margin: 0 auto;
`;
const responsiveWidthFixed = css `
	@media screen and (min-width: ${props => numToCssSize(props.theme.breakpoints.tablet)}) {
		max-width: ${props => numToCssSize(props.theme.breakpoints.tablet)};
	}
	@media screen and (min-width: ${props => numToCssSize(props.theme.breakpoints.desktop)}) {
		max-width: ${props => numToCssSize(props.theme.breakpoints.desktop)};
	}
	@media screen and (min-width: ${props => numToCssSize(props.theme.breakpoints.desktopHd)}) {
		max-width: ${props => numToCssSize(props.theme.breakpoints.desktopHd)};
	}
`;
// InnerContainer responsible for responsive fluid or fixed layout
const InnerContainer = styled.div `
	${responsiveWidthBase};
`;
const Container$7 = styled.div `
	${cssReset};
	font-family: ${props => props.theme.fontFamilyBody};
	margin: 0 auto;
	max-width: ${props => props.width ?? '100%'};
	width: 100%;
	color: ${props => props.theme.textColor};
`;
const OuterContainer = styled.div `
	padding: ${props => props.noVerticalPadding ? 0 : numToCssSize(props.theme.gutter)}
		${props => props.noHorizontalPadding ? 0 : numToCssSize(props.theme.gutter)};
	margin: 0 auto;
	max-width: 1440px;

	&.${CONTROLCLASS$p}--layout-FIXED {
		${InnerContainer} {
			${responsiveWidthFixed};
		}
	}
`;
const ssRsize = { height: 960, width: 480 };
function SsrResponsiveContainer(props) {
    const { children, width = '100%', containerLayout = SettingsAppearanceContainerLayoutEnum.FIXED, noHorizontalPadding = false, noVerticalPadding = false, } = props;
    const containerRef = useRef(null);
    const className = useResponsiveClassNames(ssRsize, CONTROLCLASS$p, {
        [`layout-${containerLayout}`]: true,
    });
    return (
    // Outer container responsible for a max-width of 1440px (hard-coded)
    jsx(OuterContainer, Object.assign({ noHorizontalPadding: noHorizontalPadding, noVerticalPadding: noVerticalPadding, className: className }, { children: jsx(InnerContainer, { children: jsx(Container$7, Object.assign({ ref: containerRef, width: width }, { children: jsx(responsiveContainerSizeContext.Provider, Object.assign({ value: ssRsize }, { children: jsx(responsiveContainerRefContext.Provider, Object.assign({ value: containerRef }, { children: children }), void 0) }), void 0) }), void 0) }, void 0) }), void 0));
}
/**
 * A responsive container having knowledge of it's width and height. Use this
 * to make other components behave with responsiveness. The advantage is, this
 * gives the height and width of the container instead of the window.
 */
function ResponsiveContainer(props) {
    const { children, width = '100%', containerLayout = SettingsAppearanceContainerLayoutEnum.FIXED, noHorizontalPadding = false, noVerticalPadding = false, } = props;
    const outerContainerRef = useRef(null);
    const containerRef = useRef(null);
    const size = componentSize(containerRef);
    const className = useResponsiveClassNames(size, CONTROLCLASS$p, {
        [`layout-${containerLayout}`]: true,
    });
    return (
    // Outer container responsible for a max-width of 1440px (hard-coded)
    jsx(OuterContainer, Object.assign({ noHorizontalPadding: noHorizontalPadding, noVerticalPadding: noVerticalPadding, className: className, ref: outerContainerRef }, { children: jsx(InnerContainer, { children: jsx(Container$7, Object.assign({ ref: containerRef, width: width }, { children: jsx(responsiveOuterContainerRefContext.Provider, Object.assign({ value: outerContainerRef }, { children: jsx(responsiveContainerSizeContext.Provider, Object.assign({ value: size }, { children: jsx(responsiveContainerRefContext.Provider, Object.assign({ value: containerRef }, { children: children }), void 0) }), void 0) }), void 0) }), void 0) }, void 0) }), void 0));
}
ResponsiveContainer.Ssr = SsrResponsiveContainer;
function Portal(props) {
    const { children } = props;
    const ref = useResponsiveOuterContainerRef();
    return createPortal(children, ref.current ?? document.body);
}
ResponsiveContainer.Portal = Portal;

/**
 * Memize options object.
 *
 * @typedef MemizeOptions
 *
 * @property {number} [maxSize] Maximum size of the cache.
 */

/**
 * Internal cache entry.
 *
 * @typedef MemizeCacheNode
 *
 * @property {?MemizeCacheNode|undefined} [prev] Previous node.
 * @property {?MemizeCacheNode|undefined} [next] Next node.
 * @property {Array<*>}                   args   Function arguments for cache
 *                                               entry.
 * @property {*}                          val    Function result.
 */

/**
 * Properties of the enhanced function for controlling cache.
 *
 * @typedef MemizeMemoizedFunction
 *
 * @property {()=>void} clear Clear the cache.
 */

/**
 * Accepts a function to be memoized, and returns a new memoized function, with
 * optional options.
 *
 * @template {Function} F
 *
 * @param {F}             fn        Function to memoize.
 * @param {MemizeOptions} [options] Options object.
 *
 * @return {F & MemizeMemoizedFunction} Memoized function.
 */
function memize( fn, options ) {
	var size = 0;

	/** @type {?MemizeCacheNode|undefined} */
	var head;

	/** @type {?MemizeCacheNode|undefined} */
	var tail;

	options = options || {};

	function memoized( /* ...args */ ) {
		var node = head,
			len = arguments.length,
			args, i;

		searchCache: while ( node ) {
			// Perform a shallow equality test to confirm that whether the node
			// under test is a candidate for the arguments passed. Two arrays
			// are shallowly equal if their length matches and each entry is
			// strictly equal between the two sets. Avoid abstracting to a
			// function which could incur an arguments leaking deoptimization.

			// Check whether node arguments match arguments length
			if ( node.args.length !== arguments.length ) {
				node = node.next;
				continue;
			}

			// Check whether node arguments match arguments values
			for ( i = 0; i < len; i++ ) {
				if ( node.args[ i ] !== arguments[ i ] ) {
					node = node.next;
					continue searchCache;
				}
			}

			// At this point we can assume we've found a match

			// Surface matched node to head if not already
			if ( node !== head ) {
				// As tail, shift to previous. Must only shift if not also
				// head, since if both head and tail, there is no previous.
				if ( node === tail ) {
					tail = node.prev;
				}

				// Adjust siblings to point to each other. If node was tail,
				// this also handles new tail's empty `next` assignment.
				/** @type {MemizeCacheNode} */ ( node.prev ).next = node.next;
				if ( node.next ) {
					node.next.prev = node.prev;
				}

				node.next = head;
				node.prev = null;
				/** @type {MemizeCacheNode} */ ( head ).prev = node;
				head = node;
			}

			// Return immediately
			return node.val;
		}

		// No cached value found. Continue to insertion phase:

		// Create a copy of arguments (avoid leaking deoptimization)
		args = new Array( len );
		for ( i = 0; i < len; i++ ) {
			args[ i ] = arguments[ i ];
		}

		node = {
			args: args,

			// Generate the result from original function
			val: fn.apply( null, args ),
		};

		// Don't need to check whether node is already head, since it would
		// have been returned above already if it was

		// Shift existing head down list
		if ( head ) {
			head.prev = node;
			node.next = head;
		} else {
			// If no head, follows that there's no tail (at initial or reset)
			tail = node;
		}

		// Trim tail if we're reached max size and are pending cache insertion
		if ( size === /** @type {MemizeOptions} */ ( options ).maxSize ) {
			tail = /** @type {MemizeCacheNode} */ ( tail ).prev;
			/** @type {MemizeCacheNode} */ ( tail ).next = null;
		} else {
			size++;
		}

		head = node;

		return node.val;
	}

	memoized.clear = function() {
		head = null;
		tail = null;
		size = 0;
	};

	// Ignore reason: There's not a clear solution to create an intersection of
	// the function with additional properties, where the goal is to retain the
	// function signature of the incoming argument and add control properties
	// on the return value.

	// @ts-ignore
	return memoized;
}

var memize_1 = memize;

var sprintf$1 = {};

/* global window, exports, define */

(function (exports) {
!function() {

    var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
    };

    function sprintf(key) {
        // `arguments` is not an array, but should be fine for this call
        return sprintf_format(sprintf_parse(key), arguments)
    }

    function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []))
    }

    function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign;
        for (i = 0; i < tree_length; i++) {
            if (typeof parse_tree[i] === 'string') {
                output += parse_tree[i];
            }
            else if (typeof parse_tree[i] === 'object') {
                ph = parse_tree[i]; // convenience purposes only
                if (ph.keys) { // keyword argument
                    arg = argv[cursor];
                    for (k = 0; k < ph.keys.length; k++) {
                        if (arg == undefined) {
                            throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k-1]))
                        }
                        arg = arg[ph.keys[k]];
                    }
                }
                else if (ph.param_no) { // positional argument (explicit)
                    arg = argv[ph.param_no];
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++];
                }

                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                    arg = arg();
                }

                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {
                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))
                }

                if (re.number.test(ph.type)) {
                    is_positive = arg >= 0;
                }

                switch (ph.type) {
                    case 'b':
                        arg = parseInt(arg, 10).toString(2);
                        break
                    case 'c':
                        arg = String.fromCharCode(parseInt(arg, 10));
                        break
                    case 'd':
                    case 'i':
                        arg = parseInt(arg, 10);
                        break
                    case 'j':
                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                        break
                    case 'e':
                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                        break
                    case 'f':
                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                        break
                    case 'g':
                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                        break
                    case 'o':
                        arg = (parseInt(arg, 10) >>> 0).toString(8);
                        break
                    case 's':
                        arg = String(arg);
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
                        break
                    case 't':
                        arg = String(!!arg);
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
                        break
                    case 'T':
                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
                        break
                    case 'u':
                        arg = parseInt(arg, 10) >>> 0;
                        break
                    case 'v':
                        arg = arg.valueOf();
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
                        break
                    case 'x':
                        arg = (parseInt(arg, 10) >>> 0).toString(16);
                        break
                    case 'X':
                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                        break
                }
                if (re.json.test(ph.type)) {
                    output += arg;
                }
                else {
                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                        sign = is_positive ? '+' : '-';
                        arg = arg.toString().replace(re.sign, '');
                    }
                    else {
                        sign = '';
                    }
                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';
                    pad_length = ph.width - (sign + arg).length;
                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : '';
                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg);
                }
            }
        }
        return output
    }

    var sprintf_cache = Object.create(null);

    function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt]
        }

        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree.push(match[0]);
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree.push('%');
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1;
                    var field_list = [], replacement_field = match[2], field_match = [];
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1]);
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                            }
                            else {
                                throw new SyntaxError('[sprintf] failed to parse named argument key')
                            }
                        }
                    }
                    else {
                        throw new SyntaxError('[sprintf] failed to parse named argument key')
                    }
                    match[2] = field_list;
                }
                else {
                    arg_names |= 2;
                }
                if (arg_names === 3) {
                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
                }

                parse_tree.push(
                    {
                        placeholder: match[0],
                        param_no:    match[1],
                        keys:        match[2],
                        sign:        match[3],
                        pad_char:    match[4],
                        align:       match[5],
                        width:       match[6],
                        precision:   match[7],
                        type:        match[8]
                    }
                );
            }
            else {
                throw new SyntaxError('[sprintf] unexpected placeholder')
            }
            _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree
    }

    /**
     * export to either browser or node.js
     */
    /* eslint-disable quote-props */
    {
        exports['sprintf'] = sprintf;
        exports['vsprintf'] = vsprintf;
    }
    if (typeof window !== 'undefined') {
        window['sprintf'] = sprintf;
        window['vsprintf'] = vsprintf;
    }
    /* eslint-enable quote-props */
}(); // eslint-disable-line
}(sprintf$1));

/**
 * External dependencies
 */
/**
 * Log to console, once per message; or more precisely, per referentially equal
 * argument set. Because Jed throws errors, we log these to the console instead
 * to avoid crashing the application.
 *
 * @param {...*} args Arguments to pass to `console.error`
 */

const logErrorOnce = memize_1(console.error); // eslint-disable-line no-console

/**
 * Returns a formatted string. If an error occurs in applying the format, the
 * original format string is returned.
 *
 * @param {string} format The format of the string to generate.
 * @param {...*}   args   Arguments to apply to the format.
 *
 * @see https://www.npmjs.com/package/sprintf-js
 *
 * @return {string} The formatted string.
 */

function sprintf(format, ...args) {
  try {
    return sprintf$1.sprintf(format, ...args);
  } catch (error) {
    logErrorOnce('sprintf error: \n\n' + error.toString());
    return format;
  }
}

var PRECEDENCE, OPENERS, TERMINATORS, PATTERN;

/**
 * Operator precedence mapping.
 *
 * @type {Object}
 */
PRECEDENCE = {
	'(': 9,
	'!': 8,
	'*': 7,
	'/': 7,
	'%': 7,
	'+': 6,
	'-': 6,
	'<': 5,
	'<=': 5,
	'>': 5,
	'>=': 5,
	'==': 4,
	'!=': 4,
	'&&': 3,
	'||': 2,
	'?': 1,
	'?:': 1,
};

/**
 * Characters which signal pair opening, to be terminated by terminators.
 *
 * @type {string[]}
 */
OPENERS = [ '(', '?' ];

/**
 * Characters which signal pair termination, the value an array with the
 * opener as its first member. The second member is an optional operator
 * replacement to push to the stack.
 *
 * @type {string[]}
 */
TERMINATORS = {
	')': [ '(' ],
	':': [ '?', '?:' ],
};

/**
 * Pattern matching operators and openers.
 *
 * @type {RegExp}
 */
PATTERN = /<=|>=|==|!=|&&|\|\||\?:|\(|!|\*|\/|%|\+|-|<|>|\?|\)|:/;

/**
 * Given a C expression, returns the equivalent postfix (Reverse Polish)
 * notation terms as an array.
 *
 * If a postfix string is desired, simply `.join( ' ' )` the result.
 *
 * @example
 *
 * ```js
 * import postfix from '@tannin/postfix';
 *
 * postfix( 'n > 1' );
 * // ⇒ [ 'n', '1', '>' ]
 * ```
 *
 * @param {string} expression C expression.
 *
 * @return {string[]} Postfix terms.
 */
function postfix( expression ) {
	var terms = [],
		stack = [],
		match, operator, term, element;

	while ( ( match = expression.match( PATTERN ) ) ) {
		operator = match[ 0 ];

		// Term is the string preceding the operator match. It may contain
		// whitespace, and may be empty (if operator is at beginning).
		term = expression.substr( 0, match.index ).trim();
		if ( term ) {
			terms.push( term );
		}

		while ( ( element = stack.pop() ) ) {
			if ( TERMINATORS[ operator ] ) {
				if ( TERMINATORS[ operator ][ 0 ] === element ) {
					// Substitution works here under assumption that because
					// the assigned operator will no longer be a terminator, it
					// will be pushed to the stack during the condition below.
					operator = TERMINATORS[ operator ][ 1 ] || operator;
					break;
				}
			} else if ( OPENERS.indexOf( element ) >= 0 || PRECEDENCE[ element ] < PRECEDENCE[ operator ] ) {
				// Push to stack if either an opener or when pop reveals an
				// element of lower precedence.
				stack.push( element );
				break;
			}

			// For each popped from stack, push to terms.
			terms.push( element );
		}

		if ( ! TERMINATORS[ operator ] ) {
			stack.push( operator );
		}

		// Slice matched fragment from expression to continue match.
		expression = expression.substr( match.index + operator.length );
	}

	// Push remainder of operand, if exists, to terms.
	expression = expression.trim();
	if ( expression ) {
		terms.push( expression );
	}

	// Pop remaining items from stack into terms.
	return terms.concat( stack.reverse() );
}

/**
 * Operator callback functions.
 *
 * @type {Object}
 */
var OPERATORS = {
	'!': function( a ) {
		return ! a;
	},
	'*': function( a, b ) {
		return a * b;
	},
	'/': function( a, b ) {
		return a / b;
	},
	'%': function( a, b ) {
		return a % b;
	},
	'+': function( a, b ) {
		return a + b;
	},
	'-': function( a, b ) {
		return a - b;
	},
	'<': function( a, b ) {
		return a < b;
	},
	'<=': function( a, b ) {
		return a <= b;
	},
	'>': function( a, b ) {
		return a > b;
	},
	'>=': function( a, b ) {
		return a >= b;
	},
	'==': function( a, b ) {
		return a === b;
	},
	'!=': function( a, b ) {
		return a !== b;
	},
	'&&': function( a, b ) {
		return a && b;
	},
	'||': function( a, b ) {
		return a || b;
	},
	'?:': function( a, b, c ) {
		if ( a ) {
			throw b;
		}

		return c;
	},
};

/**
 * Given an array of postfix terms and operand variables, returns the result of
 * the postfix evaluation.
 *
 * @example
 *
 * ```js
 * import evaluate from '@tannin/evaluate';
 *
 * // 3 + 4 * 5 / 6 ⇒ '3 4 5 * 6 / +'
 * const terms = [ '3', '4', '5', '*', '6', '/', '+' ];
 *
 * evaluate( terms, {} );
 * // ⇒ 6.333333333333334
 * ```
 *
 * @param {string[]} postfix   Postfix terms.
 * @param {Object}   variables Operand variables.
 *
 * @return {*} Result of evaluation.
 */
function evaluate( postfix, variables ) {
	var stack = [],
		i, j, args, getOperatorResult, term, value;

	for ( i = 0; i < postfix.length; i++ ) {
		term = postfix[ i ];

		getOperatorResult = OPERATORS[ term ];
		if ( getOperatorResult ) {
			// Pop from stack by number of function arguments.
			j = getOperatorResult.length;
			args = Array( j );
			while ( j-- ) {
				args[ j ] = stack.pop();
			}

			try {
				value = getOperatorResult.apply( null, args );
			} catch ( earlyReturn ) {
				return earlyReturn;
			}
		} else if ( variables.hasOwnProperty( term ) ) {
			value = variables[ term ];
		} else {
			value = +term;
		}

		stack.push( value );
	}

	return stack[ 0 ];
}

/**
 * Given a C expression, returns a function which can be called to evaluate its
 * result.
 *
 * @example
 *
 * ```js
 * import compile from '@tannin/compile';
 *
 * const evaluate = compile( 'n > 1' );
 *
 * evaluate( { n: 2 } );
 * // ⇒ true
 * ```
 *
 * @param {string} expression C expression.
 *
 * @return {(variables?:{[variable:string]:*})=>*} Compiled evaluator.
 */
function compile( expression ) {
	var terms = postfix( expression );

	return function( variables ) {
		return evaluate( terms, variables );
	};
}

/**
 * Given a C expression, returns a function which, when called with a value,
 * evaluates the result with the value assumed to be the "n" variable of the
 * expression. The result will be coerced to its numeric equivalent.
 *
 * @param {string} expression C expression.
 *
 * @return {Function} Evaluator function.
 */
function pluralForms( expression ) {
	var evaluate = compile( expression );

	return function( n ) {
		return +evaluate( { n: n } );
	};
}

/**
 * Tannin constructor options.
 *
 * @typedef {Object} TanninOptions
 *
 * @property {string}   [contextDelimiter] Joiner in string lookup with context.
 * @property {Function} [onMissingKey]     Callback to invoke when key missing.
 */

/**
 * Domain metadata.
 *
 * @typedef {Object} TanninDomainMetadata
 *
 * @property {string}            [domain]       Domain name.
 * @property {string}            [lang]         Language code.
 * @property {(string|Function)} [plural_forms] Plural forms expression or
 *                                              function evaluator.
 */

/**
 * Domain translation pair respectively representing the singular and plural
 * translation.
 *
 * @typedef {[string,string]} TanninTranslation
 */

/**
 * Locale data domain. The key is used as reference for lookup, the value an
 * array of two string entries respectively representing the singular and plural
 * translation.
 *
 * @typedef {{[key:string]:TanninDomainMetadata|TanninTranslation,'':TanninDomainMetadata|TanninTranslation}} TanninLocaleDomain
 */

/**
 * Jed-formatted locale data.
 *
 * @see http://messageformat.github.io/Jed/
 *
 * @typedef {{[domain:string]:TanninLocaleDomain}} TanninLocaleData
 */

/**
 * Default Tannin constructor options.
 *
 * @type {TanninOptions}
 */
var DEFAULT_OPTIONS = {
	contextDelimiter: '\u0004',
	onMissingKey: null,
};

/**
 * Given a specific locale data's config `plural_forms` value, returns the
 * expression.
 *
 * @example
 *
 * ```
 * getPluralExpression( 'nplurals=2; plural=(n != 1);' ) === '(n != 1)'
 * ```
 *
 * @param {string} pf Locale data plural forms.
 *
 * @return {string} Plural forms expression.
 */
function getPluralExpression( pf ) {
	var parts, i, part;

	parts = pf.split( ';' );

	for ( i = 0; i < parts.length; i++ ) {
		part = parts[ i ].trim();
		if ( part.indexOf( 'plural=' ) === 0 ) {
			return part.substr( 7 );
		}
	}
}

/**
 * Tannin constructor.
 *
 * @class
 *
 * @param {TanninLocaleData} data      Jed-formatted locale data.
 * @param {TanninOptions}    [options] Tannin options.
 */
function Tannin( data, options ) {
	var key;

	/**
	 * Jed-formatted locale data.
	 *
	 * @name Tannin#data
	 * @type {TanninLocaleData}
	 */
	this.data = data;

	/**
	 * Plural forms function cache, keyed by plural forms string.
	 *
	 * @name Tannin#pluralForms
	 * @type {Object<string,Function>}
	 */
	this.pluralForms = {};

	/**
	 * Effective options for instance, including defaults.
	 *
	 * @name Tannin#options
	 * @type {TanninOptions}
	 */
	this.options = {};

	for ( key in DEFAULT_OPTIONS ) {
		this.options[ key ] = options !== undefined && key in options
			? options[ key ]
			: DEFAULT_OPTIONS[ key ];
	}
}

/**
 * Returns the plural form index for the given domain and value.
 *
 * @param {string} domain Domain on which to calculate plural form.
 * @param {number} n      Value for which plural form is to be calculated.
 *
 * @return {number} Plural form index.
 */
Tannin.prototype.getPluralForm = function( domain, n ) {
	var getPluralForm = this.pluralForms[ domain ],
		config, plural, pf;

	if ( ! getPluralForm ) {
		config = this.data[ domain ][ '' ];

		pf = (
			config[ 'Plural-Forms' ] ||
			config[ 'plural-forms' ] ||
			// Ignore reason: As known, there's no way to document the empty
			// string property on a key to guarantee this as metadata.
			// @ts-ignore
			config.plural_forms
		);

		if ( typeof pf !== 'function' ) {
			plural = getPluralExpression(
				config[ 'Plural-Forms' ] ||
				config[ 'plural-forms' ] ||
				// Ignore reason: As known, there's no way to document the empty
				// string property on a key to guarantee this as metadata.
				// @ts-ignore
				config.plural_forms
			);

			pf = pluralForms( plural );
		}

		getPluralForm = this.pluralForms[ domain ] = pf;
	}

	return getPluralForm( n );
};

/**
 * Translate a string.
 *
 * @param {string}      domain   Translation domain.
 * @param {string|void} context  Context distinguishing terms of the same name.
 * @param {string}      singular Primary key for translation lookup.
 * @param {string=}     plural   Fallback value used for non-zero plural
 *                               form index.
 * @param {number=}     n        Value to use in calculating plural form.
 *
 * @return {string} Translated string.
 */
Tannin.prototype.dcnpgettext = function( domain, context, singular, plural, n ) {
	var index, key, entry;

	if ( n === undefined ) {
		// Default to singular.
		index = 0;
	} else {
		// Find index by evaluating plural form for value.
		index = this.getPluralForm( domain, n );
	}

	key = singular;

	// If provided, context is prepended to key with delimiter.
	if ( context ) {
		key = context + this.options.contextDelimiter + singular;
	}

	entry = this.data[ domain ][ key ];

	// Verify not only that entry exists, but that the intended index is within
	// range and non-empty.
	if ( entry && entry[ index ] ) {
		return entry[ index ];
	}

	if ( this.options.onMissingKey ) {
		this.options.onMissingKey( singular, domain );
	}

	// If entry not found, fall back to singular vs. plural with zero index
	// representing the singular value.
	return index === 0 ? singular : plural;
};

/**
 * External dependencies
 */
/**
 * @typedef {Record<string,any>} LocaleData
 */

/**
 * Default locale data to use for Tannin domain when not otherwise provided.
 * Assumes an English plural forms expression.
 *
 * @type {LocaleData}
 */

const DEFAULT_LOCALE_DATA = {
  '': {
    /** @param {number} n */
    plural_forms(n) {
      return n === 1 ? 0 : 1;
    }

  }
};
/*
 * Regular expression that matches i18n hooks like `i18n.gettext`, `i18n.ngettext`,
 * `i18n.gettext_domain` or `i18n.ngettext_with_context` or `i18n.has_translation`.
 */

const I18N_HOOK_REGEXP = /^i18n\.(n?gettext|has_translation)(_|$)/;
/**
 * @typedef {(domain?: string) => LocaleData} GetLocaleData
 *
 * Returns locale data by domain in a
 * Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 */

/**
 * @typedef {(data?: LocaleData, domain?: string) => void} SetLocaleData
 *
 * Merges locale data into the Tannin instance by domain. Accepts data in a
 * Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 */

/**
 * @typedef {(data?: LocaleData, domain?: string) => void} ResetLocaleData
 *
 * Resets all current Tannin instance locale data and sets the specified
 * locale data for the domain. Accepts data in a Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 */

/** @typedef {() => void} SubscribeCallback */

/** @typedef {() => void} UnsubscribeCallback */

/**
 * @typedef {(callback: SubscribeCallback) => UnsubscribeCallback} Subscribe
 *
 * Subscribes to changes of locale data
 */

/**
 * @typedef {(domain?: string) => string} GetFilterDomain
 * Retrieve the domain to use when calling domain-specific filters.
 */

/**
 * @typedef {(text: string, domain?: string) => string} __
 *
 * Retrieve the translation of text.
 *
 * @see https://developer.wordpress.org/reference/functions/__/
 */

/**
 * @typedef {(text: string, context: string, domain?: string) => string} _x
 *
 * Retrieve translated string with gettext context.
 *
 * @see https://developer.wordpress.org/reference/functions/_x/
 */

/**
 * @typedef {(single: string, plural: string, number: number, domain?: string) => string} _n
 *
 * Translates and retrieves the singular or plural form based on the supplied
 * number.
 *
 * @see https://developer.wordpress.org/reference/functions/_n/
 */

/**
 * @typedef {(single: string, plural: string, number: number, context: string, domain?: string) => string} _nx
 *
 * Translates and retrieves the singular or plural form based on the supplied
 * number, with gettext context.
 *
 * @see https://developer.wordpress.org/reference/functions/_nx/
 */

/**
 * @typedef {() => boolean} IsRtl
 *
 * Check if current locale is RTL.
 *
 * **RTL (Right To Left)** is a locale property indicating that text is written from right to left.
 * For example, the `he` locale (for Hebrew) specifies right-to-left. Arabic (ar) is another common
 * language written RTL. The opposite of RTL, LTR (Left To Right) is used in other languages,
 * including English (`en`, `en-US`, `en-GB`, etc.), Spanish (`es`), and French (`fr`).
 */

/**
 * @typedef {(single: string, context?: string, domain?: string) => boolean} HasTranslation
 *
 * Check if there is a translation for a given string in singular form.
 */

/** @typedef {import('@wordpress/hooks').Hooks} Hooks */

/**
 * An i18n instance
 *
 * @typedef I18n
 * @property {GetLocaleData}   getLocaleData   Returns locale data by domain in a Jed-formatted JSON object shape.
 * @property {SetLocaleData}   setLocaleData   Merges locale data into the Tannin instance by domain. Accepts data in a
 *                                             Jed-formatted JSON object shape.
 * @property {ResetLocaleData} resetLocaleData Resets all current Tannin instance locale data and sets the specified
 *                                             locale data for the domain. Accepts data in a Jed-formatted JSON object shape.
 * @property {Subscribe}       subscribe       Subscribes to changes of Tannin locale data.
 * @property {__}              __              Retrieve the translation of text.
 * @property {_x}              _x              Retrieve translated string with gettext context.
 * @property {_n}              _n              Translates and retrieves the singular or plural form based on the supplied
 *                                             number.
 * @property {_nx}             _nx             Translates and retrieves the singular or plural form based on the supplied
 *                                             number, with gettext context.
 * @property {IsRtl}           isRTL           Check if current locale is RTL.
 * @property {HasTranslation}  hasTranslation  Check if there is a translation for a given string.
 */

/**
 * Create an i18n instance
 *
 * @param {LocaleData} [initialData]   Locale data configuration.
 * @param {string}     [initialDomain] Domain for which configuration applies.
 * @param {Hooks}      [hooks]         Hooks implementation.
 *
 * @return {I18n} I18n instance.
 */

const createI18n = (initialData, initialDomain, hooks) => {
  /**
   * The underlying instance of Tannin to which exported functions interface.
   *
   * @type {Tannin}
   */
  const tannin = new Tannin({});
  const listeners = new Set();

  const notifyListeners = () => {
    listeners.forEach(listener => listener());
  };
  /**
   * Subscribe to changes of locale data.
   *
   * @param {SubscribeCallback} callback Subscription callback.
   * @return {UnsubscribeCallback} Unsubscribe callback.
   */


  const subscribe = callback => {
    listeners.add(callback);
    return () => listeners.delete(callback);
  };
  /** @type {GetLocaleData} */


  const getLocaleData = (domain = 'default') => tannin.data[domain];
  /**
   * @param {LocaleData} [data]
   * @param {string}     [domain]
   */


  const doSetLocaleData = (data, domain = 'default') => {
    tannin.data[domain] = { ...DEFAULT_LOCALE_DATA,
      ...tannin.data[domain],
      ...data
    }; // Populate default domain configuration (supported locale date which omits
    // a plural forms expression).

    tannin.data[domain][''] = { ...DEFAULT_LOCALE_DATA[''],
      ...tannin.data[domain]['']
    };
  };
  /** @type {SetLocaleData} */


  const setLocaleData = (data, domain) => {
    doSetLocaleData(data, domain);
    notifyListeners();
  };
  /** @type {ResetLocaleData} */


  const resetLocaleData = (data, domain) => {
    // Reset all current Tannin locale data.
    tannin.data = {}; // Reset cached plural forms functions cache.

    tannin.pluralForms = {};
    setLocaleData(data, domain);
  };
  /**
   * Wrapper for Tannin's `dcnpgettext`. Populates default locale data if not
   * otherwise previously assigned.
   *
   * @param {string|undefined} domain   Domain to retrieve the translated text.
   * @param {string|undefined} context  Context information for the translators.
   * @param {string}           single   Text to translate if non-plural. Used as
   *                                    fallback return value on a caught error.
   * @param {string}           [plural] The text to be used if the number is
   *                                    plural.
   * @param {number}           [number] The number to compare against to use
   *                                    either the singular or plural form.
   *
   * @return {string} The translated string.
   */


  const dcnpgettext = (domain = 'default', context, single, plural, number) => {
    if (!tannin.data[domain]) {
      // use `doSetLocaleData` to set silently, without notifying listeners
      doSetLocaleData(undefined, domain);
    }

    return tannin.dcnpgettext(domain, context, single, plural, number);
  };
  /** @type {GetFilterDomain} */


  const getFilterDomain = (domain = 'default') => domain;
  /** @type {__} */


  const __ = (text, domain) => {
    let translation = dcnpgettext(domain, undefined, text);

    if (!hooks) {
      return translation;
    }
    /**
     * Filters text with its translation.
     *
     * @param {string} translation Translated text.
     * @param {string} text        Text to translate.
     * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
     */


    translation =
    /** @type {string} */

    /** @type {*} */
    hooks.applyFilters('i18n.gettext', translation, text, domain);
    return (
      /** @type {string} */

      /** @type {*} */
      hooks.applyFilters('i18n.gettext_' + getFilterDomain(domain), translation, text, domain)
    );
  };
  /** @type {_x} */


  const _x = (text, context, domain) => {
    let translation = dcnpgettext(domain, context, text);

    if (!hooks) {
      return translation;
    }
    /**
     * Filters text with its translation based on context information.
     *
     * @param {string} translation Translated text.
     * @param {string} text        Text to translate.
     * @param {string} context     Context information for the translators.
     * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
     */


    translation =
    /** @type {string} */

    /** @type {*} */
    hooks.applyFilters('i18n.gettext_with_context', translation, text, context, domain);
    return (
      /** @type {string} */

      /** @type {*} */
      hooks.applyFilters('i18n.gettext_with_context_' + getFilterDomain(domain), translation, text, context, domain)
    );
  };
  /** @type {_n} */


  const _n = (single, plural, number, domain) => {
    let translation = dcnpgettext(domain, undefined, single, plural, number);

    if (!hooks) {
      return translation;
    }
    /**
     * Filters the singular or plural form of a string.
     *
     * @param {string} translation Translated text.
     * @param {string} single      The text to be used if the number is singular.
     * @param {string} plural      The text to be used if the number is plural.
     * @param {string} number      The number to compare against to use either the singular or plural form.
     * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
     */


    translation =
    /** @type {string} */

    /** @type {*} */
    hooks.applyFilters('i18n.ngettext', translation, single, plural, number, domain);
    return (
      /** @type {string} */

      /** @type {*} */
      hooks.applyFilters('i18n.ngettext_' + getFilterDomain(domain), translation, single, plural, number, domain)
    );
  };
  /** @type {_nx} */


  const _nx = (single, plural, number, context, domain) => {
    let translation = dcnpgettext(domain, context, single, plural, number);

    if (!hooks) {
      return translation;
    }
    /**
     * Filters the singular or plural form of a string with gettext context.
     *
     * @param {string} translation Translated text.
     * @param {string} single      The text to be used if the number is singular.
     * @param {string} plural      The text to be used if the number is plural.
     * @param {string} number      The number to compare against to use either the singular or plural form.
     * @param {string} context     Context information for the translators.
     * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
     */


    translation =
    /** @type {string} */

    /** @type {*} */
    hooks.applyFilters('i18n.ngettext_with_context', translation, single, plural, number, context, domain);
    return (
      /** @type {string} */

      /** @type {*} */
      hooks.applyFilters('i18n.ngettext_with_context_' + getFilterDomain(domain), translation, single, plural, number, context, domain)
    );
  };
  /** @type {IsRtl} */


  const isRTL = () => {
    return 'rtl' === _x('ltr', 'text direction');
  };
  /** @type {HasTranslation} */


  const hasTranslation = (single, context, domain) => {
    var _tannin$data, _tannin$data2;

    const key = context ? context + '\u0004' + single : single;
    let result = !!((_tannin$data = tannin.data) !== null && _tannin$data !== void 0 && (_tannin$data2 = _tannin$data[domain !== null && domain !== void 0 ? domain : 'default']) !== null && _tannin$data2 !== void 0 && _tannin$data2[key]);

    if (hooks) {
      /**
       * Filters the presence of a translation in the locale data.
       *
       * @param {boolean} hasTranslation Whether the translation is present or not..
       * @param {string}  single         The singular form of the translated text (used as key in locale data)
       * @param {string}  context        Context information for the translators.
       * @param {string}  domain         Text domain. Unique identifier for retrieving translated strings.
       */
      result =
      /** @type { boolean } */

      /** @type {*} */
      hooks.applyFilters('i18n.has_translation', result, single, context, domain);
      result =
      /** @type { boolean } */

      /** @type {*} */
      hooks.applyFilters('i18n.has_translation_' + getFilterDomain(domain), result, single, context, domain);
    }

    return result;
  };

  if (initialData) {
    setLocaleData(initialData, initialDomain);
  }

  if (hooks) {
    /**
     * @param {string} hookName
     */
    const onHookAddedOrRemoved = hookName => {
      if (I18N_HOOK_REGEXP.test(hookName)) {
        notifyListeners();
      }
    };

    hooks.addAction('hookAdded', 'core/i18n', onHookAddedOrRemoved);
    hooks.addAction('hookRemoved', 'core/i18n', onHookAddedOrRemoved);
  }

  return {
    getLocaleData,
    setLocaleData,
    resetLocaleData,
    subscribe,
    __,
    _x,
    _n,
    _nx,
    isRTL,
    hasTranslation
  };
};

/**
 * Validate a namespace string.
 *
 * @param {string} namespace The namespace to validate - should take the form
 *                           `vendor/plugin/function`.
 *
 * @return {boolean} Whether the namespace is valid.
 */
function validateNamespace(namespace) {
  if ('string' !== typeof namespace || '' === namespace) {
    // eslint-disable-next-line no-console
    console.error('The namespace must be a non-empty string.');
    return false;
  }

  if (!/^[a-zA-Z][a-zA-Z0-9_.\-\/]*$/.test(namespace)) {
    // eslint-disable-next-line no-console
    console.error('The namespace can only contain numbers, letters, dashes, periods, underscores and slashes.');
    return false;
  }

  return true;
}

/**
 * Validate a hookName string.
 *
 * @param {string} hookName The hook name to validate. Should be a non empty string containing
 *                          only numbers, letters, dashes, periods and underscores. Also,
 *                          the hook name cannot begin with `__`.
 *
 * @return {boolean} Whether the hook name is valid.
 */
function validateHookName(hookName) {
  if ('string' !== typeof hookName || '' === hookName) {
    // eslint-disable-next-line no-console
    console.error('The hook name must be a non-empty string.');
    return false;
  }

  if (/^__/.test(hookName)) {
    // eslint-disable-next-line no-console
    console.error('The hook name cannot begin with `__`.');
    return false;
  }

  if (!/^[a-zA-Z][a-zA-Z0-9_.-]*$/.test(hookName)) {
    // eslint-disable-next-line no-console
    console.error('The hook name can only contain numbers, letters, dashes, periods and underscores.');
    return false;
  }

  return true;
}

/**
 * Internal dependencies
 */
/**
 * @callback AddHook
 *
 * Adds the hook to the appropriate hooks container.
 *
 * @param {string}               hookName      Name of hook to add
 * @param {string}               namespace     The unique namespace identifying the callback in the form `vendor/plugin/function`.
 * @param {import('.').Callback} callback      Function to call when the hook is run
 * @param {number}               [priority=10] Priority of this hook
 */

/**
 * Returns a function which, when invoked, will add a hook.
 *
 * @param {import('.').Hooks}    hooks    Hooks instance.
 * @param {import('.').StoreKey} storeKey
 *
 * @return {AddHook} Function that adds a new hook.
 */

function createAddHook(hooks, storeKey) {
  return function addHook(hookName, namespace, callback, priority = 10) {
    const hooksStore = hooks[storeKey];

    if (!validateHookName(hookName)) {
      return;
    }

    if (!validateNamespace(namespace)) {
      return;
    }

    if ('function' !== typeof callback) {
      // eslint-disable-next-line no-console
      console.error('The hook callback must be a function.');
      return;
    } // Validate numeric priority


    if ('number' !== typeof priority) {
      // eslint-disable-next-line no-console
      console.error('If specified, the hook priority must be a number.');
      return;
    }

    const handler = {
      callback,
      priority,
      namespace
    };

    if (hooksStore[hookName]) {
      // Find the correct insert index of the new hook.
      const handlers = hooksStore[hookName].handlers;
      /** @type {number} */

      let i;

      for (i = handlers.length; i > 0; i--) {
        if (priority >= handlers[i - 1].priority) {
          break;
        }
      }

      if (i === handlers.length) {
        // If append, operate via direct assignment.
        handlers[i] = handler;
      } else {
        // Otherwise, insert before index via splice.
        handlers.splice(i, 0, handler);
      } // We may also be currently executing this hook.  If the callback
      // we're adding would come after the current callback, there's no
      // problem; otherwise we need to increase the execution index of
      // any other runs by 1 to account for the added element.


      hooksStore.__current.forEach(hookInfo => {
        if (hookInfo.name === hookName && hookInfo.currentIndex >= i) {
          hookInfo.currentIndex++;
        }
      });
    } else {
      // This is the first hook of its type.
      hooksStore[hookName] = {
        handlers: [handler],
        runs: 0
      };
    }

    if (hookName !== 'hookAdded') {
      hooks.doAction('hookAdded', hookName, namespace, callback, priority);
    }
  };
}

/**
 * Internal dependencies
 */
/**
 * @callback RemoveHook
 * Removes the specified callback (or all callbacks) from the hook with a given hookName
 * and namespace.
 *
 * @param {string} hookName  The name of the hook to modify.
 * @param {string} namespace The unique namespace identifying the callback in the
 *                           form `vendor/plugin/function`.
 *
 * @return {number | undefined} The number of callbacks removed.
 */

/**
 * Returns a function which, when invoked, will remove a specified hook or all
 * hooks by the given name.
 *
 * @param {import('.').Hooks}    hooks             Hooks instance.
 * @param {import('.').StoreKey} storeKey
 * @param {boolean}              [removeAll=false] Whether to remove all callbacks for a hookName,
 *                                                 without regard to namespace. Used to create
 *                                                 `removeAll*` functions.
 *
 * @return {RemoveHook} Function that removes hooks.
 */

function createRemoveHook(hooks, storeKey, removeAll = false) {
  return function removeHook(hookName, namespace) {
    const hooksStore = hooks[storeKey];

    if (!validateHookName(hookName)) {
      return;
    }

    if (!removeAll && !validateNamespace(namespace)) {
      return;
    } // Bail if no hooks exist by this name


    if (!hooksStore[hookName]) {
      return 0;
    }

    let handlersRemoved = 0;

    if (removeAll) {
      handlersRemoved = hooksStore[hookName].handlers.length;
      hooksStore[hookName] = {
        runs: hooksStore[hookName].runs,
        handlers: []
      };
    } else {
      // Try to find the specified callback to remove.
      const handlers = hooksStore[hookName].handlers;

      for (let i = handlers.length - 1; i >= 0; i--) {
        if (handlers[i].namespace === namespace) {
          handlers.splice(i, 1);
          handlersRemoved++; // This callback may also be part of a hook that is
          // currently executing.  If the callback we're removing
          // comes after the current callback, there's no problem;
          // otherwise we need to decrease the execution index of any
          // other runs by 1 to account for the removed element.

          hooksStore.__current.forEach(hookInfo => {
            if (hookInfo.name === hookName && hookInfo.currentIndex >= i) {
              hookInfo.currentIndex--;
            }
          });
        }
      }
    }

    if (hookName !== 'hookRemoved') {
      hooks.doAction('hookRemoved', hookName, namespace);
    }

    return handlersRemoved;
  };
}

/**
 * @callback HasHook
 *
 * Returns whether any handlers are attached for the given hookName and optional namespace.
 *
 * @param {string} hookName    The name of the hook to check for.
 * @param {string} [namespace] Optional. The unique namespace identifying the callback
 *                             in the form `vendor/plugin/function`.
 *
 * @return {boolean} Whether there are handlers that are attached to the given hook.
 */

/**
 * Returns a function which, when invoked, will return whether any handlers are
 * attached to a particular hook.
 *
 * @param {import('.').Hooks}    hooks    Hooks instance.
 * @param {import('.').StoreKey} storeKey
 *
 * @return {HasHook} Function that returns whether any handlers are
 *                   attached to a particular hook and optional namespace.
 */
function createHasHook(hooks, storeKey) {
  return function hasHook(hookName, namespace) {
    const hooksStore = hooks[storeKey]; // Use the namespace if provided.

    if ('undefined' !== typeof namespace) {
      return hookName in hooksStore && hooksStore[hookName].handlers.some(hook => hook.namespace === namespace);
    }

    return hookName in hooksStore;
  };
}

/**
 * Returns a function which, when invoked, will execute all callbacks
 * registered to a hook of the specified type, optionally returning the final
 * value of the call chain.
 *
 * @param {import('.').Hooks}    hooks                  Hooks instance.
 * @param {import('.').StoreKey} storeKey
 * @param {boolean}              [returnFirstArg=false] Whether each hook callback is expected to
 *                                                      return its first argument.
 *
 * @return {(hookName:string, ...args: unknown[]) => unknown} Function that runs hook callbacks.
 */
function createRunHook(hooks, storeKey, returnFirstArg = false) {
  return function runHooks(hookName, ...args) {
    const hooksStore = hooks[storeKey];

    if (!hooksStore[hookName]) {
      hooksStore[hookName] = {
        handlers: [],
        runs: 0
      };
    }

    hooksStore[hookName].runs++;
    const handlers = hooksStore[hookName].handlers; // The following code is stripped from production builds.

    if (!handlers || !handlers.length) {
      return returnFirstArg ? args[0] : undefined;
    }

    const hookInfo = {
      name: hookName,
      currentIndex: 0
    };

    hooksStore.__current.push(hookInfo);

    while (hookInfo.currentIndex < handlers.length) {
      const handler = handlers[hookInfo.currentIndex];
      const result = handler.callback.apply(null, args);

      if (returnFirstArg) {
        args[0] = result;
      }

      hookInfo.currentIndex++;
    }

    hooksStore.__current.pop();

    if (returnFirstArg) {
      return args[0];
    }
  };
}

/**
 * Returns a function which, when invoked, will return the name of the
 * currently running hook, or `null` if no hook of the given type is currently
 * running.
 *
 * @param {import('.').Hooks}    hooks    Hooks instance.
 * @param {import('.').StoreKey} storeKey
 *
 * @return {() => string | null} Function that returns the current hook name or null.
 */
function createCurrentHook(hooks, storeKey) {
  return function currentHook() {
    var _hooksStore$__current, _hooksStore$__current2;

    const hooksStore = hooks[storeKey];
    return (_hooksStore$__current = (_hooksStore$__current2 = hooksStore.__current[hooksStore.__current.length - 1]) === null || _hooksStore$__current2 === void 0 ? void 0 : _hooksStore$__current2.name) !== null && _hooksStore$__current !== void 0 ? _hooksStore$__current : null;
  };
}

/**
 * @callback DoingHook
 * Returns whether a hook is currently being executed.
 *
 * @param {string} [hookName] The name of the hook to check for.  If
 *                            omitted, will check for any hook being executed.
 *
 * @return {boolean} Whether the hook is being executed.
 */

/**
 * Returns a function which, when invoked, will return whether a hook is
 * currently being executed.
 *
 * @param {import('.').Hooks}    hooks    Hooks instance.
 * @param {import('.').StoreKey} storeKey
 *
 * @return {DoingHook} Function that returns whether a hook is currently
 *                     being executed.
 */
function createDoingHook(hooks, storeKey) {
  return function doingHook(hookName) {
    const hooksStore = hooks[storeKey]; // If the hookName was not passed, check for any current hook.

    if ('undefined' === typeof hookName) {
      return 'undefined' !== typeof hooksStore.__current[0];
    } // Return the __current hook.


    return hooksStore.__current[0] ? hookName === hooksStore.__current[0].name : false;
  };
}

/**
 * Internal dependencies
 */
/**
 * @callback DidHook
 *
 * Returns the number of times an action has been fired.
 *
 * @param {string} hookName The hook name to check.
 *
 * @return {number | undefined} The number of times the hook has run.
 */

/**
 * Returns a function which, when invoked, will return the number of times a
 * hook has been called.
 *
 * @param {import('.').Hooks}    hooks    Hooks instance.
 * @param {import('.').StoreKey} storeKey
 *
 * @return {DidHook} Function that returns a hook's call count.
 */

function createDidHook(hooks, storeKey) {
  return function didHook(hookName) {
    const hooksStore = hooks[storeKey];

    if (!validateHookName(hookName)) {
      return;
    }

    return hooksStore[hookName] && hooksStore[hookName].runs ? hooksStore[hookName].runs : 0;
  };
}

/**
 * Internal dependencies
 */
/**
 * Internal class for constructing hooks. Use `createHooks()` function
 *
 * Note, it is necessary to expose this class to make its type public.
 *
 * @private
 */

class _Hooks {
  constructor() {
    /** @type {import('.').Store} actions */
    this.actions = Object.create(null);
    this.actions.__current = [];
    /** @type {import('.').Store} filters */

    this.filters = Object.create(null);
    this.filters.__current = [];
    this.addAction = createAddHook(this, 'actions');
    this.addFilter = createAddHook(this, 'filters');
    this.removeAction = createRemoveHook(this, 'actions');
    this.removeFilter = createRemoveHook(this, 'filters');
    this.hasAction = createHasHook(this, 'actions');
    this.hasFilter = createHasHook(this, 'filters');
    this.removeAllActions = createRemoveHook(this, 'actions', true);
    this.removeAllFilters = createRemoveHook(this, 'filters', true);
    this.doAction = createRunHook(this, 'actions');
    this.applyFilters = createRunHook(this, 'filters', true);
    this.currentAction = createCurrentHook(this, 'actions');
    this.currentFilter = createCurrentHook(this, 'filters');
    this.doingAction = createDoingHook(this, 'actions');
    this.doingFilter = createDoingHook(this, 'filters');
    this.didAction = createDidHook(this, 'actions');
    this.didFilter = createDidHook(this, 'filters');
  }

}
/** @typedef {_Hooks} Hooks */

/**
 * Returns an instance of the hooks object.
 *
 * @return {Hooks} A Hooks instance.
 */

function createHooks() {
  return new _Hooks();
}

/**
 * Internal dependencies
 */
/** @typedef {(...args: any[])=>any} Callback */

/**
 * @typedef Handler
 * @property {Callback} callback  The callback
 * @property {string}   namespace The namespace
 * @property {number}   priority  The namespace
 */

/**
 * @typedef Hook
 * @property {Handler[]} handlers Array of handlers
 * @property {number}    runs     Run counter
 */

/**
 * @typedef Current
 * @property {string} name         Hook name
 * @property {number} currentIndex The index
 */

/**
 * @typedef {Record<string, Hook> & {__current: Current[]}} Store
 */

/**
 * @typedef {'actions' | 'filters'} StoreKey
 */

/**
 * @typedef {import('./createHooks').Hooks} Hooks
 */

const defaultHooks = createHooks();

/**
 * Internal dependencies
 */
const i18n = createI18n(undefined, undefined, defaultHooks);
/*
 * Comments in this file are duplicated from ./i18n due to
 * https://github.com/WordPress/gutenberg/pull/20318#issuecomment-590837722
 */

/**
 * @typedef {import('./create-i18n').LocaleData} LocaleData
 * @typedef {import('./create-i18n').SubscribeCallback} SubscribeCallback
 * @typedef {import('./create-i18n').UnsubscribeCallback} UnsubscribeCallback
 */

/**
 * Returns locale data by domain in a Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 *
 * @param {string} [domain] Domain for which to get the data.
 * @return {LocaleData} Locale data.
 */

i18n.getLocaleData.bind(i18n);
/**
 * Merges locale data into the Tannin instance by domain. Accepts data in a
 * Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 *
 * @param {LocaleData} [data]   Locale data configuration.
 * @param {string}     [domain] Domain for which configuration applies.
 */

i18n.setLocaleData.bind(i18n);
/**
 * Resets all current Tannin instance locale data and sets the specified
 * locale data for the domain. Accepts data in a Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 *
 * @param {LocaleData} [data]   Locale data configuration.
 * @param {string}     [domain] Domain for which configuration applies.
 */

i18n.resetLocaleData.bind(i18n);
/**
 * Subscribes to changes of locale data
 *
 * @param {SubscribeCallback} callback Subscription callback
 * @return {UnsubscribeCallback} Unsubscribe callback
 */

i18n.subscribe.bind(i18n);
/**
 * Retrieve the translation of text.
 *
 * @see https://developer.wordpress.org/reference/functions/__/
 *
 * @param {string} text     Text to translate.
 * @param {string} [domain] Domain to retrieve the translated text.
 *
 * @return {string} Translated text.
 */

const __ = i18n.__.bind(i18n);
/**
 * Retrieve translated string with gettext context.
 *
 * @see https://developer.wordpress.org/reference/functions/_x/
 *
 * @param {string} text     Text to translate.
 * @param {string} context  Context information for the translators.
 * @param {string} [domain] Domain to retrieve the translated text.
 *
 * @return {string} Translated context string without pipe.
 */

const _x = i18n._x.bind(i18n);
/**
 * Translates and retrieves the singular or plural form based on the supplied
 * number.
 *
 * @see https://developer.wordpress.org/reference/functions/_n/
 *
 * @param {string} single   The text to be used if the number is singular.
 * @param {string} plural   The text to be used if the number is plural.
 * @param {number} number   The number to compare against to use either the
 *                          singular or plural form.
 * @param {string} [domain] Domain to retrieve the translated text.
 *
 * @return {string} The translated singular or plural form.
 */

const _n = i18n._n.bind(i18n);
/**
 * Translates and retrieves the singular or plural form based on the supplied
 * number, with gettext context.
 *
 * @see https://developer.wordpress.org/reference/functions/_nx/
 *
 * @param {string} single   The text to be used if the number is singular.
 * @param {string} plural   The text to be used if the number is plural.
 * @param {number} number   The number to compare against to use either the
 *                          singular or plural form.
 * @param {string} context  Context information for the translators.
 * @param {string} [domain] Domain to retrieve the translated text.
 *
 * @return {string} The translated singular or plural form.
 */

i18n._nx.bind(i18n);
/**
 * Check if current locale is RTL.
 *
 * **RTL (Right To Left)** is a locale property indicating that text is written from right to left.
 * For example, the `he` locale (for Hebrew) specifies right-to-left. Arabic (ar) is another common
 * language written RTL. The opposite of RTL, LTR (Left To Right) is used in other languages,
 * including English (`en`, `en-US`, `en-GB`, etc.), Spanish (`es`), and French (`fr`).
 *
 * @return {boolean} Whether locale is RTL.
 */

i18n.isRTL.bind(i18n);
/**
 * Check if there is a translation for a given string (in singular form).
 *
 * @param {string} single    Singular form of the string to look up.
 * @param {string} [context] Context information for the translators.
 * @param {string} [domain]  Domain to retrieve the translated text.
 * @return {boolean} Whether the translation exists or not.
 */

i18n.hasTranslation.bind(i18n);

function slugify(...args) {
    const value = args.join(' ');
    return value
        .normalize('NFD') // split an accented letter in the base letter and the acent
        .replace(/[\u0300-\u036f]/g, '') // remove all previously split accents
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9 ]/g, '') // remove all chars not letters, numbers and spaces (to be replaced)
        .replace(/\s+/g, '-'); // separator
}

const scSlotContext = createContext(undefined);
function useScSlot() {
    return useContext(scSlotContext);
}

// CAUTION: ALL FUNCTIONS IN THIS FILE IS MUTATING
/**
 * Delete an element from array by finding it's index through equality.
 *
 * @param arr Array to operate on.
 * @param item Item to delete.
 */
function removeItemFromArrayByMutation(arr, item) {
    const index = arr.findIndex(val => val === item);
    if (index !== -1) {
        arr.splice(index, 1);
    }
}
/**
 * Mutate an array by inserting a new item on a new position.
 *
 * If position is -1, then we put the item at the end of the array.
 *
 * @param arr Array on which we operate
 * @param item Item to insert
 * @param position Position at which we insert
 */
function insertItemInArrayByMutation(arr, item, position) {
    if (position === -1) {
        arr.push(item);
    }
    else {
        arr.splice(position, 0, item);
    }
}
/**
 * Rearrange one item of an array and return a new array with changed order.
 *
 * To can be -1, in which case, it will be pushed at the end of the array.
 *
 * @param from Move item from.
 * @param to Move item to.
 * @param arr Original array.
 */
function reOrderArrayByMutation(from, to, arr) {
    if (to === from) {
        return;
    }
    const arrItem = arr.splice(from, 1);
    if (to === -1) {
        arr.push(...arrItem);
    }
    else {
        arr.splice(to, 0, ...arrItem);
    }
}
/**
 * Replace a single item in an array by mutation
 *
 * @param arr Array to replace at.
 * @param index Position at which we want to replace.
 * @param item Item to replace with.
 */
function replaceItemInArrayByMutation(arr, index, item) {
    arr[index] = item;
}
/**
 * Delete one item from an array by index, by mutation.
 *
 * If position is -1, then we delete from the end of the array.
 *
 * @param arr Array to delete from.
 * @param index Position at which to delete.
 */
function deleteItemInArrayByMutation(arr, index) {
    arr.splice(index, 1);
}
/**
 * Shuffle an array.
 *
 * @param array The array to shuffle
 */
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * i);
        const temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

/**
 * Determine whether an item is acceptable based on list of accepted and
 * unaccepted. This is used to determine element position acceptance at many
 * places.
 *
 * Most importantly, the logic resembles exactly that of PHP GraphQL API.
 *
 * @param item The item to determine.
 * @param accepted List of accepted items.
 * @param unaccepted List of unaccepted items.
 */
function isAcceptable(item, accepted = [], unaccepted = []) {
    // logic is same as PHP
    // Check inc/Form/Element/Base::validate_children
    if (accepted.length && !accepted.includes(item)) {
        return false;
    }
    if (unaccepted.length && unaccepted.includes(item)) {
        return false;
    }
    return true;
}
/**
 * A class to maintain collections in the same order as they are added.
 */
class Collections {
    /**
     * Dictionary of collections
     */
    collections = {};
    collectionOrder = [];
    /**
     * Name of the collection
     */
    name;
    changeCallbacks = [];
    /**
     * A collector function which runs on the given item.
     */
    collector = null;
    constructor(name, collector = null) {
        this.name = name;
        this.collector = collector;
    }
    /**
     * Subscribe to changes called through replaceItem.
     *
     * @param callback Callback to execute.
     * @returns Id of the subscription, use it to unsubscribe.
     */
    subscribeToChanges(callback) {
        const id = v4();
        this.changeCallbacks.push({
            id,
            callback,
        });
        return id;
    }
    unsubscribeFromChanges(id) {
        this.changeCallbacks = this.changeCallbacks.filter(cb => cb.id !== id);
    }
    addItem(id, item, order) {
        if (this.collections[id]) {
            throw new Error(`Collection ${this.name} with item ${id} already exists.`);
        }
        this.collections[id] = this.collector ? this.collector(item) : item;
        if (!order) {
            this.collectionOrder.push(id);
        }
        else {
            insertItemInArrayByMutation(this.collectionOrder, id, order);
        }
    }
    replaceItem(id, item) {
        if (!this.collections[id]) {
            throw new Error(`Collection ${this.name} with item ${id} does not exist.`);
        }
        this.collections[id] = this.collector ? this.collector(item) : item;
        this.changeCallbacks.forEach(cb => {
            cb.callback(id);
        });
    }
    addWithoutCollector(id, item) {
        if (this.collections[id]) {
            throw new Error(`Collection ${this.name} with item ${id} already exists.`);
        }
        this.collections[id] = item;
        this.collectionOrder.push(id);
    }
    getItem(id) {
        if (!this.collections[id]) {
            throw new Error(`Collection ${this.name} does not have item ${id}.`);
        }
        return this.collections[id];
    }
    hasItem(id) {
        return !!this.collections[id];
    }
    deleteItem(id) {
        // get the index
        const orderIndex = this.collectionOrder.findIndex(item => item === id);
        if (orderIndex !== -1) {
            // delete from collectionOrder
            this.collectionOrder.splice(orderIndex, 1);
            delete this.collections[id];
        }
        else {
            // if not found, then throw an error
            throw new Error(`Collection ${this.name} does not have item ${id}.`);
        }
    }
    getItems(accepted = [], unaccepted = [], filterFn) {
        const filteredCollectionOrder = this.collectionOrder.filter(id => {
            // if search is not empty and if the item doesn't match
            if (filterFn && !filterFn(this.collections[id], id)) {
                return false;
            }
            return isAcceptable(id, accepted, unaccepted);
        });
        return filteredCollectionOrder.map(key => ({
            id: key,
            item: this.collections[key],
        }));
    }
    resetItems() {
        this.collectionOrder = [];
        this.collections = {};
    }
}

const generalPalette = {
    // Neutrals [cool-grey]
    neutrals: {
        '050': '#F5F7FA',
        '100': '#E4E7EB',
        '200': '#CBD2D9',
        '300': '#9AA5B1',
        '400': '#7B8794',
        '500': '#616E7C',
        '600': '#52606D',
        '700': '#3E4C59',
        '800': '#323F4B',
        '900': '#1F2933',
    },
    // [red-vivid]
    red: {
        '050': '#FFE3E3',
        '100': '#FFBDBD',
        '200': '#FF9B9B',
        '300': '#F86A6A',
        '400': '#EF4E4E',
        '500': '#E12D39',
        '600': '#CF1124',
        '700': '#AB091E',
        '800': '#8A041A',
        '900': '#610316',
    },
    // [green-vivid]
    green: {
        '050': '#E3F9E5',
        '100': '#C1F2C7',
        '200': '#91E697',
        '300': '#51CA58',
        '400': '#31B237',
        '500': '#18981D',
        '600': '#0F8613',
        '700': '#0E7817',
        '800': '#07600E',
        '900': '#014807',
    },
    // [yellow-vivid]
    yellow: {
        '050': '#FFFBEA',
        '100': '#FFF3C4',
        '200': '#FCE588',
        '300': '#FADB5F',
        '400': '#F7C948',
        '500': '#F0B429',
        '600': '#DE911D',
        '700': '#CB6E17',
        '800': '#B44D12',
        '900': '#8D2B0B',
    },
};
const commonTheme = {
    // typography & sizes
    fontFamilyBody: `--apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif`,
    fontFamilyHeading: `--apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif`,
    fontFamilyMono: `"SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace`,
    fz: {
        small2: 12,
        small1: 14,
        base: 16,
        large1: 18,
        large2: 20,
        large3: 24,
        large4: 30,
        large5: 36,
        large6: 48,
        large7: 60,
        large8: 72,
    },
    boldHeading: true,
    italicHeading: false,
    // control appearance
    borderRadiusBase: 4,
    gutter: 20,
    controlHeightBase: 40,
    // generic box shadows
    boxShadowBase: '0 2px 8px rgba(0, 0, 0, .15)',
    boxShadowElevationOne: '0 1px 3px rgba(0, 0, 0, 0.01), 0 1px 2px rgba(0, 0, 0, 0.06)',
    boxShadowHover: '0 3px 6px rgba(0,0,0,0.01), 0 3px 6px rgba(0,0,0,0.06)',
    boxShadowBottom: '0 2px 3px rgba(0, 0, 0, 0.01), 0 2px 2px rgba(0, 0, 0, 0.06)',
    boxShadowTop: '0 -1px 2px rgba(0, 0, 0, 0.01), 0 -2px 6px rgba(0, 0, 0, 0.06)',
    boxShadowRight: '1px 0 3px 0 rgba(0,0,0,0.01), 1px 0 2px 0 rgba(0,0,0,0.06)',
    boxShadowInset: 'inset -1px 0 3px 0 rgba(0, 0, 0, 0.01), inset -2px 2px 6px 0 rgba(0,0,0,0.06)',
    boxShadowNoneFocus: `0 0 0 0 transparent`,
    /* Shadow 1dp */
    boxShadow1dp: `0 1px 1px 0 rgba(0,0,0,0.14), 0 2px 1px -1px rgba(0,0,0,0.12), 0 1px 3px 0 rgba(0,0,0,0.20)`,
    /* Shadow 2dp */
    boxShadow2dp: `0 2px 2px 0 rgba(0,0,0,0.14), 0 3px 1px -2px rgba(0,0,0,0.12), 0 1px 5px 0 rgba(0,0,0,0.20)`,
    /* Shadow 3dp */
    boxShadow3dp: `0 3px 4px 0 rgba(0,0,0,0.14), 0 3px 3px -2px rgba(0,0,0,0.12), 0 1px 8px 0 rgba(0,0,0,0.20)`,
    /* Shadow 4dp */
    boxShadow4dp: `0 4px 5px 0 rgba(0,0,0,0.14), 0 1px 10px 0 rgba(0,0,0,0.12), 0 2px 4px -1px rgba(0,0,0,0.20)`,
    /* Shadow 6dp */
    boxShadow6dp: `0 6px 10px 0 rgba(0,0,0,0.14), 0 1px 18px 0 rgba(0,0,0,0.12), 0 3px 5px -1px rgba(0,0,0,0.20)`,
    /* Shadow 8dp */
    boxShadow8dp: `0 8px 10px 1px rgba(0,0,0,0.14), 0 3px 14px 2px rgba(0,0,0,0.12), 0 5px 5px -3px rgba(0,0,0,0.20)`,
    /* Shadow 9dp */
    boxShadow9dp: `0 9px 12px 1px rgba(0,0,0,0.14), 0 3px 16px 2px rgba(0,0,0,0.12), 0 5px 6px -3px rgba(0,0,0,0.20)`,
    /* Shadow 12dp */
    boxShadow12dp: `0 12px 17px 2px rgba(0,0,0,0.14), 0 5px 22px 4px rgba(0,0,0,0.12), 0 7px 8px -4px rgba(0,0,0,0.20)`,
    /* Shadow 16dp */
    boxShadow16dp: `0 16px 24px 2px rgba(0,0,0,0.14), 0 6px 30px 5px rgba(0,0,0,0.12), 0 8px 10px -5px rgba(0,0,0,0.20)`,
    /* Shadow 24dp */
    boxShadow24dp: `0 24px 38px 3px rgba(0,0,0,0.14), 0 9px 46px 8px rgba(0,0,0,0.12), 0 11px 15px -7px rgba(0,0,0,0.20)`,
    // transitions
    transition: '300ms ease-out',
    transitionControl: '200ms ease-out',
    transitionBeizer: '300ms cubic-bezier(0.755, 0.05, 0.855, 0.06)',
    springConfigGeneral: config.gentle,
    springConfigStiff: config.stiff,
    springConfigSlow: config.slow,
    // breakpoints
    breakpoints: {
        tablet: 600,
        desktop: 1024 - 40,
        desktopHd: 1200,
    },
};
function makeTheme(palette) {
    const neutrals = palette.neutrals ?? generalPalette.neutrals;
    const red = palette.red ?? generalPalette.red;
    const green = palette.green ?? generalPalette.green;
    const yellow = palette.yellow ?? generalPalette.yellow;
    return {
        // alert colors
        successColor: green['600'],
        warningColor: yellow['500'],
        errorColor: red['600'],
        errorBackgroundColor: red['050'],
        successBackgroundColor: green['050'],
        warningBackgroundColor: yellow['050'],
        // general colors
        primaryLightColor: palette.primary['400'],
        primaryColor: palette.primary['500'],
        primaryDarkColor: palette.primary['700'],
        primaryBackgroundColor: palette.primary['050'],
        primaryBgText: '#ffffff',
        accentColor: palette.accent?.['700'] ?? palette.primary['800'],
        greyLightColor: neutrals['400'],
        greyColor: neutrals['500'],
        greyDarkColor: neutrals['700'],
        greyBgText: '#ffffff',
        backgroundShade: neutrals['050'],
        backgroundControl: curriedLighten(0.05, neutrals['100']),
        backgroundHover: curriedDarken(0.05, neutrals['050']),
        appBackgroundColor: '#ffffff',
        linkColor: palette.primary['500'],
        // typography colors
        headingColor: neutrals['800'],
        textColor: neutrals['900'],
        textColorSecondary: neutrals['500'],
        darkTextColor: neutrals['900'],
        lightTextColor: neutrals['050'],
        // control colors
        disabledColor: neutrals['200'],
        disabledBackgroundColor: curriedLighten(0.05, neutrals['100']),
        borderColorBase: neutrals['300'],
        borderColorSplit: neutrals['200'],
        borderColorLight: neutrals['100'],
        backgroundSelected: neutrals['100'],
        borderColorError: red['300'],
        // box shadows
        // 12 is the small2 font size
        boxShadowControlFocus: `0 0 0 ${numToCssSize(12 / 4)} ${curriedTransparentize(0.8, palette.primary['500'])}`,
        boxShadowControlFocusError: `0 0 0 ${numToCssSize(12 / 4)} ${curriedTransparentize(0.8, red['500'])}`,
        boxShadowControlFocusSuccess: `0 0 0 ${numToCssSize(12 / 4)} ${curriedTransparentize(0.8, green['500'])}`,
        boxShadowFocus: `0 0 0 2px ${curriedTransparentize(0.5, palette.primary['500'])}`,
        ...commonTheme,
        dark: {
            // alert colors
            successColor: green['300'],
            warningColor: yellow['300'],
            errorColor: red['300'],
            errorBackgroundColor: red['900'],
            successBackgroundColor: green['900'],
            warningBackgroundColor: yellow['900'],
            // general colors
            primaryBackgroundColor: palette.primary['800'],
            backgroundShade: neutrals['800'],
            backgroundControl: curriedLighten(0.05, neutrals['700']),
            backgroundHover: curriedDarken(0.05, neutrals['800']),
            appBackgroundColor: neutrals['900'],
            linkColor: palette.primary['200'],
            // typography colors
            headingColor: neutrals['200'],
            textColor: neutrals['050'],
            textColorSecondary: neutrals['200'],
            darkTextColor: neutrals['100'],
            lightTextColor: neutrals['700'],
            // control colors
            disabledColor: neutrals['600'],
            disabledBackgroundColor: curriedLighten(0.04, neutrals['900']),
            borderColorBase: neutrals['500'],
            borderColorSplit: neutrals['600'],
            borderColorLight: neutrals['700'],
            backgroundSelected: neutrals['700'],
            borderColorError: red['600'],
            // box shadows
            // 12 is the small2 font size
            boxShadowControlFocus: `0 0 0 ${numToCssSize(12 / 4)} ${curriedTransparentize(0.8, palette.primary['500'])}`,
            boxShadowControlFocusError: `0 0 0 ${numToCssSize(12 / 4)} ${curriedTransparentize(0.8, red['500'])}`,
            boxShadowControlFocusSuccess: `0 0 0 ${numToCssSize(12 / 4)} ${curriedTransparentize(0.8, green['500'])}`,
            boxShadowFocus: `0 0 0 2px ${curriedTransparentize(0.5, palette.primary['500'])}`,
        },
    };
}

const vividBlue = makeTheme({
    // Primary [blue-vivid]
    primary: {
        '050': '#E6F6FF',
        '100': '#BAE3FF',
        '200': '#7CC4FA',
        '300': '#47A3F3',
        '400': '#2186EB',
        '500': '#0967D2',
        '600': '#0552B5',
        '700': '#03449E',
        '800': '#01337D',
        '900': '#002159',
    },
    // accent
    accent: {
        '700': '#099AA4',
    },
});
const teal = makeTheme({
    primary: {
        '050': '#EFFCF6',
        '100': '#C6F7E2',
        '200': '#8EEDC7',
        '300': '#65D6AD',
        '400': '#3EBD93',
        '500': '#27AB83',
        '600': '#199473',
        '700': '#147D64',
        '800': '#0C6B58',
        '900': '#014D40',
    },
    // accent
    accent: {
        '700': '#421987',
    },
});
const wp = makeTheme({
    primary: {
        '050': '#c5d9ed',
        '100': '#f0f0f1',
        '200': '#72aee6',
        '300': '#4f94d4',
        '400': '#3582c4',
        '500': '#2271b1',
        '600': '#135e96',
        '700': '#0a4b78',
        '800': '#043959',
        '900': '#01263a',
    },
    neutrals: {
        '050': '#dcdcde',
        '100': '#c3c4c7',
        '200': '#a7aaad',
        '300': '#8c8f94',
        '400': '#787c82',
        '500': '#646970',
        '600': '#50575e',
        '700': '#3c434a',
        '800': '#2c3338',
        '900': '#1d2327',
    },
    red: {
        '050': '#facfd2',
        '100': '#ffabaf',
        '200': '#ff8085',
        '300': '#f86368',
        '400': '#e65054',
        '500': '#d63638',
        '600': '#b32d2e',
        '700': '#8a2424',
        '800': '#691c1c',
        '900': '#451313',
    },
    green: {
        '050': '#b8e6bf',
        '100': '#68de7c',
        '200': '#1ed14b',
        '300': '#00ba37',
        '400': '#00a32a',
        '500': '#008a20',
        '600': '#007017',
        '700': '#005c12',
        '800': '#00450c',
        '900': '#003008',
    },
    yellow: {
        '050': '#f5e6ab',
        '100': '#f2d675',
        '200': '#f0c33c',
        '300': '#dba617',
        '400': '#bd8600',
        '500': '#996800',
        '600': '#755100',
        '700': '#614200',
        '800': '#4a3200',
        '900': '#362400',
    },
});

const materialRed = makeTheme({
    primary: {
        '050': '#FFEBEE',
        '100': '#FFCDD2',
        '200': '#EF9A9A',
        '300': '#E57373',
        // '400': '#EF5350',
        '400': '#F44336',
        // '500': '#F44336',
        '500': '#E53935',
        '600': '#E53935',
        '700': '#D32F2F',
        '800': '#C62828',
        '900': '#B71C1C',
    },
    accent: {
        '700': '#D50000',
    },
});
const materialPink = makeTheme({
    primary: {
        '050': '#FCE4EC',
        '100': '#F8BBD0',
        '200': '#F48FB1',
        '300': '#F06292',
        // '400': '#EC407A',
        '400': '#E91E63',
        // '500': '#E91E63',
        '500': '#D81B60',
        '600': '#D81B60',
        '700': '#C2185B',
        '800': '#AD1457',
        '900': '#880E4F',
    },
    accent: {
        '700': '#C51162',
    },
});
const materialPurple = makeTheme({
    primary: {
        '050': '#F3E5F5',
        '100': '#E1BEE7',
        '200': '#CE93D8',
        '300': '#BA68C8',
        '400': '#AB47BC',
        '500': '#9C27B0',
        '600': '#8E24AA',
        '700': '#7B1FA2',
        '800': '#6A1B9A',
        '900': '#4A148C',
    },
    accent: {
        '700': '#AA00FF',
    },
});
const materialDeepPurple = makeTheme({
    primary: {
        '050': '#EDE7F6',
        '100': '#D1C4E9',
        '200': '#B39DDB',
        '300': '#9575CD',
        '400': '#7E57C2',
        '500': '#673AB7',
        '600': '#5E35B1',
        '700': '#512DA8',
        '800': '#4527A0',
        '900': '#311B92',
    },
    accent: {
        '700': '#6200EA',
    },
});
const materialIndigo = makeTheme({
    primary: {
        '050': '#E8EAF6',
        '100': '#C5CAE9',
        '200': '#9FA8DA',
        '300': '#7986CB',
        '400': '#5C6BC0',
        '500': '#3F51B5',
        '600': '#3949AB',
        '700': '#303F9F',
        '800': '#283593',
        '900': '#1A237E',
    },
    accent: {
        '700': '#304FFE',
    },
});
const materialBlue = makeTheme({
    primary: {
        '050': '#E3F2FD',
        '100': '#BBDEFB',
        '200': '#90CAF9',
        '300': '#64B5F6',
        // '400': '#42A5F5',
        '400': '#2196F3',
        // '500': '#2196F3',
        '500': '#1E88E5',
        '600': '#1E88E5',
        '700': '#1976D2',
        '800': '#1565C0',
        '900': '#0D47A1',
    },
    accent: {
        '700': '#2962FF',
    },
});
const materialBrown = makeTheme({
    primary: {
        '050': '#EFEBE9',
        '100': '#D7CCC8',
        '200': '#BCAAA4',
        '300': '#A1887F',
        '400': '#8D6E63',
        '500': '#795548',
        '600': '#6D4C41',
        '700': '#5D4037',
        '800': '#4E342E',
        '900': '#3E2723',
    },
});
const materialGray = makeTheme({
    primary: {
        '050': '#FAFAFA',
        '100': '#F5F5F5',
        '200': '#EEEEEE',
        '300': '#E0E0E0',
        // '400': '#BDBDBD',
        '400': '#9E9E9E',
        // '500': '#9E9E9E',
        '500': '#757575',
        '600': '#757575',
        '700': '#616161',
        '800': '#424242',
        '900': '#212121',
    },
});
const materialBlueGray = makeTheme({
    primary: {
        '050': '#ECEFF1',
        '100': '#CFD8DC',
        '200': '#B0BEC5',
        '300': '#90A4AE',
        '400': '#78909C',
        '500': '#607D8B',
        '600': '#546E7A',
        '700': '#455A64',
        '800': '#37474F',
        '900': '#263238',
    },
});

const wpEFormThemes = new Collections('WPEForm Themes');
wpEFormThemes.addItem('vividblue', {
    name: 'Vivid Blue',
    config: vividBlue,
});
wpEFormThemes.addItem('teal', { name: 'Teal', config: teal });
wpEFormThemes.addItem('wp', { name: 'WordPress 5.7 Palette', config: wp });
wpEFormThemes.addItem('materialblue', {
    name: 'Material Blue',
    config: materialBlue,
});
wpEFormThemes.addItem('materialbluegray', {
    name: 'Material Blue Gray',
    config: materialBlueGray,
});
wpEFormThemes.addItem('materialbrown', {
    name: 'Material Brown',
    config: materialBrown,
});
wpEFormThemes.addItem('materialdeeppurple', {
    name: 'Material Deep Purple',
    config: materialDeepPurple,
});
wpEFormThemes.addItem('materialgray', {
    name: 'Material Gray',
    config: materialGray,
});
wpEFormThemes.addItem('materialindigo', {
    name: 'Material Indigo',
    config: materialIndigo,
});
wpEFormThemes.addItem('materialpink', {
    name: 'Material Pink',
    config: materialPink,
});
wpEFormThemes.addItem('materialpurple', {
    name: 'Material Purple',
    config: materialPurple,
});
wpEFormThemes.addItem('materialred', {
    name: 'Material Red',
    config: materialRed,
});

/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
}

/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObjectObject(o) {
  return isObject(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
}

var esrever = {exports: {}};

/*! https://mths.be/esrever v0.2.0 by @mathias */

(function (module, exports) {
(function(root) {

	// Detect free variables `exports`
	var freeExports = exports;

	// Detect free variable `module`
	var freeModule = module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var regexSymbolWithCombiningMarks = /([\0-\u02FF\u0370-\u1AAF\u1B00-\u1DBF\u1E00-\u20CF\u2100-\uD7FF\uE000-\uFE1F\uFE30-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])([\u0300-\u036F\u1AB0-\u1AFF\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]+)/g;
	var regexSurrogatePair = /([\uD800-\uDBFF])([\uDC00-\uDFFF])/g;

	var reverse = function(string) {
		// Step 1: deal with combining marks and astral symbols (surrogate pairs)
		string = string
			// Swap symbols with their combining marks so the combining marks go first
			.replace(regexSymbolWithCombiningMarks, function($0, $1, $2) {
				// Reverse the combining marks so they will end up in the same order
				// later on (after another round of reversing)
				return reverse($2) + $1;
			})
			// Swap high and low surrogates so the low surrogates go first
			.replace(regexSurrogatePair, '$2$1');
		// Step 2: reverse the code units in the string
		var result = '';
		var index = string.length;
		while (index--) {
			result += string.charAt(index);
		}
		return result;
	};

	/*--------------------------------------------------------------------------*/

	var esrever = {
		'version': '0.2.0',
		'reverse': reverse
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = esrever;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (var key in esrever) {
				esrever.hasOwnProperty(key) && (freeExports[key] = esrever[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.esrever = esrever;
	}

}(this));
}(esrever, esrever.exports));

function n$1(n){for(var r=arguments.length,t=Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];throw Error("[Immer] minified error nr: "+n+(t.length?" "+t.map((function(n){return "'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function r$1(n){return !!n&&!!n[Q$1]}function t$1(n){return !!n&&(function(n){if(!n||"object"!=typeof n)return !1;var r=Object.getPrototypeOf(n);if(null===r)return !0;var t=Object.hasOwnProperty.call(r,"constructor")&&r.constructor;return "function"==typeof t&&Function.toString.call(t)===Z$1}(n)||Array.isArray(n)||!!n[L$1]||!!n.constructor[L$1]||s$1(n)||v$1(n))}function i$1(n,r,t){void 0===t&&(t=!1),0===o$1(n)?(t?Object.keys:nn$1)(n).forEach((function(e){t&&"symbol"==typeof e||r(e,n[e],n);})):n.forEach((function(t,e){return r(e,t,n)}));}function o$1(n){var r=n[Q$1];return r?r.i>3?r.i-4:r.i:Array.isArray(n)?1:s$1(n)?2:v$1(n)?3:0}function u$1(n,r){return 2===o$1(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function a$1(n,r){return 2===o$1(n)?n.get(r):n[r]}function f$1(n,r,t){var e=o$1(n);2===e?n.set(r,t):3===e?(n.delete(r),n.add(t)):n[r]=t;}function c$1(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function s$1(n){return X$1&&n instanceof Map}function v$1(n){return q$1&&n instanceof Set}function p$1(n){return n.o||n.t}function l$1(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=rn$1(n);delete r[Q$1];for(var t=nn$1(r),e=0;e<t.length;e++){var i=t[e],o=r[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(r[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]});}return Object.create(Object.getPrototypeOf(n),r)}function d$1(n,e){return void 0===e&&(e=!1),y$1(n)||r$1(n)||!t$1(n)?n:(o$1(n)>1&&(n.set=n.add=n.clear=n.delete=h$1),Object.freeze(n),e&&i$1(n,(function(n,r){return d$1(r,!0)}),!0),n)}function h$1(){n$1(2);}function y$1(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function b$1(r){var t=tn$1[r];return t||n$1(18,r),t}function _$1(){return U$1}function j$1(n,r){r&&(b$1("Patches"),n.u=[],n.s=[],n.v=r);}function g$1(n){O$1(n),n.p.forEach(S$1),n.p=null;}function O$1(n){n===U$1&&(U$1=n.l);}function w$1(n){return U$1={p:[],l:U$1,h:n,m:!0,_:0}}function S$1(n){var r=n[Q$1];0===r.i||1===r.i?r.j():r.g=!0;}function P$1(r,e){e._=e.p.length;var i=e.p[0],o=void 0!==r&&r!==i;return e.h.O||b$1("ES5").S(e,r,o),o?(i[Q$1].P&&(g$1(e),n$1(4)),t$1(r)&&(r=M$1(e,r),e.l||x$1(e,r)),e.u&&b$1("Patches").M(i[Q$1],r,e.u,e.s)):r=M$1(e,i,[]),g$1(e),e.u&&e.v(e.u,e.s),r!==H$1?r:void 0}function M$1(n,r,t){if(y$1(r))return r;var e=r[Q$1];if(!e)return i$1(r,(function(i,o){return A$1(n,e,r,i,o,t)}),!0),r;if(e.A!==n)return r;if(!e.P)return x$1(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l$1(e.k):e.o;i$1(3===e.i?new Set(o):o,(function(r,i){return A$1(n,e,o,r,i,t)})),x$1(n,o,!1),t&&n.u&&b$1("Patches").R(e,t,n.u,n.s);}return e.o}function A$1(e,i,o,a,c,s){if(r$1(c)){var v=M$1(e,c,s&&i&&3!==i.i&&!u$1(i.D,a)?s.concat(a):void 0);if(f$1(o,a,v),!r$1(v))return;e.m=!1;}if(t$1(c)&&!y$1(c)){if(!e.h.F&&e._<1)return;M$1(e,c),i&&i.A.l||x$1(e,c);}}function x$1(n,r,t){void 0===t&&(t=!1),n.h.F&&n.m&&d$1(r,t);}function z$1(n,r){var t=n[Q$1];return (t?p$1(t):n)[r]}function I$1(n,r){if(r in n)for(var t=Object.getPrototypeOf(n);t;){var e=Object.getOwnPropertyDescriptor(t,r);if(e)return e;t=Object.getPrototypeOf(t);}}function k$1(n){n.P||(n.P=!0,n.l&&k$1(n.l));}function E$1(n){n.o||(n.o=l$1(n.t));}function R$1(n,r,t){var e=s$1(r)?b$1("MapSet").N(r,t):v$1(r)?b$1("MapSet").T(r,t):n.O?function(n,r){var t=Array.isArray(n),e={i:t?1:0,A:r?r.A:_$1(),P:!1,I:!1,D:{},l:r,t:n,k:null,o:null,j:null,C:!1},i=e,o=en$1;t&&(i=[e],o=on$1);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(r,t):b$1("ES5").J(r,t);return (t?t.A:_$1()).p.push(e),e}function D$1(e){return r$1(e)||n$1(22,e),function n(r){if(!t$1(r))return r;var e,u=r[Q$1],c=o$1(r);if(u){if(!u.P&&(u.i<4||!b$1("ES5").K(u)))return u.t;u.I=!0,e=F$1(r,c),u.I=!1;}else e=F$1(r,c);return i$1(e,(function(r,t){u&&a$1(u.t,r)===t||f$1(e,r,n(t));})),3===c?new Set(e):e}(e)}function F$1(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return l$1(n)}var G$1,U$1,W$1="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X$1="undefined"!=typeof Map,q$1="undefined"!=typeof Set,B$1="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H$1=W$1?Symbol.for("immer-nothing"):((G$1={})["immer-nothing"]=!0,G$1),L$1=W$1?Symbol.for("immer-draftable"):"__$immer_draftable",Q$1=W$1?Symbol.for("immer-state"):"__$immer_state",Z$1=""+Object.prototype.constructor,nn$1="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,rn$1=Object.getOwnPropertyDescriptors||function(n){var r={};return nn$1(n).forEach((function(t){r[t]=Object.getOwnPropertyDescriptor(n,t);})),r},tn$1={},en$1={get:function(n,r){if(r===Q$1)return n;var e=p$1(n);if(!u$1(e,r))return function(n,r,t){var e,i=I$1(r,t);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,r);var i=e[r];return n.I||!t$1(i)?i:i===z$1(n.t,r)?(E$1(n),n.o[r]=R$1(n.A.h,i,n)):i},has:function(n,r){return r in p$1(n)},ownKeys:function(n){return Reflect.ownKeys(p$1(n))},set:function(n,r,t){var e=I$1(p$1(n),r);if(null==e?void 0:e.set)return e.set.call(n.k,t),!0;if(!n.P){var i=z$1(p$1(n),r),o=null==i?void 0:i[Q$1];if(o&&o.t===t)return n.o[r]=t,n.D[r]=!1,!0;if(c$1(t,i)&&(void 0!==t||u$1(n.t,r)))return !0;E$1(n),k$1(n);}return n.o[r]===t&&"number"!=typeof t||(n.o[r]=t,n.D[r]=!0,!0)},deleteProperty:function(n,r){return void 0!==z$1(n.t,r)||r in n.t?(n.D[r]=!1,E$1(n),k$1(n)):delete n.D[r],n.o&&delete n.o[r],!0},getOwnPropertyDescriptor:function(n,r){var t=p$1(n),e=Reflect.getOwnPropertyDescriptor(t,r);return e?{writable:!0,configurable:1!==n.i||"length"!==r,enumerable:e.enumerable,value:t[r]}:e},defineProperty:function(){n$1(11);},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n$1(12);}},on$1={};i$1(en$1,(function(n,r){on$1[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)};})),on$1.deleteProperty=function(r,t){return en$1.deleteProperty.call(this,r[0],t)},on$1.set=function(r,t,e){return en$1.set.call(this,r[0],t,e,r[0])};var un$1=function(){function e(r){var e=this;this.O=B$1,this.F=!0,this.produce=function(r,i,o){if("function"==typeof r&&"function"!=typeof i){var u=i;i=r;var a=e;return function(n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return (t=i).call.apply(t,[r,n].concat(e))}))}}var f;if("function"!=typeof i&&n$1(6),void 0!==o&&"function"!=typeof o&&n$1(7),t$1(r)){var c=w$1(e),s=R$1(e,r,void 0),v=!0;try{f=i(s),v=!1;}finally{v?g$1(c):O$1(c);}return "undefined"!=typeof Promise&&f instanceof Promise?f.then((function(n){return j$1(c,o),P$1(n,c)}),(function(n){throw g$1(c),n})):(j$1(c,o),P$1(f,c))}if(!r||"object"!=typeof r){if((f=i(r))===H$1)return;return void 0===f&&(f=r),e.F&&d$1(f,!0),f}n$1(21,r);},this.produceWithPatches=function(n,r){return "function"==typeof n?function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))}:[e.produce(n,r,(function(n,r){t=n,i=r;})),t,i];var t,i;},"boolean"==typeof(null==r?void 0:r.useProxies)&&this.setUseProxies(r.useProxies),"boolean"==typeof(null==r?void 0:r.autoFreeze)&&this.setAutoFreeze(r.autoFreeze);}var i=e.prototype;return i.createDraft=function(e){t$1(e)||n$1(8),r$1(e)&&(e=D$1(e));var i=w$1(this),o=R$1(this,e,void 0);return o[Q$1].C=!0,O$1(i),o},i.finishDraft=function(r,t){var e=r&&r[Q$1];var i=e.A;return j$1(i,t),P$1(void 0,i)},i.setAutoFreeze=function(n){this.F=n;},i.setUseProxies=function(r){r&&!B$1&&n$1(20),this.O=r;},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}var o=b$1("Patches").$;return r$1(n)?o(n,t):this.produce(n,(function(n){return o(n,t.slice(e+1))}))},e}(),an$1=new un$1,fn$1=an$1.produce;an$1.produceWithPatches.bind(an$1);an$1.setAutoFreeze.bind(an$1);an$1.setUseProxies.bind(an$1);an$1.applyPatches.bind(an$1);var ln=an$1.createDraft.bind(an$1),dn=an$1.finishDraft.bind(an$1);

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var DIRTY_PATHS = new WeakMap();
var NORMALIZING = new WeakMap();
var PATH_REFS = new WeakMap();
var POINT_REFS = new WeakMap();
var RANGE_REFS = new WeakMap();

function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties$2(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$3(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/**
 * Constants for string distance checking.
 */
var SPACE = /\s/;
var PUNCTUATION = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var CHAMELEON = /['\u2018\u2019]/;
var SURROGATE_START = 0xd800;
var SURROGATE_END = 0xdfff;
var ZERO_WIDTH_JOINER = 0x200d;
/**
 * Get the distance to the end of the first character in a string of text.
 */

var getCharacterDistance = text => {
  var offset = 0; // prev types:
  // SURR: surrogate pair
  // MOD: modifier (technically also surrogate pair)
  // ZWJ: zero width joiner
  // VAR: variation selector
  // BMP: sequenceable character from basic multilingual plane

  var prev = null;
  var charCode = text.charCodeAt(0);

  while (charCode) {
    if (isSurrogate(charCode)) {
      var modifier = isModifier(charCode, text, offset); // Early returns are the heart of this function, where we decide if previous and current
      // codepoints should form a single character (in terms of how many of them should selection
      // jump over).

      if (prev === 'SURR' || prev === 'BMP') {
        break;
      }

      offset += 2;
      prev = modifier ? 'MOD' : 'SURR';
      charCode = text.charCodeAt(offset); // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which
      // is the case when out of `text` range), next `while` loop won"t execute and we"re done.

      continue;
    }

    if (charCode === ZERO_WIDTH_JOINER) {
      offset += 1;
      prev = 'ZWJ';
      charCode = text.charCodeAt(offset);
      continue;
    }

    if (isBMPEmoji(charCode)) {
      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {
        break;
      }

      offset += 1;
      prev = 'BMP';
      charCode = text.charCodeAt(offset);
      continue;
    }

    if (isVariationSelector(charCode)) {
      if (prev && prev !== 'ZWJ') {
        break;
      }

      offset += 1;
      prev = 'VAR';
      charCode = text.charCodeAt(offset);
      continue;
    } // Modifier 'groups up' with what ever character is before that (even whitespace), need to
    // look ahead.


    if (prev === 'MOD') {
      offset += 1;
      break;
    } // If while loop ever gets here, we're done (e.g latin chars).


    break;
  }

  return offset || 1;
};
/**
 * Get the distance to the end of the first word in a string of text.
 */

var getWordDistance = text => {
  var length = 0;
  var i = 0;
  var started = false;
  var char;

  while (char = text.charAt(i)) {
    var l = getCharacterDistance(char);
    char = text.slice(i, i + l);
    var rest = text.slice(i + l);

    if (isWordCharacter(char, rest)) {
      started = true;
      length += l;
    } else if (!started) {
      length += l;
    } else {
      break;
    }

    i += l;
  }

  return length;
};
/**
 * Check if a character is a word character. The `remaining` argument is used
 * because sometimes you must read subsequent characters to truly determine it.
 */

var isWordCharacter = (char, remaining) => {
  if (SPACE.test(char)) {
    return false;
  } // Chameleons count as word characters as long as they're in a word, so
  // recurse to see if the next one is a word character or not.


  if (CHAMELEON.test(char)) {
    var next = remaining.charAt(0);
    var length = getCharacterDistance(next);
    next = remaining.slice(0, length);
    var rest = remaining.slice(length);

    if (isWordCharacter(next, rest)) {
      return true;
    }
  }

  if (PUNCTUATION.test(char)) {
    return false;
  }

  return true;
};
/**
 * Determines if `code` is a surrogate
 */


var isSurrogate = code => SURROGATE_START <= code && code <= SURROGATE_END;
/**
 * Does `code` form Modifier with next one.
 *
 * https://emojipedia.org/modifiers/
 */


var isModifier = (code, text, offset) => {
  if (code === 0xd83c) {
    var next = text.charCodeAt(offset + 1);
    return next <= 0xdfff && next >= 0xdffb;
  }

  return false;
};
/**
 * Is `code` a Variation Selector.
 *
 * https://codepoints.net/variation_selectors
 */


var isVariationSelector = code => {
  return code <= 0xfe0f && code >= 0xfe00;
};
/**
 * Is `code` one of the BMP codes used in emoji sequences.
 *
 * https://emojipedia.org/emoji-zwj-sequences/
 */


var isBMPEmoji = code => {
  // This requires tiny bit of maintanance, better ideas?
  // Fortunately it only happens if new Unicode Standard
  // is released. Fails gracefully if upkeep lags behind,
  // same way Slate previously behaved with all emojis.
  return code === 0x2764 || // heart (❤)
  code === 0x2642 || // male (♂)
  code === 0x2640 || // female (♀)
  code === 0x2620 || // scull (☠)
  code === 0x2695 || // medical (⚕)
  code === 0x2708 || // plane (✈️)
  code === 0x25ef // large circle (◯)
  ;
};

var Element$2 = {
  /**
   * Check if a value implements the 'Ancestor' interface.
   */
  isAncestor(value) {
    return isPlainObject(value) && Node.isNodeList(value.children);
  },

  /**
   * Check if a value implements the `Element` interface.
   */
  isElement(value) {
    return isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);
  },

  /**
   * Check if a value is an array of `Element` objects.
   */
  isElementList(value) {
    return Array.isArray(value) && value.every(val => Element$2.isElement(val));
  },

  /**
   * Check if a set of props is a partial of Element.
   */
  isElementProps(props) {
    return props.children !== undefined;
  },

  /**
   * Check if an element matches set of properties.
   *
   * Note: this checks custom properties, and it does not ensure that any
   * children are equivalent.
   */
  matches(element, props) {
    for (var key in props) {
      if (key === 'children') {
        continue;
      }

      if (element[key] !== props[key]) {
        return false;
      }
    }

    return true;
  }

};

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var IS_EDITOR_CACHE = new WeakMap();
var Editor = {
  /**
   * Get the ancestor above a location in the document.
   */
  above(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      voids = false,
      mode = 'lowest',
      at = editor.selection,
      match
    } = options;

    if (!at) {
      return;
    }

    var path = Editor.path(editor, at);
    var reverse = mode === 'lowest';

    for (var [n, p] of Editor.levels(editor, {
      at: path,
      voids,
      match,
      reverse
    })) {
      if (!Text$4.isText(n) && !Path.equals(path, p)) {
        return [n, p];
      }
    }
  },

  /**
   * Add a custom property to the leaf text nodes in the current selection.
   *
   * If the selection is currently collapsed, the marks will be added to the
   * `editor.marks` property instead, and applied when text is inserted next.
   */
  addMark(editor, key, value) {
    editor.addMark(key, value);
  },

  /**
   * Get the point after a location.
   */
  after(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var anchor = Editor.point(editor, at, {
      edge: 'end'
    });
    var focus = Editor.end(editor, []);
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d = 0;
    var target;

    for (var p of Editor.positions(editor, _objectSpread$1(_objectSpread$1({}, options), {}, {
      at: range
    }))) {
      if (d > distance) {
        break;
      }

      if (d !== 0) {
        target = p;
      }

      d++;
    }

    return target;
  },

  /**
   * Get the point before a location.
   */
  before(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var anchor = Editor.start(editor, []);
    var focus = Editor.point(editor, at, {
      edge: 'start'
    });
    var range = {
      anchor,
      focus
    };
    var {
      distance = 1
    } = options;
    var d = 0;
    var target;

    for (var p of Editor.positions(editor, _objectSpread$1(_objectSpread$1({}, options), {}, {
      at: range,
      reverse: true
    }))) {
      if (d > distance) {
        break;
      }

      if (d !== 0) {
        target = p;
      }

      d++;
    }

    return target;
  },

  /**
   * Delete content in the editor backward from the current selection.
   */
  deleteBackward(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      unit = 'character'
    } = options;
    editor.deleteBackward(unit);
  },

  /**
   * Delete content in the editor forward from the current selection.
   */
  deleteForward(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      unit = 'character'
    } = options;
    editor.deleteForward(unit);
  },

  /**
   * Delete the content in the current selection.
   */
  deleteFragment(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      direction = 'forward'
    } = options;
    editor.deleteFragment(direction);
  },

  /**
   * Get the start and end points of a location.
   */
  edges(editor, at) {
    return [Editor.start(editor, at), Editor.end(editor, at)];
  },

  /**
   * Get the end point of a location.
   */
  end(editor, at) {
    return Editor.point(editor, at, {
      edge: 'end'
    });
  },

  /**
   * Get the first node at a location.
   */
  first(editor, at) {
    var path = Editor.path(editor, at, {
      edge: 'start'
    });
    return Editor.node(editor, path);
  },

  /**
   * Get the fragment at a location.
   */
  fragment(editor, at) {
    var range = Editor.range(editor, at);
    var fragment = Node.fragment(editor, range);
    return fragment;
  },

  /**
   * Check if a node has block children.
   */
  hasBlocks(editor, element) {
    return element.children.some(n => Editor.isBlock(editor, n));
  },

  /**
   * Check if a node has inline and text children.
   */
  hasInlines(editor, element) {
    return element.children.some(n => Text$4.isText(n) || Editor.isInline(editor, n));
  },

  /**
   * Check if a node has text children.
   */
  hasTexts(editor, element) {
    return element.children.every(n => Text$4.isText(n));
  },

  /**
   * Insert a block break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertBreak(editor) {
    editor.insertBreak();
  },

  /**
   * Insert a fragment at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertFragment(editor, fragment) {
    editor.insertFragment(fragment);
  },

  /**
   * Insert a node at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertNode(editor, node) {
    editor.insertNode(node);
  },

  /**
   * Insert text at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertText(editor, text) {
    editor.insertText(text);
  },

  /**
   * Check if a value is a block `Element` object.
   */
  isBlock(editor, value) {
    return Element$2.isElement(value) && !editor.isInline(value);
  },

  /**
   * Check if a value is an `Editor` object.
   */
  isEditor(value) {
    if (!isPlainObject(value)) return false;
    var cachedIsEditor = IS_EDITOR_CACHE.get(value);

    if (cachedIsEditor !== undefined) {
      return cachedIsEditor;
    }

    var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range$2.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);
    IS_EDITOR_CACHE.set(value, isEditor);
    return isEditor;
  },

  /**
   * Check if a point is the end point of a location.
   */
  isEnd(editor, point, at) {
    var end = Editor.end(editor, at);
    return Point.equals(point, end);
  },

  /**
   * Check if a point is an edge of a location.
   */
  isEdge(editor, point, at) {
    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);
  },

  /**
   * Check if an element is empty, accounting for void nodes.
   */
  isEmpty(editor, element) {
    var {
      children
    } = element;
    var [first] = children;
    return children.length === 0 || children.length === 1 && Text$4.isText(first) && first.text === '' && !editor.isVoid(element);
  },

  /**
   * Check if a value is an inline `Element` object.
   */
  isInline(editor, value) {
    return Element$2.isElement(value) && editor.isInline(value);
  },

  /**
   * Check if the editor is currently normalizing after each operation.
   */
  isNormalizing(editor) {
    var isNormalizing = NORMALIZING.get(editor);
    return isNormalizing === undefined ? true : isNormalizing;
  },

  /**
   * Check if a point is the start point of a location.
   */
  isStart(editor, point, at) {
    // PERF: If the offset isn't `0` we know it's not the start.
    if (point.offset !== 0) {
      return false;
    }

    var start = Editor.start(editor, at);
    return Point.equals(point, start);
  },

  /**
   * Check if a value is a void `Element` object.
   */
  isVoid(editor, value) {
    return Element$2.isElement(value) && editor.isVoid(value);
  },

  /**
   * Get the last node at a location.
   */
  last(editor, at) {
    var path = Editor.path(editor, at, {
      edge: 'end'
    });
    return Editor.node(editor, path);
  },

  /**
   * Get the leaf text node at a location.
   */
  leaf(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var node = Node.leaf(editor, path);
    return [node, path];
  },

  /**
   * Iterate through all of the levels at a location.
   */
  *levels(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      at = editor.selection,
      reverse = false,
      voids = false
    } = options;
    var {
      match
    } = options;

    if (match == null) {
      match = () => true;
    }

    if (!at) {
      return;
    }

    var levels = [];
    var path = Editor.path(editor, at);

    for (var [n, p] of Node.levels(editor, path)) {
      if (!match(n, p)) {
        continue;
      }

      levels.push([n, p]);

      if (!voids && Editor.isVoid(editor, n)) {
        break;
      }
    }

    if (reverse) {
      levels.reverse();
    }

    yield* levels;
  },

  /**
   * Get the marks that would be added to text at the current selection.
   */
  marks(editor) {
    var {
      marks,
      selection
    } = editor;

    if (!selection) {
      return null;
    }

    if (marks) {
      return marks;
    }

    if (Range$2.isExpanded(selection)) {
      var [match] = Editor.nodes(editor, {
        match: Text$4.isText
      });

      if (match) {
        var [_node] = match;

        var _rest = _objectWithoutProperties$2(_node, ["text"]);

        return _rest;
      } else {
        return {};
      }
    }

    var {
      anchor
    } = selection;
    var {
      path
    } = anchor;
    var [node] = Editor.leaf(editor, path);

    if (anchor.offset === 0) {
      var prev = Editor.previous(editor, {
        at: path,
        match: Text$4.isText
      });
      var block = Editor.above(editor, {
        match: n => Editor.isBlock(editor, n)
      });

      if (prev && block) {
        var [prevNode, prevPath] = prev;
        var [, blockPath] = block;

        if (Path.isAncestor(blockPath, prevPath)) {
          node = prevNode;
        }
      }
    }

    var rest = _objectWithoutProperties$2(node, ["text"]);

    return rest;
  },

  /**
   * Get the matching node in the branch of the document after a location.
   */
  next(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      mode = 'lowest',
      voids = false
    } = options;
    var {
      match,
      at = editor.selection
    } = options;

    if (!at) {
      return;
    }

    var pointAfterLocation = Editor.after(editor, at, {
      voids
    });
    if (!pointAfterLocation) return;
    var [, to] = Editor.last(editor, []);
    var span = [pointAfterLocation.path, to];

    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the next node from the root node!");
    }

    if (match == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor.parent(editor, at);

        match = n => parent.children.includes(n);
      } else {
        match = () => true;
      }
    }

    var [next] = Editor.nodes(editor, {
      at: span,
      match,
      mode,
      voids
    });
    return next;
  },

  /**
   * Get the node at a location.
   */
  node(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var node = Node.get(editor, path);
    return [node, path];
  },

  /**
   * Iterate through all of the nodes in the Editor.
   */
  *nodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      at = editor.selection,
      mode = 'all',
      universal = false,
      reverse = false,
      voids = false
    } = options;
    var {
      match
    } = options;

    if (!match) {
      match = () => true;
    }

    if (!at) {
      return;
    }

    var from;
    var to;

    if (Span.isSpan(at)) {
      from = at[0];
      to = at[1];
    } else {
      var first = Editor.path(editor, at, {
        edge: 'start'
      });
      var last = Editor.path(editor, at, {
        edge: 'end'
      });
      from = reverse ? last : first;
      to = reverse ? first : last;
    }

    var nodeEntries = Node.nodes(editor, {
      reverse,
      from,
      to,
      pass: (_ref) => {
        var [n] = _ref;
        return voids ? false : Editor.isVoid(editor, n);
      }
    });
    var matches = [];
    var hit;

    for (var [node, path] of nodeEntries) {
      var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.

      if (mode === 'highest' && isLower) {
        continue;
      }

      if (!match(node, path)) {
        // If we've arrived at a leaf text node that is not lower than the last
        // hit, then we've found a branch that doesn't include a match, which
        // means the match is not universal.
        if (universal && !isLower && Text$4.isText(node)) {
          return;
        } else {
          continue;
        }
      } // If there's a match and it's lower than the last, update the hit.


      if (mode === 'lowest' && isLower) {
        hit = [node, path];
        continue;
      } // In lowest mode we emit the last hit, once it's guaranteed lowest.


      var emit = mode === 'lowest' ? hit : [node, path];

      if (emit) {
        if (universal) {
          matches.push(emit);
        } else {
          yield emit;
        }
      }

      hit = [node, path];
    } // Since lowest is always emitting one behind, catch up at the end.


    if (mode === 'lowest' && hit) {
      if (universal) {
        matches.push(hit);
      } else {
        yield hit;
      }
    } // Universal defers to ensure that the match occurs in every branch, so we
    // yield all of the matches after iterating.


    if (universal) {
      yield* matches;
    }
  },

  /**
   * Normalize any dirty objects in the editor.
   */
  normalize(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      force = false
    } = options;

    var getDirtyPaths = editor => {
      return DIRTY_PATHS.get(editor) || [];
    };

    if (!Editor.isNormalizing(editor)) {
      return;
    }

    if (force) {
      var allPaths = Array.from(Node.nodes(editor), (_ref2) => {
        var [, p] = _ref2;
        return p;
      });
      DIRTY_PATHS.set(editor, allPaths);
    }

    if (getDirtyPaths(editor).length === 0) {
      return;
    }

    Editor.withoutNormalizing(editor, () => {
      /*
        Fix dirty elements with no children.
        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.
        Running an initial pass avoids the catch-22 race condition.
      */
      for (var dirtyPath of getDirtyPaths(editor)) {
        if (Node.has(editor, dirtyPath)) {
          var [node, _] = Editor.node(editor, dirtyPath); // Add a text child to elements with no children.
          // This is safe to do in any order, by definition it can't cause other paths to change.

          if (Element$2.isElement(node) && node.children.length === 0) {
            var child = {
              text: ''
            };
            Transforms.insertNodes(editor, child, {
              at: dirtyPath.concat(0),
              voids: true
            });
          }
        }
      }

      var max = getDirtyPaths(editor).length * 42; // HACK: better way?

      var m = 0;

      while (getDirtyPaths(editor).length !== 0) {
        if (m > max) {
          throw new Error("\n            Could not completely normalize the editor after ".concat(max, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          "));
        }

        var _dirtyPath = getDirtyPaths(editor).pop(); // If the node doesn't exist in the tree, it does not need to be normalized.


        if (Node.has(editor, _dirtyPath)) {
          var entry = Editor.node(editor, _dirtyPath);
          editor.normalizeNode(entry);
        }

        m++;
      }
    });
  },

  /**
   * Get the parent node of a location.
   */
  parent(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var parentPath = Path.parent(path);
    var entry = Editor.node(editor, parentPath);
    return entry;
  },

  /**
   * Get the path of a location.
   */
  path(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      depth,
      edge
    } = options;

    if (Path.isPath(at)) {
      if (edge === 'start') {
        var [, firstPath] = Node.first(editor, at);
        at = firstPath;
      } else if (edge === 'end') {
        var [, lastPath] = Node.last(editor, at);
        at = lastPath;
      }
    }

    if (Range$2.isRange(at)) {
      if (edge === 'start') {
        at = Range$2.start(at);
      } else if (edge === 'end') {
        at = Range$2.end(at);
      } else {
        at = Path.common(at.anchor.path, at.focus.path);
      }
    }

    if (Point.isPoint(at)) {
      at = at.path;
    }

    if (depth != null) {
      at = at.slice(0, depth);
    }

    return at;
  },

  hasPath(editor, path) {
    return Node.has(editor, path);
  },

  /**
   * Create a mutable ref for a `Path` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pathRef(editor, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      affinity = 'forward'
    } = options;
    var ref = {
      current: path,
      affinity,

      unref() {
        var {
          current
        } = ref;
        var pathRefs = Editor.pathRefs(editor);
        pathRefs.delete(ref);
        ref.current = null;
        return current;
      }

    };
    var refs = Editor.pathRefs(editor);
    refs.add(ref);
    return ref;
  },

  /**
   * Get the set of currently tracked path refs of the editor.
   */
  pathRefs(editor) {
    var refs = PATH_REFS.get(editor);

    if (!refs) {
      refs = new Set();
      PATH_REFS.set(editor, refs);
    }

    return refs;
  },

  /**
   * Get the start or end point of a location.
   */
  point(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      edge = 'start'
    } = options;

    if (Path.isPath(at)) {
      var path;

      if (edge === 'end') {
        var [, lastPath] = Node.last(editor, at);
        path = lastPath;
      } else {
        var [, firstPath] = Node.first(editor, at);
        path = firstPath;
      }

      var node = Node.get(editor, path);

      if (!Text$4.isText(node)) {
        throw new Error("Cannot get the ".concat(edge, " point in the node at path [").concat(at, "] because it has no ").concat(edge, " text node."));
      }

      return {
        path,
        offset: edge === 'end' ? node.text.length : 0
      };
    }

    if (Range$2.isRange(at)) {
      var [start, end] = Range$2.edges(at);
      return edge === 'start' ? start : end;
    }

    return at;
  },

  /**
   * Create a mutable ref for a `Point` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pointRef(editor, point) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      affinity = 'forward'
    } = options;
    var ref = {
      current: point,
      affinity,

      unref() {
        var {
          current
        } = ref;
        var pointRefs = Editor.pointRefs(editor);
        pointRefs.delete(ref);
        ref.current = null;
        return current;
      }

    };
    var refs = Editor.pointRefs(editor);
    refs.add(ref);
    return ref;
  },

  /**
   * Get the set of currently tracked point refs of the editor.
   */
  pointRefs(editor) {
    var refs = POINT_REFS.get(editor);

    if (!refs) {
      refs = new Set();
      POINT_REFS.set(editor, refs);
    }

    return refs;
  },

  /**
   * Return all the positions in `at` range where a `Point` can be placed.
   *
   * By default, moves forward by individual offsets at a time, but
   * the `unit` option can be used to to move by character, word, line, or block.
   *
   * The `reverse` option can be used to change iteration direction.
   *
   * Note: By default void nodes are treated as a single point and iteration
   * will not happen inside their content unless you pass in true for the
   * `voids` option, then iteration will occur.
   */
  *positions(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      at = editor.selection,
      unit = 'offset',
      reverse: reverse$1 = false,
      voids = false
    } = options;

    if (!at) {
      return;
    }
    /**
     * Algorithm notes:
     *
     * Each step `distance` is dynamic depending on the underlying text
     * and the `unit` specified.  Each step, e.g., a line or word, may
     * span multiple text nodes, so we iterate through the text both on
     * two levels in step-sync:
     *
     * `leafText` stores the text on a text leaf level, and is advanced
     * through using the counters `leafTextOffset` and `leafTextRemaining`.
     *
     * `blockText` stores the text on a block level, and is shortened
     * by `distance` every time it is advanced.
     *
     * We only maintain a window of one blockText and one leafText because
     * a block node always appears before all of its leaf nodes.
     */


    var range = Editor.range(editor, at);
    var [start, end] = Range$2.edges(range);
    var first = reverse$1 ? end : start;
    var isNewBlock = false;
    var blockText = '';
    var distance = 0; // Distance for leafText to catch up to blockText.

    var leafTextRemaining = 0;
    var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content
    // of block nodes in blockText, and text nodes in leafText.
    // Exploits the fact that nodes are sequenced in such a way that we first
    // encounter the block node, then all of its text nodes, so when iterating
    // through the blockText and leafText we just need to remember a window of
    // one block node and leaf node, respectively.

    for (var [node, path] of Editor.nodes(editor, {
      at,
      reverse: reverse$1,
      voids
    })) {
      /*
       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks
       */
      if (Element$2.isElement(node)) {
        // Void nodes are a special case, so by default we will always
        // yield their first point. If the `voids` option is set to true,
        // then we will iterate over their content.
        if (!voids && editor.isVoid(node)) {
          yield Editor.start(editor, path);
          continue;
        } // Inline element nodes are ignored as they don't themselves
        // contribute to `blockText` or `leafText` - their parent and
        // children do.


        if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.

        if (Editor.hasInlines(editor, node)) {
          // We always exhaust block nodes before encountering a new one:
          //   console.assert(blockText === '',
          //     `blockText='${blockText}' - `+
          //     `not exhausted before new block node`, path)
          // Ensure range considered is capped to `range`, in the
          // start/end edge cases where block extends beyond range.
          // Equivalent to this, but presumably more performant:
          //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))
          //   blockRange = Range.intersection(range, blockRange) // intersect
          //   blockText = Editor.string(editor, blockRange, { voids })
          var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);
          var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);
          blockText = Editor.string(editor, {
            anchor: s,
            focus: e
          }, {
            voids
          });
          blockText = reverse$1 ? esrever.exports.reverse(blockText) : blockText;
          isNewBlock = true;
        }
      }
      /*
       * TEXT LEAF NODE - Iterate through text content, yielding
       * positions every `distance` offset according to `unit`.
       */


      if (Text$4.isText(node)) {
        var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:
        //   console.assert(leafTextRemaining <= 0,
        //     `leafTextRemaining=${leafTextRemaining} - `+
        //     `not exhausted before new leaf text node`, path)
        // Reset `leafText` counters for new text node.

        if (isFirst) {
          leafTextRemaining = reverse$1 ? first.offset : node.text.length - first.offset;
          leafTextOffset = first.offset; // Works for reverse too.
        } else {
          leafTextRemaining = node.text.length;
          leafTextOffset = reverse$1 ? leafTextRemaining : 0;
        } // Yield position at the start of node (potentially).


        if (isFirst || isNewBlock || unit === 'offset') {
          yield {
            path,
            offset: leafTextOffset
          };
          isNewBlock = false;
        } // Yield positions every (dynamically calculated) `distance` offset.


        while (true) {
          // If `leafText` has caught up with `blockText` (distance=0),
          // and if blockText is exhausted, break to get another block node,
          // otherwise advance blockText forward by the new `distance`.
          if (distance === 0) {
            if (blockText === '') break;
            distance = calcDistance(blockText, unit);
            blockText = blockText.slice(distance);
          } // Advance `leafText` by the current `distance`.


          leafTextOffset = reverse$1 ? leafTextOffset - distance : leafTextOffset + distance;
          leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node
          // and set distance to the overflow amount, so we'll (maybe)
          // catch up to blockText in the next leaf text node.

          if (leafTextRemaining < 0) {
            distance = -leafTextRemaining;
            break;
          } // Successfully walked `distance` offsets through `leafText`
          // to catch up with `blockText`, so we can reset `distance`
          // and yield this position in this node.


          distance = 0;
          yield {
            path,
            offset: leafTextOffset
          };
        }
      }
    } // Proof that upon completion, we've exahusted both leaf and block text:
    //   console.assert(leafTextRemaining <= 0, "leafText wasn't exhausted")
    //   console.assert(blockText === '', "blockText wasn't exhausted")
    // Helper:
    // Return the distance in offsets for a step of size `unit` on given string.


    function calcDistance(text, unit) {
      if (unit === 'character') {
        return getCharacterDistance(text);
      } else if (unit === 'word') {
        return getWordDistance(text);
      } else if (unit === 'line' || unit === 'block') {
        return text.length;
      }

      return 1;
    }
  },

  /**
   * Get the matching node in the branch of the document before a location.
   */
  previous(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      mode = 'lowest',
      voids = false
    } = options;
    var {
      match,
      at = editor.selection
    } = options;

    if (!at) {
      return;
    }

    var pointBeforeLocation = Editor.before(editor, at, {
      voids
    });

    if (!pointBeforeLocation) {
      return;
    }

    var [, to] = Editor.first(editor, []); // The search location is from the start of the document to the path of
    // the point before the location passed in

    var span = [pointBeforeLocation.path, to];

    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the previous node from the root node!");
    }

    if (match == null) {
      if (Path.isPath(at)) {
        var [parent] = Editor.parent(editor, at);

        match = n => parent.children.includes(n);
      } else {
        match = () => true;
      }
    }

    var [previous] = Editor.nodes(editor, {
      reverse: true,
      at: span,
      match,
      mode,
      voids
    });
    return previous;
  },

  /**
   * Get a range of a location.
   */
  range(editor, at, to) {
    if (Range$2.isRange(at) && !to) {
      return at;
    }

    var start = Editor.start(editor, at);
    var end = Editor.end(editor, to || at);
    return {
      anchor: start,
      focus: end
    };
  },

  /**
   * Create a mutable ref for a `Range` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  rangeRef(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      affinity = 'forward'
    } = options;
    var ref = {
      current: range,
      affinity,

      unref() {
        var {
          current
        } = ref;
        var rangeRefs = Editor.rangeRefs(editor);
        rangeRefs.delete(ref);
        ref.current = null;
        return current;
      }

    };
    var refs = Editor.rangeRefs(editor);
    refs.add(ref);
    return ref;
  },

  /**
   * Get the set of currently tracked range refs of the editor.
   */
  rangeRefs(editor) {
    var refs = RANGE_REFS.get(editor);

    if (!refs) {
      refs = new Set();
      RANGE_REFS.set(editor, refs);
    }

    return refs;
  },

  /**
   * Remove a custom property from all of the leaf text nodes in the current
   * selection.
   *
   * If the selection is currently collapsed, the removal will be stored on
   * `editor.marks` and applied to the text inserted next.
   */
  removeMark(editor, key) {
    editor.removeMark(key);
  },

  /**
   * Get the start point of a location.
   */
  start(editor, at) {
    return Editor.point(editor, at, {
      edge: 'start'
    });
  },

  /**
   * Get the text string content of a location.
   *
   * Note: by default the text of void nodes is considered to be an empty
   * string, regardless of content, unless you pass in true for the voids option
   */
  string(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var range = Editor.range(editor, at);
    var [start, end] = Range$2.edges(range);
    var text = '';

    for (var [node, path] of Editor.nodes(editor, {
      at: range,
      match: Text$4.isText,
      voids
    })) {
      var t = node.text;

      if (Path.equals(path, end.path)) {
        t = t.slice(0, end.offset);
      }

      if (Path.equals(path, start.path)) {
        t = t.slice(start.offset);
      }

      text += t;
    }

    return text;
  },

  /**
   * Convert a range into a non-hanging one.
   */
  unhangRange(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var [start, end] = Range$2.edges(range); // PERF: exit early if we can guarantee that the range isn't hanging.

    if (start.offset !== 0 || end.offset !== 0 || Range$2.isCollapsed(range)) {
      return range;
    }

    var endBlock = Editor.above(editor, {
      at: end,
      match: n => Editor.isBlock(editor, n)
    });
    var blockPath = endBlock ? endBlock[1] : [];
    var first = Editor.start(editor, []);
    var before = {
      anchor: first,
      focus: end
    };
    var skip = true;

    for (var [node, path] of Editor.nodes(editor, {
      at: before,
      match: Text$4.isText,
      reverse: true,
      voids
    })) {
      if (skip) {
        skip = false;
        continue;
      }

      if (node.text !== '' || Path.isBefore(path, blockPath)) {
        end = {
          path,
          offset: node.text.length
        };
        break;
      }
    }

    return {
      anchor: start,
      focus: end
    };
  },

  /**
   * Match a void node in the current branch of the editor.
   */
  void(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return Editor.above(editor, _objectSpread$1(_objectSpread$1({}, options), {}, {
      match: n => Editor.isVoid(editor, n)
    }));
  },

  /**
   * Call a function, deferring normalization until after it completes.
   */
  withoutNormalizing(editor, fn) {
    var value = Editor.isNormalizing(editor);
    NORMALIZING.set(editor, false);

    try {
      fn();
    } finally {
      NORMALIZING.set(editor, value);
    }

    Editor.normalize(editor);
  }

};
var Span = {
  /**
   * Check if a value implements the `Span` interface.
   */
  isSpan(value) {
    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);
  }

};

var IS_NODE_LIST_CACHE = new WeakMap();
var Node = {
  /**
   * Get the node at a specific path, asserting that it's an ancestor node.
   */
  ancestor(root, path) {
    var node = Node.get(root, path);

    if (Text$4.isText(node)) {
      throw new Error("Cannot get the ancestor node at path [".concat(path, "] because it refers to a text node instead: ").concat(node));
    }

    return node;
  },

  /**
   * Return a generator of all the ancestor nodes above a specific path.
   *
   * By default the order is bottom-up, from lowest to highest ancestor in
   * the tree, but you can pass the `reverse: true` option to go top-down.
   */
  *ancestors(root, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    for (var p of Path.ancestors(path, options)) {
      var n = Node.ancestor(root, p);
      var entry = [n, p];
      yield entry;
    }
  },

  /**
   * Get the child of a node at a specific index.
   */
  child(root, index) {
    if (Text$4.isText(root)) {
      throw new Error("Cannot get the child of a text node: ".concat(JSON.stringify(root)));
    }

    var c = root.children[index];

    if (c == null) {
      throw new Error("Cannot get child at index `".concat(index, "` in node: ").concat(JSON.stringify(root)));
    }

    return c;
  },

  /**
   * Iterate over the children of a node at a specific path.
   */
  *children(root, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      reverse = false
    } = options;
    var ancestor = Node.ancestor(root, path);
    var {
      children
    } = ancestor;
    var index = reverse ? children.length - 1 : 0;

    while (reverse ? index >= 0 : index < children.length) {
      var child = Node.child(ancestor, index);
      var childPath = path.concat(index);
      yield [child, childPath];
      index = reverse ? index - 1 : index + 1;
    }
  },

  /**
   * Get an entry for the common ancesetor node of two paths.
   */
  common(root, path, another) {
    var p = Path.common(path, another);
    var n = Node.get(root, p);
    return [n, p];
  },

  /**
   * Get the node at a specific path, asserting that it's a descendant node.
   */
  descendant(root, path) {
    var node = Node.get(root, path);

    if (Editor.isEditor(node)) {
      throw new Error("Cannot get the descendant node at path [".concat(path, "] because it refers to the root editor node instead: ").concat(node));
    }

    return node;
  },

  /**
   * Return a generator of all the descendant node entries inside a root node.
   */
  *descendants(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    for (var [node, path] of Node.nodes(root, options)) {
      if (path.length !== 0) {
        // NOTE: we have to coerce here because checking the path's length does
        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.
        yield [node, path];
      }
    }
  },

  /**
   * Return a generator of all the element nodes inside a root node. Each iteration
   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the
   * root node is an element it will be included in the iteration as well.
   */
  *elements(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    for (var [node, path] of Node.nodes(root, options)) {
      if (Element$2.isElement(node)) {
        yield [node, path];
      }
    }
  },

  /**
   * Extract props from a Node.
   */
  extractProps(node) {
    if (Element$2.isAncestor(node)) {
      var properties = _objectWithoutProperties$2(node, ["children"]);

      return properties;
    } else {
      var properties = _objectWithoutProperties$2(node, ["text"]);

      return properties;
    }
  },

  /**
   * Get the first node entry in a root node from a path.
   */
  first(root, path) {
    var p = path.slice();
    var n = Node.get(root, p);

    while (n) {
      if (Text$4.isText(n) || n.children.length === 0) {
        break;
      } else {
        n = n.children[0];
        p.push(0);
      }
    }

    return [n, p];
  },

  /**
   * Get the sliced fragment represented by a range inside a root node.
   */
  fragment(root, range) {
    if (Text$4.isText(root)) {
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(JSON.stringify(root)));
    }

    var newRoot = fn$1({
      children: root.children
    }, r => {
      var [start, end] = Range$2.edges(range);
      var nodeEntries = Node.nodes(r, {
        reverse: true,
        pass: (_ref) => {
          var [, path] = _ref;
          return !Range$2.includes(range, path);
        }
      });

      for (var [, path] of nodeEntries) {
        if (!Range$2.includes(range, path)) {
          var parent = Node.parent(r, path);
          var index = path[path.length - 1];
          parent.children.splice(index, 1);
        }

        if (Path.equals(path, end.path)) {
          var leaf = Node.leaf(r, path);
          leaf.text = leaf.text.slice(0, end.offset);
        }

        if (Path.equals(path, start.path)) {
          var _leaf = Node.leaf(r, path);

          _leaf.text = _leaf.text.slice(start.offset);
        }
      }

      if (Editor.isEditor(r)) {
        r.selection = null;
      }
    });
    return newRoot.children;
  },

  /**
   * Get the descendant node referred to by a specific path. If the path is an
   * empty array, it refers to the root node itself.
   */
  get(root, path) {
    var node = root;

    for (var i = 0; i < path.length; i++) {
      var p = path[i];

      if (Text$4.isText(node) || !node.children[p]) {
        throw new Error("Cannot find a descendant at path [".concat(path, "] in node: ").concat(JSON.stringify(root)));
      }

      node = node.children[p];
    }

    return node;
  },

  /**
   * Check if a descendant node exists at a specific path.
   */
  has(root, path) {
    var node = root;

    for (var i = 0; i < path.length; i++) {
      var p = path[i];

      if (Text$4.isText(node) || !node.children[p]) {
        return false;
      }

      node = node.children[p];
    }

    return true;
  },

  /**
   * Check if a value implements the `Node` interface.
   */
  isNode(value) {
    return Text$4.isText(value) || Element$2.isElement(value) || Editor.isEditor(value);
  },

  /**
   * Check if a value is a list of `Node` objects.
   */
  isNodeList(value) {
    if (!Array.isArray(value)) {
      return false;
    }

    var cachedResult = IS_NODE_LIST_CACHE.get(value);

    if (cachedResult !== undefined) {
      return cachedResult;
    }

    var isNodeList = value.every(val => Node.isNode(val));
    IS_NODE_LIST_CACHE.set(value, isNodeList);
    return isNodeList;
  },

  /**
   * Get the last node entry in a root node from a path.
   */
  last(root, path) {
    var p = path.slice();
    var n = Node.get(root, p);

    while (n) {
      if (Text$4.isText(n) || n.children.length === 0) {
        break;
      } else {
        var i = n.children.length - 1;
        n = n.children[i];
        p.push(i);
      }
    }

    return [n, p];
  },

  /**
   * Get the node at a specific path, ensuring it's a leaf text node.
   */
  leaf(root, path) {
    var node = Node.get(root, path);

    if (!Text$4.isText(node)) {
      throw new Error("Cannot get the leaf node at path [".concat(path, "] because it refers to a non-leaf node: ").concat(node));
    }

    return node;
  },

  /**
   * Return a generator of the in a branch of the tree, from a specific path.
   *
   * By default the order is top-down, from lowest to highest node in the tree,
   * but you can pass the `reverse: true` option to go bottom-up.
   */
  *levels(root, path) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    for (var p of Path.levels(path, options)) {
      var n = Node.get(root, p);
      yield [n, p];
    }
  },

  /**
   * Check if a node matches a set of props.
   */
  matches(node, props) {
    return Element$2.isElement(node) && Element$2.isElementProps(props) && Element$2.matches(node, props) || Text$4.isText(node) && Text$4.isTextProps(props) && Text$4.matches(node, props);
  },

  /**
   * Return a generator of all the node entries of a root node. Each entry is
   * returned as a `[Node, Path]` tuple, with the path referring to the node's
   * position inside the root node.
   */
  *nodes(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      pass,
      reverse = false
    } = options;
    var {
      from = [],
      to
    } = options;
    var visited = new Set();
    var p = [];
    var n = root;

    while (true) {
      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {
        break;
      }

      if (!visited.has(n)) {
        yield [n, p];
      } // If we're allowed to go downward and we haven't descended yet, do.


      if (!visited.has(n) && !Text$4.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {
        visited.add(n);
        var nextIndex = reverse ? n.children.length - 1 : 0;

        if (Path.isAncestor(p, from)) {
          nextIndex = from[p.length];
        }

        p = p.concat(nextIndex);
        n = Node.get(root, p);
        continue;
      } // If we're at the root and we can't go down, we're done.


      if (p.length === 0) {
        break;
      } // If we're going forward...


      if (!reverse) {
        var newPath = Path.next(p);

        if (Node.has(root, newPath)) {
          p = newPath;
          n = Node.get(root, p);
          continue;
        }
      } // If we're going backward...


      if (reverse && p[p.length - 1] !== 0) {
        var _newPath = Path.previous(p);

        p = _newPath;
        n = Node.get(root, p);
        continue;
      } // Otherwise we're going upward...


      p = Path.parent(p);
      n = Node.get(root, p);
      visited.add(n);
    }
  },

  /**
   * Get the parent of a node at a specific path.
   */
  parent(root, path) {
    var parentPath = Path.parent(path);
    var p = Node.get(root, parentPath);

    if (Text$4.isText(p)) {
      throw new Error("Cannot get the parent of path [".concat(path, "] because it does not exist in the root."));
    }

    return p;
  },

  /**
   * Get the concatenated text string of a node's content.
   *
   * Note that this will not include spaces or line breaks between block nodes.
   * It is not a user-facing string, but a string for performing offset-related
   * computations for a node.
   */
  string(node) {
    if (Text$4.isText(node)) {
      return node.text;
    } else {
      return node.children.map(Node.string).join('');
    }
  },

  /**
   * Return a generator of all leaf text nodes in a root node.
   */
  *texts(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    for (var [node, path] of Node.nodes(root, options)) {
      if (Text$4.isText(node)) {
        yield [node, path];
      }
    }
  }

};

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Operation = {
  /**
   * Check of a value is a `NodeOperation` object.
   */
  isNodeOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith('_node');
  },

  /**
   * Check of a value is an `Operation` object.
   */
  isOperation(value) {
    if (!isPlainObject(value)) {
      return false;
    }

    switch (value.type) {
      case 'insert_node':
        return Path.isPath(value.path) && Node.isNode(value.node);

      case 'insert_text':
        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);

      case 'merge_node':
        return typeof value.position === 'number' && Path.isPath(value.path) && isPlainObject(value.properties);

      case 'move_node':
        return Path.isPath(value.path) && Path.isPath(value.newPath);

      case 'remove_node':
        return Path.isPath(value.path) && Node.isNode(value.node);

      case 'remove_text':
        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);

      case 'set_node':
        return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);

      case 'set_selection':
        return value.properties === null && Range$2.isRange(value.newProperties) || value.newProperties === null && Range$2.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);

      case 'split_node':
        return Path.isPath(value.path) && typeof value.position === 'number' && isPlainObject(value.properties);

      default:
        return false;
    }
  },

  /**
   * Check if a value is a list of `Operation` objects.
   */
  isOperationList(value) {
    return Array.isArray(value) && value.every(val => Operation.isOperation(val));
  },

  /**
   * Check of a value is a `SelectionOperation` object.
   */
  isSelectionOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith('_selection');
  },

  /**
   * Check of a value is a `TextOperation` object.
   */
  isTextOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith('_text');
  },

  /**
   * Invert an operation, returning a new operation that will exactly undo the
   * original when applied.
   */
  inverse(op) {
    switch (op.type) {
      case 'insert_node':
        {
          return _objectSpread$2(_objectSpread$2({}, op), {}, {
            type: 'remove_node'
          });
        }

      case 'insert_text':
        {
          return _objectSpread$2(_objectSpread$2({}, op), {}, {
            type: 'remove_text'
          });
        }

      case 'merge_node':
        {
          return _objectSpread$2(_objectSpread$2({}, op), {}, {
            type: 'split_node',
            path: Path.previous(op.path)
          });
        }

      case 'move_node':
        {
          var {
            newPath,
            path
          } = op; // PERF: in this case the move operation is a no-op anyways.

          if (Path.equals(newPath, path)) {
            return op;
          } // If the move happens completely within a single parent the path and
          // newPath are stable with respect to each other.


          if (Path.isSibling(path, newPath)) {
            return _objectSpread$2(_objectSpread$2({}, op), {}, {
              path: newPath,
              newPath: path
            });
          } // If the move does not happen within a single parent it is possible
          // for the move to impact the true path to the location where the node
          // was removed from and where it was inserted. We have to adjust for this
          // and find the original path. We can accomplish this (only in non-sibling)
          // moves by looking at the impact of the move operation on the node
          // after the original move path.


          var inversePath = Path.transform(path, op);
          var inverseNewPath = Path.transform(Path.next(path), op);
          return _objectSpread$2(_objectSpread$2({}, op), {}, {
            path: inversePath,
            newPath: inverseNewPath
          });
        }

      case 'remove_node':
        {
          return _objectSpread$2(_objectSpread$2({}, op), {}, {
            type: 'insert_node'
          });
        }

      case 'remove_text':
        {
          return _objectSpread$2(_objectSpread$2({}, op), {}, {
            type: 'insert_text'
          });
        }

      case 'set_node':
        {
          var {
            properties,
            newProperties
          } = op;
          return _objectSpread$2(_objectSpread$2({}, op), {}, {
            properties: newProperties,
            newProperties: properties
          });
        }

      case 'set_selection':
        {
          var {
            properties: _properties,
            newProperties: _newProperties
          } = op;

          if (_properties == null) {
            return _objectSpread$2(_objectSpread$2({}, op), {}, {
              properties: _newProperties,
              newProperties: null
            });
          } else if (_newProperties == null) {
            return _objectSpread$2(_objectSpread$2({}, op), {}, {
              properties: null,
              newProperties: _properties
            });
          } else {
            return _objectSpread$2(_objectSpread$2({}, op), {}, {
              properties: _newProperties,
              newProperties: _properties
            });
          }
        }

      case 'split_node':
        {
          return _objectSpread$2(_objectSpread$2({}, op), {}, {
            type: 'merge_node',
            path: Path.next(op.path)
          });
        }
    }
  }

};

var Path = {
  /**
   * Get a list of ancestor paths for a given path.
   *
   * The paths are sorted from deepest to shallowest ancestor. However, if the
   * `reverse: true` option is passed, they are reversed.
   */
  ancestors(path) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var paths = Path.levels(path, options);

    if (reverse) {
      paths = paths.slice(1);
    } else {
      paths = paths.slice(0, -1);
    }

    return paths;
  },

  /**
   * Get the common ancestor path of two paths.
   */
  common(path, another) {
    var common = [];

    for (var i = 0; i < path.length && i < another.length; i++) {
      var av = path[i];
      var bv = another[i];

      if (av !== bv) {
        break;
      }

      common.push(av);
    }

    return common;
  },

  /**
   * Compare a path to another, returning an integer indicating whether the path
   * was before, at, or after the other.
   *
   * Note: Two paths of unequal length can still receive a `0` result if one is
   * directly above or below the other. If you want exact matching, use
   * [[Path.equals]] instead.
   */
  compare(path, another) {
    var min = Math.min(path.length, another.length);

    for (var i = 0; i < min; i++) {
      if (path[i] < another[i]) return -1;
      if (path[i] > another[i]) return 1;
    }

    return 0;
  },

  /**
   * Check if a path ends after one of the indexes in another.
   */
  endsAfter(path, another) {
    var i = path.length - 1;
    var as = path.slice(0, i);
    var bs = another.slice(0, i);
    var av = path[i];
    var bv = another[i];
    return Path.equals(as, bs) && av > bv;
  },

  /**
   * Check if a path ends at one of the indexes in another.
   */
  endsAt(path, another) {
    var i = path.length;
    var as = path.slice(0, i);
    var bs = another.slice(0, i);
    return Path.equals(as, bs);
  },

  /**
   * Check if a path ends before one of the indexes in another.
   */
  endsBefore(path, another) {
    var i = path.length - 1;
    var as = path.slice(0, i);
    var bs = another.slice(0, i);
    var av = path[i];
    var bv = another[i];
    return Path.equals(as, bs) && av < bv;
  },

  /**
   * Check if a path is exactly equal to another.
   */
  equals(path, another) {
    return path.length === another.length && path.every((n, i) => n === another[i]);
  },

  /**
   * Check if the path of previous sibling node exists
   */
  hasPrevious(path) {
    return path[path.length - 1] > 0;
  },

  /**
   * Check if a path is after another.
   */
  isAfter(path, another) {
    return Path.compare(path, another) === 1;
  },

  /**
   * Check if a path is an ancestor of another.
   */
  isAncestor(path, another) {
    return path.length < another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is before another.
   */
  isBefore(path, another) {
    return Path.compare(path, another) === -1;
  },

  /**
   * Check if a path is a child of another.
   */
  isChild(path, another) {
    return path.length === another.length + 1 && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is equal to or an ancestor of another.
   */
  isCommon(path, another) {
    return path.length <= another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is a descendant of another.
   */
  isDescendant(path, another) {
    return path.length > another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check if a path is the parent of another.
   */
  isParent(path, another) {
    return path.length + 1 === another.length && Path.compare(path, another) === 0;
  },

  /**
   * Check is a value implements the `Path` interface.
   */
  isPath(value) {
    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');
  },

  /**
   * Check if a path is a sibling of another.
   */
  isSibling(path, another) {
    if (path.length !== another.length) {
      return false;
    }

    var as = path.slice(0, -1);
    var bs = another.slice(0, -1);
    var al = path[path.length - 1];
    var bl = another[another.length - 1];
    return al !== bl && Path.equals(as, bs);
  },

  /**
   * Get a list of paths at every level down to a path. Note: this is the same
   * as `Path.ancestors`, but including the path itself.
   *
   * The paths are sorted from shallowest to deepest. However, if the `reverse:
   * true` option is passed, they are reversed.
   */
  levels(path) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var list = [];

    for (var i = 0; i <= path.length; i++) {
      list.push(path.slice(0, i));
    }

    if (reverse) {
      list.reverse();
    }

    return list;
  },

  /**
   * Given a path, get the path to the next sibling node.
   */
  next(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the next path of a root path [".concat(path, "], because it has no next index."));
    }

    var last = path[path.length - 1];
    return path.slice(0, -1).concat(last + 1);
  },

  /**
   * Given a path, return a new path referring to the parent node above it.
   */
  parent(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the parent path of the root path [".concat(path, "]."));
    }

    return path.slice(0, -1);
  },

  /**
   * Given a path, get the path to the previous sibling node.
   */
  previous(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the previous path of a root path [".concat(path, "], because it has no previous index."));
    }

    var last = path[path.length - 1];

    if (last <= 0) {
      throw new Error("Cannot get the previous path of a first child path [".concat(path, "] because it would result in a negative index."));
    }

    return path.slice(0, -1).concat(last - 1);
  },

  /**
   * Get a path relative to an ancestor.
   */
  relative(path, ancestor) {
    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {
      throw new Error("Cannot get the relative path of [".concat(path, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
    }

    return path.slice(ancestor.length);
  },

  /**
   * Transform a path by an operation.
   */
  transform(path, operation) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return fn$1(path, p => {
      var {
        affinity = 'forward'
      } = options; // PERF: Exit early if the operation is guaranteed not to have an effect.

      if (path.length === 0) {
        return;
      }

      switch (operation.type) {
        case 'insert_node':
          {
            var {
              path: op
            } = operation;

            if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {
              p[op.length - 1] += 1;
            }

            break;
          }

        case 'remove_node':
          {
            var {
              path: _op
            } = operation;

            if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {
              return null;
            } else if (Path.endsBefore(_op, p)) {
              p[_op.length - 1] -= 1;
            }

            break;
          }

        case 'merge_node':
          {
            var {
              path: _op2,
              position
            } = operation;

            if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {
              p[_op2.length - 1] -= 1;
            } else if (Path.isAncestor(_op2, p)) {
              p[_op2.length - 1] -= 1;
              p[_op2.length] += position;
            }

            break;
          }

        case 'split_node':
          {
            var {
              path: _op3,
              position: _position
            } = operation;

            if (Path.equals(_op3, p)) {
              if (affinity === 'forward') {
                p[p.length - 1] += 1;
              } else if (affinity === 'backward') ; else {
                return null;
              }
            } else if (Path.endsBefore(_op3, p)) {
              p[_op3.length - 1] += 1;
            } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {
              p[_op3.length - 1] += 1;
              p[_op3.length] -= _position;
            }

            break;
          }

        case 'move_node':
          {
            var {
              path: _op4,
              newPath: onp
            } = operation; // If the old and new path are the same, it's a no-op.

            if (Path.equals(_op4, onp)) {
              return;
            }

            if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {
              var copy = onp.slice();

              if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
                copy[_op4.length - 1] -= 1;
              }

              return copy.concat(p.slice(_op4.length));
            } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {
              if (Path.endsBefore(_op4, p)) {
                p[_op4.length - 1] -= 1;
              } else {
                p[_op4.length - 1] += 1;
              }
            } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {
              if (Path.endsBefore(_op4, p)) {
                p[_op4.length - 1] -= 1;
              }

              p[onp.length - 1] += 1;
            } else if (Path.endsBefore(_op4, p)) {
              if (Path.equals(onp, p)) {
                p[onp.length - 1] += 1;
              }

              p[_op4.length - 1] -= 1;
            }

            break;
          }
      }
    });
  }

};

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Point = {
  /**
   * Compare a point to another, returning an integer indicating whether the
   * point was before, at, or after the other.
   */
  compare(point, another) {
    var result = Path.compare(point.path, another.path);

    if (result === 0) {
      if (point.offset < another.offset) return -1;
      if (point.offset > another.offset) return 1;
      return 0;
    }

    return result;
  },

  /**
   * Check if a point is after another.
   */
  isAfter(point, another) {
    return Point.compare(point, another) === 1;
  },

  /**
   * Check if a point is before another.
   */
  isBefore(point, another) {
    return Point.compare(point, another) === -1;
  },

  /**
   * Check if a point is exactly equal to another.
   */
  equals(point, another) {
    // PERF: ensure the offsets are equal first since they are cheaper to check.
    return point.offset === another.offset && Path.equals(point.path, another.path);
  },

  /**
   * Check if a value implements the `Point` interface.
   */
  isPoint(value) {
    return isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);
  },

  /**
   * Transform a point by an operation.
   */
  transform(point, op) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return fn$1(point, p => {
      var {
        affinity = 'forward'
      } = options;
      var {
        path,
        offset
      } = p;

      switch (op.type) {
        case 'insert_node':
        case 'move_node':
          {
            p.path = Path.transform(path, op, options);
            break;
          }

        case 'insert_text':
          {
            if (Path.equals(op.path, path) && op.offset <= offset) {
              p.offset += op.text.length;
            }

            break;
          }

        case 'merge_node':
          {
            if (Path.equals(op.path, path)) {
              p.offset += op.position;
            }

            p.path = Path.transform(path, op, options);
            break;
          }

        case 'remove_text':
          {
            if (Path.equals(op.path, path) && op.offset <= offset) {
              p.offset -= Math.min(offset - op.offset, op.text.length);
            }

            break;
          }

        case 'remove_node':
          {
            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {
              return null;
            }

            p.path = Path.transform(path, op, options);
            break;
          }

        case 'split_node':
          {
            if (Path.equals(op.path, path)) {
              if (op.position === offset && affinity == null) {
                return null;
              } else if (op.position < offset || op.position === offset && affinity === 'forward') {
                p.offset -= op.position;
                p.path = Path.transform(path, op, _objectSpread$3(_objectSpread$3({}, options), {}, {
                  affinity: 'forward'
                }));
              }
            } else {
              p.path = Path.transform(path, op, options);
            }

            break;
          }
      }
    });
  }

};

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Range$2 = {
  /**
   * Get the start and end points of a range, in the order in which they appear
   * in the document.
   */
  edges(range) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var {
      anchor,
      focus
    } = range;
    return Range$2.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];
  },

  /**
   * Get the end point of a range.
   */
  end(range) {
    var [, end] = Range$2.edges(range);
    return end;
  },

  /**
   * Check if a range is exactly equal to another.
   */
  equals(range, another) {
    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);
  },

  /**
   * Check if a range includes a path, a point or part of another range.
   */
  includes(range, target) {
    if (Range$2.isRange(target)) {
      if (Range$2.includes(range, target.anchor) || Range$2.includes(range, target.focus)) {
        return true;
      }

      var [rs, re] = Range$2.edges(range);
      var [ts, te] = Range$2.edges(target);
      return Point.isBefore(rs, ts) && Point.isAfter(re, te);
    }

    var [start, end] = Range$2.edges(range);
    var isAfterStart = false;
    var isBeforeEnd = false;

    if (Point.isPoint(target)) {
      isAfterStart = Point.compare(target, start) >= 0;
      isBeforeEnd = Point.compare(target, end) <= 0;
    } else {
      isAfterStart = Path.compare(target, start.path) >= 0;
      isBeforeEnd = Path.compare(target, end.path) <= 0;
    }

    return isAfterStart && isBeforeEnd;
  },

  /**
   * Get the intersection of a range with another.
   */
  intersection(range, another) {
    var rest = _objectWithoutProperties$2(range, ["anchor", "focus"]);

    var [s1, e1] = Range$2.edges(range);
    var [s2, e2] = Range$2.edges(another);
    var start = Point.isBefore(s1, s2) ? s2 : s1;
    var end = Point.isBefore(e1, e2) ? e1 : e2;

    if (Point.isBefore(end, start)) {
      return null;
    } else {
      return _objectSpread$4({
        anchor: start,
        focus: end
      }, rest);
    }
  },

  /**
   * Check if a range is backward, meaning that its anchor point appears in the
   * document _after_ its focus point.
   */
  isBackward(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.isAfter(anchor, focus);
  },

  /**
   * Check if a range is collapsed, meaning that both its anchor and focus
   * points refer to the exact same position in the document.
   */
  isCollapsed(range) {
    var {
      anchor,
      focus
    } = range;
    return Point.equals(anchor, focus);
  },

  /**
   * Check if a range is expanded.
   *
   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.
   */
  isExpanded(range) {
    return !Range$2.isCollapsed(range);
  },

  /**
   * Check if a range is forward.
   *
   * This is the opposite of [[Range.isBackward]] and is provided for legibility.
   */
  isForward(range) {
    return !Range$2.isBackward(range);
  },

  /**
   * Check if a value implements the [[Range]] interface.
   */
  isRange(value) {
    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);
  },

  /**
   * Iterate through all of the point entries in a range.
   */
  *points(range) {
    yield [range.anchor, 'anchor'];
    yield [range.focus, 'focus'];
  },

  /**
   * Get the start point of a range.
   */
  start(range) {
    var [start] = Range$2.edges(range);
    return start;
  },

  /**
   * Transform a range by an operation.
   */
  transform(range, op) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      affinity = 'inward'
    } = options;
    var affinityAnchor;
    var affinityFocus;

    if (affinity === 'inward') {
      if (Range$2.isForward(range)) {
        affinityAnchor = 'forward';
        affinityFocus = 'backward';
      } else {
        affinityAnchor = 'backward';
        affinityFocus = 'forward';
      }
    } else if (affinity === 'outward') {
      if (Range$2.isForward(range)) {
        affinityAnchor = 'backward';
        affinityFocus = 'forward';
      } else {
        affinityAnchor = 'forward';
        affinityFocus = 'backward';
      }
    } else {
      affinityAnchor = affinity;
      affinityFocus = affinity;
    }

    return fn$1(range, r => {
      var anchor = Point.transform(r.anchor, op, {
        affinity: affinityAnchor
      });
      var focus = Point.transform(r.focus, op, {
        affinity: affinityFocus
      });

      if (!anchor || !focus) {
        return null;
      }

      r.anchor = anchor;
      r.focus = focus;
    });
  }

};

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Text$4 = {
  /**
   * Check if two text nodes are equal.
   */
  equals(text, another) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      loose = false
    } = options;

    function omitText(obj) {
      var rest = _objectWithoutProperties$2(obj, ["text"]);

      return rest;
    }

    return fastDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);
  },

  /**
   * Check if a value implements the `Text` interface.
   */
  isText(value) {
    return isPlainObject(value) && typeof value.text === 'string';
  },

  /**
   * Check if a value is a list of `Text` objects.
   */
  isTextList(value) {
    return Array.isArray(value) && value.every(val => Text$4.isText(val));
  },

  /**
   * Check if some props are a partial of Text.
   */
  isTextProps(props) {
    return props.text !== undefined;
  },

  /**
   * Check if an text matches set of properties.
   *
   * Note: this is for matching custom properties, and it does not ensure that
   * the `text` property are two nodes equal.
   */
  matches(text, props) {
    for (var key in props) {
      if (key === 'text') {
        continue;
      }

      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {
        return false;
      }
    }

    return true;
  },

  /**
   * Get the leaves for a text node given decorations.
   */
  decorations(node, decorations) {
    var leaves = [_objectSpread$5({}, node)];

    for (var dec of decorations) {
      var rest = _objectWithoutProperties$2(dec, ["anchor", "focus"]);

      var [start, end] = Range$2.edges(dec);
      var next = [];
      var o = 0;

      for (var leaf of leaves) {
        var {
          length
        } = leaf.text;
        var offset = o;
        o += length; // If the range encompases the entire leaf, add the range.

        if (start.offset <= offset && end.offset >= o) {
          Object.assign(leaf, rest);
          next.push(leaf);
          continue;
        } // If the range expanded and match the leaf, or starts after, or ends before it, continue.


        if (start.offset !== end.offset && (start.offset === o || end.offset === offset) || start.offset > o || end.offset < offset || end.offset === offset && offset !== 0) {
          next.push(leaf);
          continue;
        } // Otherwise we need to split the leaf, at the start, end, or both,
        // and add the range to the middle intersecting section. Do the end
        // split first since we don't need to update the offset that way.


        var middle = leaf;
        var before = void 0;
        var after = void 0;

        if (end.offset < o) {
          var off = end.offset - offset;
          after = _objectSpread$5(_objectSpread$5({}, middle), {}, {
            text: middle.text.slice(off)
          });
          middle = _objectSpread$5(_objectSpread$5({}, middle), {}, {
            text: middle.text.slice(0, off)
          });
        }

        if (start.offset > offset) {
          var _off = start.offset - offset;

          before = _objectSpread$5(_objectSpread$5({}, middle), {}, {
            text: middle.text.slice(0, _off)
          });
          middle = _objectSpread$5(_objectSpread$5({}, middle), {}, {
            text: middle.text.slice(_off)
          });
        }

        Object.assign(middle, rest);

        if (before) {
          next.push(before);
        }

        next.push(middle);

        if (after) {
          next.push(after);
        }
      }

      leaves = next;
    }

    return leaves;
  }

};

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var applyToDraft = (editor, selection, op) => {
  switch (op.type) {
    case 'insert_node':
      {
        var {
          path,
          node
        } = op;
        var parent = Node.parent(editor, path);
        var index = path[path.length - 1];

        if (index > parent.children.length) {
          throw new Error("Cannot apply an \"insert_node\" operation at path [".concat(path, "] because the destination is past the end of the node."));
        }

        parent.children.splice(index, 0, node);

        if (selection) {
          for (var [point, key] of Range$2.points(selection)) {
            selection[key] = Point.transform(point, op);
          }
        }

        break;
      }

    case 'insert_text':
      {
        var {
          path: _path,
          offset,
          text
        } = op;
        if (text.length === 0) break;

        var _node = Node.leaf(editor, _path);

        var before = _node.text.slice(0, offset);

        var after = _node.text.slice(offset);

        _node.text = before + text + after;

        if (selection) {
          for (var [_point, _key] of Range$2.points(selection)) {
            selection[_key] = Point.transform(_point, op);
          }
        }

        break;
      }

    case 'merge_node':
      {
        var {
          path: _path2
        } = op;

        var _node2 = Node.get(editor, _path2);

        var prevPath = Path.previous(_path2);
        var prev = Node.get(editor, prevPath);

        var _parent = Node.parent(editor, _path2);

        var _index = _path2[_path2.length - 1];

        if (Text$4.isText(_node2) && Text$4.isText(prev)) {
          prev.text += _node2.text;
        } else if (!Text$4.isText(_node2) && !Text$4.isText(prev)) {
          prev.children.push(..._node2.children);
        } else {
          throw new Error("Cannot apply a \"merge_node\" operation at path [".concat(_path2, "] to nodes of different interfaces: ").concat(_node2, " ").concat(prev));
        }

        _parent.children.splice(_index, 1);

        if (selection) {
          for (var [_point2, _key2] of Range$2.points(selection)) {
            selection[_key2] = Point.transform(_point2, op);
          }
        }

        break;
      }

    case 'move_node':
      {
        var {
          path: _path3,
          newPath
        } = op;

        if (Path.isAncestor(_path3, newPath)) {
          throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
        }

        var _node3 = Node.get(editor, _path3);

        var _parent2 = Node.parent(editor, _path3);

        var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to
        // the same snapshot in time, there's a mismatch. After either
        // removing the original position, the second step's path can be out
        // of date. So instead of using the `op.newPath` directly, we
        // transform `op.path` to ascertain what the `newPath` would be after
        // the operation was applied.

        _parent2.children.splice(_index2, 1);

        var truePath = Path.transform(_path3, op);
        var newParent = Node.get(editor, Path.parent(truePath));
        var newIndex = truePath[truePath.length - 1];
        newParent.children.splice(newIndex, 0, _node3);

        if (selection) {
          for (var [_point3, _key3] of Range$2.points(selection)) {
            selection[_key3] = Point.transform(_point3, op);
          }
        }

        break;
      }

    case 'remove_node':
      {
        var {
          path: _path4
        } = op;
        var _index3 = _path4[_path4.length - 1];

        var _parent3 = Node.parent(editor, _path4);

        _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the
        // node that was removed we need to update the range or remove it.


        if (selection) {
          for (var [_point4, _key4] of Range$2.points(selection)) {
            var result = Point.transform(_point4, op);

            if (selection != null && result != null) {
              selection[_key4] = result;
            } else {
              var _prev = void 0;

              var next = void 0;

              for (var [n, p] of Node.texts(editor)) {
                if (Path.compare(p, _path4) === -1) {
                  _prev = [n, p];
                } else {
                  next = [n, p];
                  break;
                }
              }

              if (_prev) {
                _point4.path = _prev[1];
                _point4.offset = _prev[0].text.length;
              } else if (next) {
                _point4.path = next[1];
                _point4.offset = 0;
              } else {
                selection = null;
              }
            }
          }
        }

        break;
      }

    case 'remove_text':
      {
        var {
          path: _path5,
          offset: _offset,
          text: _text
        } = op;
        if (_text.length === 0) break;

        var _node4 = Node.leaf(editor, _path5);

        var _before = _node4.text.slice(0, _offset);

        var _after = _node4.text.slice(_offset + _text.length);

        _node4.text = _before + _after;

        if (selection) {
          for (var [_point5, _key5] of Range$2.points(selection)) {
            selection[_key5] = Point.transform(_point5, op);
          }
        }

        break;
      }

    case 'set_node':
      {
        var {
          path: _path6,
          properties,
          newProperties
        } = op;

        if (_path6.length === 0) {
          throw new Error("Cannot set properties on the root node!");
        }

        var _node5 = Node.get(editor, _path6);

        for (var _key6 in newProperties) {
          if (_key6 === 'children' || _key6 === 'text') {
            throw new Error("Cannot set the \"".concat(_key6, "\" property of nodes!"));
          }

          var value = newProperties[_key6];

          if (value == null) {
            delete _node5[_key6];
          } else {
            _node5[_key6] = value;
          }
        } // properties that were previously defined, but are now missing, must be deleted


        for (var _key7 in properties) {
          if (!newProperties.hasOwnProperty(_key7)) {
            delete _node5[_key7];
          }
        }

        break;
      }

    case 'set_selection':
      {
        var {
          newProperties: _newProperties
        } = op;

        if (_newProperties == null) {
          selection = _newProperties;
        } else {
          if (selection == null) {
            if (!Range$2.isRange(_newProperties)) {
              throw new Error("Cannot apply an incomplete \"set_selection\" operation properties ".concat(JSON.stringify(_newProperties), " when there is no current selection."));
            }

            selection = _objectSpread$6({}, _newProperties);
          }

          for (var _key8 in _newProperties) {
            var _value = _newProperties[_key8];

            if (_value == null) {
              if (_key8 === 'anchor' || _key8 === 'focus') {
                throw new Error("Cannot remove the \"".concat(_key8, "\" selection property"));
              }

              delete selection[_key8];
            } else {
              selection[_key8] = _value;
            }
          }
        }

        break;
      }

    case 'split_node':
      {
        var {
          path: _path7,
          position,
          properties: _properties
        } = op;

        if (_path7.length === 0) {
          throw new Error("Cannot apply a \"split_node\" operation at path [".concat(_path7, "] because the root node cannot be split."));
        }

        var _node6 = Node.get(editor, _path7);

        var _parent4 = Node.parent(editor, _path7);

        var _index4 = _path7[_path7.length - 1];
        var newNode;

        if (Text$4.isText(_node6)) {
          var _before2 = _node6.text.slice(0, position);

          var _after2 = _node6.text.slice(position);

          _node6.text = _before2;
          newNode = _objectSpread$6(_objectSpread$6({}, _properties), {}, {
            text: _after2
          });
        } else {
          var _before3 = _node6.children.slice(0, position);

          var _after3 = _node6.children.slice(position);

          _node6.children = _before3;
          newNode = _objectSpread$6(_objectSpread$6({}, _properties), {}, {
            children: _after3
          });
        }

        _parent4.children.splice(_index4 + 1, 0, newNode);

        if (selection) {
          for (var [_point6, _key9] of Range$2.points(selection)) {
            selection[_key9] = Point.transform(_point6, op);
          }
        }

        break;
      }
  }

  return selection;
};

var GeneralTransforms = {
  /**
   * Transform the editor by an operation.
   */
  transform(editor, op) {
    editor.children = ln(editor.children);
    var selection = editor.selection && ln(editor.selection);

    try {
      selection = applyToDraft(editor, selection, op);
    } finally {
      editor.children = dn(editor.children);

      if (selection) {
        editor.selection = r$1(selection) ? dn(selection) : selection;
      } else {
        editor.selection = null;
      }
    }
  }

};

function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var NodeTransforms = {
  /**
   * Insert nodes at a specific location in the Editor.
   */
  insertNodes(editor, nodes) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = 'lowest'
      } = options;
      var {
        at,
        match,
        select
      } = options;

      if (Node.isNode(nodes)) {
        nodes = [nodes];
      }

      if (nodes.length === 0) {
        return;
      }

      var [node] = nodes; // By default, use the selection as the target location. But if there is
      // no selection, insert at the end of the document since that is such a
      // common use case when inserting from a non-selected state.

      if (!at) {
        if (editor.selection) {
          at = editor.selection;
        } else if (editor.children.length > 0) {
          at = Editor.end(editor, []);
        } else {
          at = [0];
        }

        select = true;
      }

      if (select == null) {
        select = false;
      }

      if (Range$2.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at);
        }

        if (Range$2.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range$2.edges(at);
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      }

      if (Point.isPoint(at)) {
        if (match == null) {
          if (Text$4.isText(node)) {
            match = n => Text$4.isText(n);
          } else if (editor.isInline(node)) {
            match = n => Text$4.isText(n) || Editor.isInline(editor, n);
          } else {
            match = n => Editor.isBlock(editor, n);
          }
        }

        var [entry] = Editor.nodes(editor, {
          at: at.path,
          match,
          mode,
          voids
        });

        if (entry) {
          var [, _matchPath] = entry;
          var pathRef = Editor.pathRef(editor, _matchPath);
          var isAtEnd = Editor.isEnd(editor, at, _matchPath);
          Transforms.splitNodes(editor, {
            at,
            match,
            mode,
            voids
          });
          var path = pathRef.unref();
          at = isAtEnd ? Path.next(path) : path;
        } else {
          return;
        }
      }

      var parentPath = Path.parent(at);
      var index = at[at.length - 1];

      if (!voids && Editor.void(editor, {
        at: parentPath
      })) {
        return;
      }

      for (var _node of nodes) {
        var _path = parentPath.concat(index);

        index++;
        editor.apply({
          type: 'insert_node',
          path: _path,
          node: _node
        });
      }

      if (select) {
        var point = Editor.end(editor, at);

        if (point) {
          Transforms.select(editor, point);
        }
      }
    });
  },

  /**
   * Lift nodes at a specific location upwards in the document tree, splitting
   * their parent in two if necessary.
   */
  liftNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        at = editor.selection,
        mode = 'lowest',
        voids = false
      } = options;
      var {
        match
      } = options;

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      if (!at) {
        return;
      }

      var matches = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(matches, (_ref) => {
        var [, p] = _ref;
        return Editor.pathRef(editor, p);
      });

      for (var pathRef of pathRefs) {
        var path = pathRef.unref();

        if (path.length < 2) {
          throw new Error("Cannot lift node at a path [".concat(path, "] because it has a depth of less than `2`."));
        }

        var parentNodeEntry = Editor.node(editor, Path.parent(path));
        var [parent, parentPath] = parentNodeEntry;
        var index = path[path.length - 1];
        var {
          length
        } = parent.children;

        if (length === 1) {
          var toPath = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path,
            to: toPath,
            voids
          });
          Transforms.removeNodes(editor, {
            at: parentPath,
            voids
          });
        } else if (index === 0) {
          Transforms.moveNodes(editor, {
            at: path,
            to: parentPath,
            voids
          });
        } else if (index === length - 1) {
          var _toPath = Path.next(parentPath);

          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath,
            voids
          });
        } else {
          var splitPath = Path.next(path);

          var _toPath2 = Path.next(parentPath);

          Transforms.splitNodes(editor, {
            at: splitPath,
            voids
          });
          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath2,
            voids
          });
        }
      }
    });
  },

  /**
   * Merge a node at a location with the previous node of the same depth,
   * removing any empty containing nodes after the merge if necessary.
   */
  mergeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match,
        at = editor.selection
      } = options;
      var {
        hanging = false,
        voids = false,
        mode = 'lowest'
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        if (Path.isPath(at)) {
          var [parent] = Editor.parent(editor, at);

          match = n => parent.children.includes(n);
        } else {
          match = n => Editor.isBlock(editor, n);
        }
      }

      if (!hanging && Range$2.isRange(at)) {
        at = Editor.unhangRange(editor, at);
      }

      if (Range$2.isRange(at)) {
        if (Range$2.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range$2.edges(at);
          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();

          if (options.at == null) {
            Transforms.select(editor, at);
          }
        }
      }

      var [current] = Editor.nodes(editor, {
        at,
        match,
        voids,
        mode
      });
      var prev = Editor.previous(editor, {
        at,
        match,
        voids,
        mode
      });

      if (!current || !prev) {
        return;
      }

      var [node, path] = current;
      var [prevNode, prevPath] = prev;

      if (path.length === 0 || prevPath.length === 0) {
        return;
      }

      var newPath = Path.next(prevPath);
      var commonPath = Path.common(path, prevPath);
      var isPreviousSibling = Path.isSibling(path, prevPath);
      var levels = Array.from(Editor.levels(editor, {
        at: path
      }), (_ref2) => {
        var [n] = _ref2;
        return n;
      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a
      // result, in which case we'll want to remove it after merging.

      var emptyAncestor = Editor.above(editor, {
        at: path,
        mode: 'highest',
        match: n => levels.includes(n) && hasSingleChildNest(editor, n)
      });
      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);
      var properties;
      var position; // Ensure that the nodes are equivalent, and figure out what the position
      // and extra properties of the merge will be.

      if (Text$4.isText(node) && Text$4.isText(prevNode)) {
        var rest = _objectWithoutProperties$2(node, ["text"]);

        position = prevNode.text.length;
        properties = rest;
      } else if (Element$2.isElement(node) && Element$2.isElement(prevNode)) {
        var rest = _objectWithoutProperties$2(node, ["children"]);

        position = prevNode.children.length;
        properties = rest;
      } else {
        throw new Error("Cannot merge the node at path [".concat(path, "] with the previous sibling because it is not the same kind: ").concat(JSON.stringify(node), " ").concat(JSON.stringify(prevNode)));
      } // If the node isn't already the next sibling of the previous node, move
      // it so that it is before merging.


      if (!isPreviousSibling) {
        Transforms.moveNodes(editor, {
          at: path,
          to: newPath,
          voids
        });
      } // If there was going to be an empty ancestor of the node that was merged,
      // we remove it from the tree.


      if (emptyRef) {
        Transforms.removeNodes(editor, {
          at: emptyRef.current,
          voids
        });
      } // If the target node that we're merging with is empty, remove it instead
      // of merging the two. This is a common rich text editor behavior to
      // prevent losing formatting when deleting entire nodes when you have a
      // hanging selection.


      if (Element$2.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text$4.isText(prevNode) && prevNode.text === '') {
        Transforms.removeNodes(editor, {
          at: prevPath,
          voids
        });
      } else {
        editor.apply({
          type: 'merge_node',
          path: newPath,
          position,
          properties
        });
      }

      if (emptyRef) {
        emptyRef.unref();
      }
    });
  },

  /**
   * Move the nodes at a location to a new location.
   */
  moveNodes(editor, options) {
    Editor.withoutNormalizing(editor, () => {
      var {
        to,
        at = editor.selection,
        mode = 'lowest',
        voids = false
      } = options;
      var {
        match
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      var toRef = Editor.pathRef(editor, to);
      var targets = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(targets, (_ref3) => {
        var [, p] = _ref3;
        return Editor.pathRef(editor, p);
      });

      for (var pathRef of pathRefs) {
        var path = pathRef.unref();
        var newPath = toRef.current;

        if (path.length !== 0) {
          editor.apply({
            type: 'move_node',
            path,
            newPath
          });
        }

        if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {
          // When performing a sibling move to a later index, the path at the destination is shifted
          // to before the insertion point instead of after. To ensure our group of nodes are inserted
          // in the correct order we increment toRef to account for that
          toRef.current = Path.next(toRef.current);
        }
      }

      toRef.unref();
    });
  },

  /**
   * Remove the nodes at a specific location in the document.
   */
  removeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = 'lowest'
      } = options;
      var {
        at = editor.selection,
        match
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      if (!hanging && Range$2.isRange(at)) {
        at = Editor.unhangRange(editor, at);
      }

      var depths = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(depths, (_ref4) => {
        var [, p] = _ref4;
        return Editor.pathRef(editor, p);
      });

      for (var pathRef of pathRefs) {
        var path = pathRef.unref();

        if (path) {
          var [node] = Editor.node(editor, path);
          editor.apply({
            type: 'remove_node',
            path,
            node
          });
        }
      }
    });
  },

  /**
   * Set new properties on the nodes at a location.
   */
  setNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match,
        at = editor.selection
      } = options;
      var {
        hanging = false,
        mode = 'lowest',
        split = false,
        voids = false
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      if (!hanging && Range$2.isRange(at)) {
        at = Editor.unhangRange(editor, at);
      }

      if (split && Range$2.isRange(at)) {
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: 'inward'
        });
        var [start, end] = Range$2.edges(at);
        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';
        var endAtEndOfNode = Editor.isEnd(editor, end, end.path);
        Transforms.splitNodes(editor, {
          at: end,
          match,
          mode: splitMode,
          voids,
          always: !endAtEndOfNode
        });
        var startAtStartOfNode = Editor.isStart(editor, start, start.path);
        Transforms.splitNodes(editor, {
          at: start,
          match,
          mode: splitMode,
          voids,
          always: !startAtStartOfNode
        });
        at = rangeRef.unref();

        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }

      for (var [node, path] of Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      })) {
        var properties = {};
        var newProperties = {}; // You can't set properties on the editor node.

        if (path.length === 0) {
          continue;
        }

        for (var k in props) {
          if (k === 'children' || k === 'text') {
            continue;
          }

          if (props[k] !== node[k]) {
            // Omit new properties from the old property list rather than set them to undefined
            if (node.hasOwnProperty(k)) properties[k] = node[k];
            newProperties[k] = props[k];
          }
        }

        if (Object.keys(newProperties).length !== 0) {
          editor.apply({
            type: 'set_node',
            path,
            properties,
            newProperties
          });
        }
      }
    });
  },

  /**
   * Split the nodes at a specific location.
   */
  splitNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = 'lowest',
        voids = false
      } = options;
      var {
        match,
        at = editor.selection,
        height = 0,
        always = false
      } = options;

      if (match == null) {
        match = n => Editor.isBlock(editor, n);
      }

      if (Range$2.isRange(at)) {
        at = deleteRange(editor, at);
      } // If the target is a path, the default height-skipping and position
      // counters need to account for us potentially splitting at a non-leaf.


      if (Path.isPath(at)) {
        var path = at;
        var point = Editor.point(editor, path);
        var [parent] = Editor.parent(editor, path);

        match = n => n === parent;

        height = point.path.length - path.length + 1;
        at = point;
        always = true;
      }

      if (!at) {
        return;
      }

      var beforeRef = Editor.pointRef(editor, at, {
        affinity: 'backward'
      });
      var [highest] = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });

      if (!highest) {
        return;
      }

      var voidMatch = Editor.void(editor, {
        at,
        mode: 'highest'
      });
      var nudge = 0;

      if (!voids && voidMatch) {
        var [voidNode, voidPath] = voidMatch;

        if (Element$2.isElement(voidNode) && editor.isInline(voidNode)) {
          var after = Editor.after(editor, voidPath);

          if (!after) {
            var text = {
              text: ''
            };
            var afterPath = Path.next(voidPath);
            Transforms.insertNodes(editor, text, {
              at: afterPath,
              voids
            });
            after = Editor.point(editor, afterPath);
          }

          at = after;
          always = true;
        }

        var siblingHeight = at.path.length - voidPath.length;
        height = siblingHeight + 1;
        always = true;
      }

      var afterRef = Editor.pointRef(editor, at);
      var depth = at.path.length - height;
      var [, highestPath] = highest;
      var lowestPath = at.path.slice(0, depth);
      var position = height === 0 ? at.offset : at.path[depth] + nudge;

      for (var [node, _path2] of Editor.levels(editor, {
        at: lowestPath,
        reverse: true,
        voids
      })) {
        var split = false;

        if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor.isVoid(editor, node)) {
          break;
        }

        var _point = beforeRef.current;
        var isEnd = Editor.isEnd(editor, _point, _path2);

        if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {
          split = true;
          var properties = Node.extractProps(node);
          editor.apply({
            type: 'split_node',
            path: _path2,
            position,
            properties
          });
        }

        position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);
      }

      if (options.at == null) {
        var _point2 = afterRef.current || Editor.end(editor, []);

        Transforms.select(editor, _point2);
      }

      beforeRef.unref();
      afterRef.unref();
    });
  },

  /**
   * Unset properties on the nodes at a location.
   */
  unsetNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (!Array.isArray(props)) {
      props = [props];
    }

    var obj = {};

    for (var key of props) {
      obj[key] = null;
    }

    Transforms.setNodes(editor, obj, options);
  },

  /**
   * Unwrap the nodes at a location from a parent node, splitting the parent if
   * necessary to ensure that only the content in the range is unwrapped.
   */
  unwrapNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = 'lowest',
        split = false,
        voids = false
      } = options;
      var {
        at = editor.selection,
        match
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);
      }

      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }

      var rangeRef = Range$2.isRange(at) ? Editor.rangeRef(editor, at) : null;
      var matches = Editor.nodes(editor, {
        at,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(matches, (_ref5) => {
        var [, p] = _ref5;
        return Editor.pathRef(editor, p);
      });

      var _loop = function _loop(pathRef) {
        var path = pathRef.unref();
        var [node] = Editor.node(editor, path);
        var range = Editor.range(editor, path);

        if (split && rangeRef) {
          range = Range$2.intersection(rangeRef.current, range);
        }

        Transforms.liftNodes(editor, {
          at: range,
          match: n => Element$2.isAncestor(node) && node.children.includes(n),
          voids
        });
      };

      for (var pathRef of pathRefs) {
        _loop(pathRef);
      }

      if (rangeRef) {
        rangeRef.unref();
      }
    });
  },

  /**
   * Wrap the nodes at a location in a new container node, splitting the edges
   * of the range first to ensure that only the content in the range is wrapped.
   */
  wrapNodes(editor, element) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = 'lowest',
        split = false,
        voids = false
      } = options;
      var {
        match,
        at = editor.selection
      } = options;

      if (!at) {
        return;
      }

      if (match == null) {
        if (Path.isPath(at)) {
          match = matchPath(editor, at);
        } else if (editor.isInline(element)) {
          match = n => Editor.isInline(editor, n) || Text$4.isText(n);
        } else {
          match = n => Editor.isBlock(editor, n);
        }
      }

      if (split && Range$2.isRange(at)) {
        var [start, end] = Range$2.edges(at);
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: 'inward'
        });
        Transforms.splitNodes(editor, {
          at: end,
          match,
          voids
        });
        Transforms.splitNodes(editor, {
          at: start,
          match,
          voids
        });
        at = rangeRef.unref();

        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }

      var roots = Array.from(Editor.nodes(editor, {
        at,
        match: editor.isInline(element) ? n => Editor.isBlock(editor, n) : n => Editor.isEditor(n),
        mode: 'lowest',
        voids
      }));

      for (var [, rootPath] of roots) {
        var a = Range$2.isRange(at) ? Range$2.intersection(at, Editor.range(editor, rootPath)) : at;

        if (!a) {
          continue;
        }

        var matches = Array.from(Editor.nodes(editor, {
          at: a,
          match,
          mode,
          voids
        }));

        if (matches.length > 0) {
          (function () {
            var [first] = matches;
            var last = matches[matches.length - 1];
            var [, firstPath] = first;
            var [, lastPath] = last;
            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);
            var range = Editor.range(editor, firstPath, lastPath);
            var commonNodeEntry = Editor.node(editor, commonPath);
            var [commonNode] = commonNodeEntry;
            var depth = commonPath.length + 1;
            var wrapperPath = Path.next(lastPath.slice(0, depth));

            var wrapper = _objectSpread$7(_objectSpread$7({}, element), {}, {
              children: []
            });

            Transforms.insertNodes(editor, wrapper, {
              at: wrapperPath,
              voids
            });
            Transforms.moveNodes(editor, {
              at: range,
              match: n => Element$2.isAncestor(commonNode) && commonNode.children.includes(n),
              to: wrapperPath.concat(0),
              voids
            });
          })();
        }
      }
    });
  }

};

var hasSingleChildNest = (editor, node) => {
  if (Element$2.isElement(node)) {
    var element = node;

    if (Editor.isVoid(editor, node)) {
      return true;
    } else if (element.children.length === 1) {
      return hasSingleChildNest(editor, element.children[0]);
    } else {
      return false;
    }
  } else if (Editor.isEditor(node)) {
    return false;
  } else {
    return true;
  }
};
/**
 * Convert a range into a point by deleting it's content.
 */


var deleteRange = (editor, range) => {
  if (Range$2.isCollapsed(range)) {
    return range.anchor;
  } else {
    var [, end] = Range$2.edges(range);
    var pointRef = Editor.pointRef(editor, end);
    Transforms.delete(editor, {
      at: range
    });
    return pointRef.unref();
  }
};

var matchPath = (editor, path) => {
  var [node] = Editor.node(editor, path);
  return n => n === node;
};

function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var SelectionTransforms = {
  /**
   * Collapse the selection.
   */
  collapse(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      edge = 'anchor'
    } = options;
    var {
      selection
    } = editor;

    if (!selection) {
      return;
    } else if (edge === 'anchor') {
      Transforms.select(editor, selection.anchor);
    } else if (edge === 'focus') {
      Transforms.select(editor, selection.focus);
    } else if (edge === 'start') {
      var [start] = Range$2.edges(selection);
      Transforms.select(editor, start);
    } else if (edge === 'end') {
      var [, end] = Range$2.edges(selection);
      Transforms.select(editor, end);
    }
  },

  /**
   * Unset the selection.
   */
  deselect(editor) {
    var {
      selection
    } = editor;

    if (selection) {
      editor.apply({
        type: 'set_selection',
        properties: selection,
        newProperties: null
      });
    }
  },

  /**
   * Move the selection's point forward or backward.
   */
  move(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var {
      selection
    } = editor;
    var {
      distance = 1,
      unit = 'character',
      reverse = false
    } = options;
    var {
      edge = null
    } = options;

    if (!selection) {
      return;
    }

    if (edge === 'start') {
      edge = Range$2.isBackward(selection) ? 'focus' : 'anchor';
    }

    if (edge === 'end') {
      edge = Range$2.isBackward(selection) ? 'anchor' : 'focus';
    }

    var {
      anchor,
      focus
    } = selection;
    var opts = {
      distance,
      unit
    };
    var props = {};

    if (edge == null || edge === 'anchor') {
      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);

      if (point) {
        props.anchor = point;
      }
    }

    if (edge == null || edge === 'focus') {
      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);

      if (_point) {
        props.focus = _point;
      }
    }

    Transforms.setSelection(editor, props);
  },

  /**
   * Set the selection to a new value.
   */
  select(editor, target) {
    var {
      selection
    } = editor;
    target = Editor.range(editor, target);

    if (selection) {
      Transforms.setSelection(editor, target);
      return;
    }

    if (!Range$2.isRange(target)) {
      throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(JSON.stringify(target)));
    }

    editor.apply({
      type: 'set_selection',
      properties: selection,
      newProperties: target
    });
  },

  /**
   * Set new properties on one of the selection's points.
   */
  setPoint(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {
      selection
    } = editor;
    var {
      edge = 'both'
    } = options;

    if (!selection) {
      return;
    }

    if (edge === 'start') {
      edge = Range$2.isBackward(selection) ? 'focus' : 'anchor';
    }

    if (edge === 'end') {
      edge = Range$2.isBackward(selection) ? 'anchor' : 'focus';
    }

    var {
      anchor,
      focus
    } = selection;
    var point = edge === 'anchor' ? anchor : focus;
    Transforms.setSelection(editor, {
      [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$8(_objectSpread$8({}, point), props)
    });
  },

  /**
   * Set new properties on the selection.
   */
  setSelection(editor, props) {
    var {
      selection
    } = editor;
    var oldProps = {};
    var newProps = {};

    if (!selection) {
      return;
    }

    for (var k in props) {
      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {
        oldProps[k] = selection[k];
        newProps[k] = props[k];
      }
    }

    if (Object.keys(oldProps).length > 0) {
      editor.apply({
        type: 'set_selection',
        properties: oldProps,
        newProperties: newProps
      });
    }
  }

};

var TextTransforms = {
  /**
   * Delete content in the editor.
   */
  delete(editor) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        reverse = false,
        unit = 'character',
        distance = 1,
        voids = false
      } = options;
      var {
        at = editor.selection,
        hanging = false
      } = options;

      if (!at) {
        return;
      }

      if (Range$2.isRange(at) && Range$2.isCollapsed(at)) {
        at = at.anchor;
      }

      if (Point.isPoint(at)) {
        var furthestVoid = Editor.void(editor, {
          at,
          mode: 'highest'
        });

        if (!voids && furthestVoid) {
          var [, voidPath] = furthestVoid;
          at = voidPath;
        } else {
          var opts = {
            unit,
            distance
          };
          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);
          at = {
            anchor: at,
            focus: target
          };
          hanging = true;
        }
      }

      if (Path.isPath(at)) {
        Transforms.removeNodes(editor, {
          at,
          voids
        });
        return;
      }

      if (Range$2.isCollapsed(at)) {
        return;
      }

      if (!hanging) {
        var [, _end] = Range$2.edges(at);
        var endOfDoc = Editor.end(editor, []);

        if (!Point.equals(_end, endOfDoc)) {
          at = Editor.unhangRange(editor, at, {
            voids
          });
        }
      }

      var [start, end] = Range$2.edges(at);
      var startBlock = Editor.above(editor, {
        match: n => Editor.isBlock(editor, n),
        at: start,
        voids
      });
      var endBlock = Editor.above(editor, {
        match: n => Editor.isBlock(editor, n),
        at: end,
        voids
      });
      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
      var isSingleText = Path.equals(start.path, end.path);
      var startVoid = voids ? null : Editor.void(editor, {
        at: start,
        mode: 'highest'
      });
      var endVoid = voids ? null : Editor.void(editor, {
        at: end,
        mode: 'highest'
      }); // If the start or end points are inside an inline void, nudge them out.

      if (startVoid) {
        var before = Editor.before(editor, start);

        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {
          start = before;
        }
      }

      if (endVoid) {
        var after = Editor.after(editor, end);

        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {
          end = after;
        }
      } // Get the highest nodes that are completely inside the range, as well as
      // the start and end nodes.


      var matches = [];
      var lastPath;

      for (var entry of Editor.nodes(editor, {
        at,
        voids
      })) {
        var [node, path] = entry;

        if (lastPath && Path.compare(path, lastPath) === 0) {
          continue;
        }

        if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {
          matches.push(entry);
          lastPath = path;
        }
      }

      var pathRefs = Array.from(matches, (_ref) => {
        var [, p] = _ref;
        return Editor.pathRef(editor, p);
      });
      var startRef = Editor.pointRef(editor, start);
      var endRef = Editor.pointRef(editor, end);

      if (!isSingleText && !startVoid) {
        var _point = startRef.current;
        var [_node] = Editor.leaf(editor, _point);
        var {
          path: _path
        } = _point;
        var {
          offset
        } = start;

        var text = _node.text.slice(offset);

        if (text.length > 0) editor.apply({
          type: 'remove_text',
          path: _path,
          offset,
          text
        });
      }

      for (var pathRef of pathRefs) {
        var _path2 = pathRef.unref();

        Transforms.removeNodes(editor, {
          at: _path2,
          voids
        });
      }

      if (!endVoid) {
        var _point2 = endRef.current;
        var [_node2] = Editor.leaf(editor, _point2);
        var {
          path: _path3
        } = _point2;

        var _offset = isSingleText ? start.offset : 0;

        var _text = _node2.text.slice(_offset, end.offset);

        if (_text.length > 0) editor.apply({
          type: 'remove_text',
          path: _path3,
          offset: _offset,
          text: _text
        });
      }

      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
        Transforms.mergeNodes(editor, {
          at: endRef.current,
          hanging: true,
          voids
        });
      }

      var point = reverse ? startRef.unref() || endRef.unref() : endRef.unref() || startRef.unref();

      if (options.at == null && point) {
        Transforms.select(editor, point);
      }
    });
  },

  /**
   * Insert a fragment at a specific location in the editor.
   */
  insertFragment(editor, fragment) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;

      if (!fragment.length) {
        return;
      }

      if (!at) {
        return;
      } else if (Range$2.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at);
        }

        if (Range$2.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end] = Range$2.edges(at);

          if (!voids && Editor.void(editor, {
            at: end
          })) {
            return;
          }

          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      } else if (Path.isPath(at)) {
        at = Editor.start(editor, at);
      }

      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      } // If the insert point is at the edge of an inline node, move it outside
      // instead since it will need to be split otherwise.


      var inlineElementMatch = Editor.above(editor, {
        at,
        match: n => Editor.isInline(editor, n),
        mode: 'highest',
        voids
      });

      if (inlineElementMatch) {
        var [, _inlinePath] = inlineElementMatch;

        if (Editor.isEnd(editor, at, _inlinePath)) {
          var after = Editor.after(editor, _inlinePath);
          at = after;
        } else if (Editor.isStart(editor, at, _inlinePath)) {
          var before = Editor.before(editor, _inlinePath);
          at = before;
        }
      }

      var blockMatch = Editor.above(editor, {
        match: n => Editor.isBlock(editor, n),
        at,
        voids
      });
      var [, blockPath] = blockMatch;
      var isBlockStart = Editor.isStart(editor, at, blockPath);
      var isBlockEnd = Editor.isEnd(editor, at, blockPath);
      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;
      var mergeEnd = !isBlockEnd;
      var [, firstPath] = Node.first({
        children: fragment
      }, []);
      var [, lastPath] = Node.last({
        children: fragment
      }, []);
      var matches = [];

      var matcher = (_ref2) => {
        var [n, p] = _ref2;

        if (mergeStart && Path.isAncestor(p, firstPath) && Element$2.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {
          return false;
        }

        if (mergeEnd && Path.isAncestor(p, lastPath) && Element$2.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {
          return false;
        }

        return true;
      };

      for (var entry of Node.nodes({
        children: fragment
      }, {
        pass: matcher
      })) {
        if (entry[1].length > 0 && matcher(entry)) {
          matches.push(entry);
        }
      }

      var starts = [];
      var middles = [];
      var ends = [];
      var starting = true;
      var hasBlocks = false;

      for (var [node] of matches) {
        if (Element$2.isElement(node) && !editor.isInline(node)) {
          starting = false;
          hasBlocks = true;
          middles.push(node);
        } else if (starting) {
          starts.push(node);
        } else {
          ends.push(node);
        }
      }

      var [inlineMatch] = Editor.nodes(editor, {
        at,
        match: n => Text$4.isText(n) || Editor.isInline(editor, n),
        mode: 'highest',
        voids
      });
      var [, inlinePath] = inlineMatch;
      var isInlineStart = Editor.isStart(editor, at, inlinePath);
      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);
      var middleRef = Editor.pathRef(editor, isBlockEnd ? Path.next(blockPath) : blockPath);
      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.splitNodes(editor, {
        at,
        match: n => hasBlocks ? Editor.isBlock(editor, n) : Text$4.isText(n) || Editor.isInline(editor, n),
        mode: hasBlocks ? 'lowest' : 'highest',
        voids
      });
      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.insertNodes(editor, starts, {
        at: startRef.current,
        match: n => Text$4.isText(n) || Editor.isInline(editor, n),
        mode: 'highest',
        voids
      });
      Transforms.insertNodes(editor, middles, {
        at: middleRef.current,
        match: n => Editor.isBlock(editor, n),
        mode: 'lowest',
        voids
      });
      Transforms.insertNodes(editor, ends, {
        at: endRef.current,
        match: n => Text$4.isText(n) || Editor.isInline(editor, n),
        mode: 'highest',
        voids
      });

      if (!options.at) {
        var path;

        if (ends.length > 0) {
          path = Path.previous(endRef.current);
        } else if (middles.length > 0) {
          path = Path.previous(middleRef.current);
        } else {
          path = Path.previous(startRef.current);
        }

        var _end2 = Editor.end(editor, path);

        Transforms.select(editor, _end2);
      }

      startRef.unref();
      middleRef.unref();
      endRef.unref();
    });
  },

  /**
   * Insert a string of text in the Editor.
   */
  insertText(editor, text) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;

      if (!at) {
        return;
      }

      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }

      if (Range$2.isRange(at)) {
        if (Range$2.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var end = Range$2.end(at);

          if (!voids && Editor.void(editor, {
            at: end
          })) {
            return;
          }

          var pointRef = Editor.pointRef(editor, end);
          Transforms.delete(editor, {
            at,
            voids
          });
          at = pointRef.unref();
          Transforms.setSelection(editor, {
            anchor: at,
            focus: at
          });
        }
      }

      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      }

      var {
        path,
        offset
      } = at;
      if (text.length > 0) editor.apply({
        type: 'insert_text',
        path,
        offset,
        text
      });
    });
  }

};

function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);

const defaultValue = [
    {
        type: 'paragraph',
        children: [{ text: '' }],
    },
];
function getDefaultSlateNodeWithChildren(text) {
    return [
        {
            type: 'paragraph',
            children: [{ text }],
        },
    ];
}
function getNodesFromJSON(json) {
    if (!json) {
        return defaultValue;
    }
    let value;
    try {
        value = JSON.parse(json);
        if (!Array.isArray(value)) {
            value =
                typeof json === 'string'
                    ? getDefaultSlateNodeWithChildren(json)
                    : defaultValue;
        }
    }
    catch (e) {
        value =
            typeof json === 'string'
                ? getDefaultSlateNodeWithChildren(json)
                : defaultValue;
    }
    if (value.length === 0) {
        return defaultValue;
    }
    return value;
}
function getStringValueFromNodes(nodes) {
    return nodes
        .map(n => {
        if (n.type === 'mentions') {
            return '…';
        }
        if (n.children?.length) {
            return getStringValueFromNodes(n.children);
        }
        return Node.string(n);
    })
        .join('\n');
}
function getStringValueFromJSON(json) {
    const nodes = getNodesFromJSON(json);
    return getStringValueFromNodes(nodes);
}
function isNodesEmpty(nodes) {
    let empty = true;
    nodes.forEach(child => {
        if (empty) {
            if (child.type &&
                ['mentions', 'latex', 'media'].includes(child.type)) {
                // if child is of type mentions or latex, then also not empty
                empty = false;
            }
            else if (child.children) {
                // if child has more children, then recursively check them
                empty = isNodesEmpty(child.children);
            }
            else if (child.text &&
                child.text !== '') {
                // if the text is there, it is not empty
                empty = false;
            }
        }
    });
    return empty;
}

/**
 * Deeply omit a key from an object. Useful for removing __typename
 * from GraphQL queries before sending to the server.
 *
 * @link {https://gist.github.com/Billy-/d94b65998501736bfe6521eadc1ab538}
 *
 * @param value The original Object or Array.
 * @param key The key to omit from the object.
 */
function omitDeep(value, key) {
    if (Array.isArray(value)) {
        return value.map(i => omitDeep(i, key));
    }
    if (typeof value === 'object' && value !== null) {
        return Object.keys(value).reduce((newObject, k) => {
            if (k === key)
                return newObject;
            // eslint-disable-next-line prefer-object-spread
            return Object.assign({ [k]: omitDeep(value[k], key) }, newObject);
        }, {});
    }
    return value;
}
/**
 * Find an item in a haystack by Id.
 *
 * @param arr The haystack array.
 * @param id Id by which to search.
 */
function findInArrayById(arr, id) {
    const index = arr.findIndex(item => item.id === id);
    if (index === -1) {
        return undefined;
    }
    return [arr[index], index];
}
/**
 * Get items which are chosen, in order of the original list.
 *
 * @param ids Chosen Ids, can be out of order.
 * @param items Items, must be in order.
 */
function getChosenItemsInOrder(ids, items) {
    return items.filter(item => ids.includes(item.id));
}
/**
 * Deep copy an object with JSON function.
 *
 * This would work only if none of the elements of the object is a function.
 *
 * @param obj The input object
 */
function deepCopyWithJson(obj) {
    return JSON.parse(JSON.stringify(obj));
}
/**
 * Remove an item from an array of items. It removes by doing a equality check.
 */
function removeItemInArray(arr, item) {
    return arr.filter(id => id !== item);
}
/**
 * Deduplicate an array.
 *
 * @param arr Input array.
 */
function deDupArray(arr) {
    return arr.filter((a, b) => arr.indexOf(a) === b);
}
/**
 * Checks if two arrays have exactly the same items.
 *
 * @param arr1 Array one.
 * @param arr2 Array two.
 * @returns
 */
function areArraysEqual(arr1, arr2) {
    return arr1.every((item, index) => arr2[index] === item);
}
/**
 * Get paramter value from a URL seach string. It returns the value as-is.
 * It could be either a string or an array of string.
 *
 * @param search Search string from URL.
 * @param key Lookup key.
 */
function getUrlParameterValue(search, key) {
    const urlParams = parse(search);
    const valueFromUrl = urlParams[key];
    if (typeof valueFromUrl === 'string' || Array.isArray(valueFromUrl)) {
        return valueFromUrl;
    }
    return null;
}
/**
 * Match a label value with a list of MCQ Options. If a match is found, return
 * the id of the option from the option list.
 *
 * @param options MCQ Options List.
 * @param values Value of label to compare with.
 */
function matchValuesAgainstOptionLabel(options, values) {
    if (!options) {
        return [];
    }
    // first normalize the compare with values
    const compareWith = typeof values === 'string'
        ? [values.toLowerCase()]
        : values.map(v => v.toLowerCase());
    // assume the matchedIds
    const matchedIds = [];
    // Now match and push
    options.forEach(op => {
        const compareAgainst = getStringValueFromNodes(getNodesFromJSON(op.label)).toLowerCase();
        if (compareWith.includes(compareAgainst)) {
            matchedIds.push(op.id);
        }
    });
    return matchedIds;
}
/**
 * Get option ids from a comma delimited value.
 *
 * @param value Input value, comma delimited.
 * @param isSingle Whether or not only a single value is allowed
 * @returns Option ids list.
 */
function getOptionIdsFromString(value, isSingle = false) {
    if (!value) {
        return [];
    }
    const parsed = value.split(',');
    if (isSingle) {
        return [parsed[0]];
    }
    return parsed;
}
/**
 * Decode JSON record safely.
 *
 * @param json JSON value.
 */
function decodeJSONRecord(json) {
    try {
        const decodedExtra = JSON.parse(json ?? '');
        if (decodedExtra && typeof decodedExtra === 'object') {
            return decodedExtra;
        }
    }
    catch (e) {
        // do nothing
    }
    return null;
}
/**
 * Check the storage data integrity.
 *
 * We store complex data to a string in the following shape
 *
 * ```ts
 * {
 * 	type: string;
 * 	data: DataType;
 * }
 * ```
 *
 * This function checks if json has `type` and `data` property and `type` matches
 * given type.
 *
 * @param json Parsed JSON value.
 * @param type Type to look up for.
 * @returns True if successful, false otherwise.
 */
function verifyJsonDataStructureForStorage(json, type) {
    if (typeof json === 'object' && json.type && json.type === type) {
        return true;
    }
    return false;
}
/**
 * Checks whether a value is null or empty string.
 *
 * @param input Value to check against.
 */
function isNullOrEmptyString(input) {
    return input == null || input === '';
}
/**
 * Check if SOME of the given properties of the object, does have a
 * value included in parameter.
 *
 * @param obj Object to check against.
 * @param keys properties of objects to check.
 * @param values Values to check against.
 */
function checkObjectPropertiesSomeHaveValue(obj, keys, values) {
    return keys.some(key => values.includes(obj[key]));
}
/**
 * Check if ALL of the given properties of the object, does have a
 * value included in parameter.
 *
 * @param obj Object to check against.
 * @param keys properties of objects to check.
 * @param values Values to check against.
 */
function checkObjectPropertiesAllHaveValue(obj, keys, values) {
    return keys.every(key => values.includes(obj[key]));
}
function getOrderlyIndexedItemInArray(index, items) {
    const nextIndex = index % items.length;
    return items[nextIndex];
}

const wpEFormFonts = new Collections('EForm Fonts');
wpEFormFonts.addItem('inherit', {
    name: __('Inherit from theme', 'wp-eform'),
    fontFamily: 'inherit',
    enqueue: null,
});
wpEFormFonts.addItem('system', {
    name: __('System UI', 'wp-eform'),
    fontFamily: `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
    enqueue: null,
});
wpEFormFonts.addItem('systemMono', {
    name: __('System UI Mono', 'wp-eform'),
    fontFamily: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
    enqueue: null,
});
wpEFormFonts.addItem('custom', {
    name: __('Custom Font', 'wp-eform'),
    fontFamily: '',
    enqueue: null,
});
// Google WebFonts
// TODO: Combine lists from the following URLs
// 1. https://www.awwwards.com/20-best-web-fonts-from-google-web-fonts-and-font-face.html
// 2. https://www.typewolf.com/google-fonts
wpEFormFonts.addItem('alegreya', {
    name: 'Alegreya',
    fontFamily: `'Alegreya', serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Alegreya:ital,wght@0,400;0,700;1,400;1,700&display=swap`,
});
wpEFormFonts.addItem('b612', {
    name: 'B612',
    fontFamily: `'B612', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=B612:ital,wght@0,400;0,700;1,400;1,700&display=swap`,
});
wpEFormFonts.addItem('titilliumweb', {
    name: 'Titillium Web',
    fontFamily: `'Titillium Web', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Titillium+Web:ital,wght@0,400;0,700;1,400;1,700&display=swap`,
});
wpEFormFonts.addItem('vollkorn', {
    name: 'Vollkorn',
    fontFamily: `'Vollkorn', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Vollkorn:ital,wght@0,400;0,700;1,400;1,700&display=swap`,
});
wpEFormFonts.addItem('ibmplexsans', {
    name: 'IBM Plex Sans',
    fontFamily: `'IBM Plex Sans', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap`,
});
wpEFormFonts.addItem('crimsontext', {
    name: 'Crimson Text',
    fontFamily: `'Crimson Text', serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&display=swap`,
});
wpEFormFonts.addItem('karla', {
    name: 'Karla',
    fontFamily: `'Karla', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Karla:ital,wght@0,400;0,700;1,400;1,700&display=swap`,
});
wpEFormFonts.addItem('lora', {
    name: 'Lora',
    fontFamily: `'Lora', serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&display=swap`,
});
wpEFormFonts.addItem('playfairdisplay', {
    name: 'Playfair Display',
    fontFamily: `'Playfair Display', serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,500;0,600;0,700;0,800;0,900;1,400;1,500;1,600;1,700;1,800;1,900&display=swap`,
});
wpEFormFonts.addItem('archivo', {
    name: 'Archivo',
    fontFamily: `'Archivo', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Archivo:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&display=swap`,
});
wpEFormFonts.addItem('spectral', {
    name: 'Spectral',
    fontFamily: `'Spectral', serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap`,
});
wpEFormFonts.addItem('roboto', {
    name: 'Roboto',
    fontFamily: `'Roboto', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap`,
});
wpEFormFonts.addItem('montserrat', {
    name: 'Montserrat',
    fontFamily: `'Montserrat', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap`,
});
wpEFormFonts.addItem('rubik', {
    name: 'Rubik',
    fontFamily: `'Rubik', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Rubik:ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap`,
});
wpEFormFonts.addItem('sourcesanspro', {
    name: 'Source Sans Pro',
    fontFamily: `'Source Sans Pro', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&display=swap`,
});
wpEFormFonts.addItem('cormorant', {
    name: 'Cormorant',
    fontFamily: `'Cormorant', serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Cormorant:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&display=swap`,
});
wpEFormFonts.addItem('worksans', {
    name: 'Work Sans',
    fontFamily: `'Work Sans', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Work+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap`,
});
wpEFormFonts.addItem('arvo', {
    name: 'Arvo',
    fontFamily: `'Arvo', serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Arvo:ital,wght@0,400;0,700;1,400;1,700&display=swap`,
});
wpEFormFonts.addItem('lato', {
    name: 'Lato',
    fontFamily: `'Lato', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&display=swap`,
});
wpEFormFonts.addItem('ubuntu', {
    name: 'Ubuntu',
    fontFamily: `'Ubuntu', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap`,
});
wpEFormFonts.addItem('ptserif', {
    name: 'PT Serif',
    fontFamily: `'PT Serif', serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=PT+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap`,
});
wpEFormFonts.addItem('ptsans', {
    name: 'PT Sans',
    fontFamily: `'PT Sans', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=PT+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap`,
});
wpEFormFonts.addItem('poppins', {
    name: 'Poppins',
    fontFamily: `'Poppins', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap`,
});
wpEFormFonts.addItem('firasans', {
    name: 'Fira Sans',
    fontFamily: `'Fira Sans', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Fira+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap`,
});
wpEFormFonts.addItem('nunito', {
    name: 'Nunito',
    fontFamily: `'Nunito', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200;0,300;0,400;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,600;1,700;1,800;1,900&display=swap`,
});
wpEFormFonts.addItem('exo2', {
    name: 'Exo 2',
    fontFamily: `'Exo 2', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Exo+2:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap`,
});
wpEFormFonts.addItem('opensans', {
    name: 'Open Sans',
    fontFamily: `'Open Sans', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;0,800;1,300;1,400;1,600;1,700;1,800&display=swap`,
});
wpEFormFonts.addItem('merriweather', {
    name: 'Merriweather',
    fontFamily: `'Merriweather', serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&display=swap`,
});
wpEFormFonts.addItem('notosans', {
    name: 'Noto Sans',
    fontFamily: `'Noto Sans', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap`,
});
wpEFormFonts.addItem('spacemono', {
    name: 'Space Mono',
    fontFamily: `'Space Mono', monospace`,
    enqueue: `https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap`,
});
wpEFormFonts.addItem('librefranklin', {
    name: 'Libre Franklin',
    fontFamily: `'Libre Franklin', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Libre+Franklin:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap`,
});
wpEFormFonts.addItem('alegreyasans', {
    name: 'Alegreya Sans',
    fontFamily: `'Alegreya Sans', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Alegreya+Sans:ital,wght@0,100;0,300;0,400;0,500;0,700;0,800;0,900;1,100;1,300;1,400;1,500;1,700;1,800;1,900&display=swap`,
});
wpEFormFonts.addItem('chivo', {
    name: 'Chivo',
    fontFamily: `'Chivo', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Chivo:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&display=swap`,
});
wpEFormFonts.addItem('sourceserifpro', {
    name: 'Source Serif Pro',
    fontFamily: `'Source Serif Pro', serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Source+Serif+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&display=swap`,
});
wpEFormFonts.addItem('archivonarrow', {
    name: 'Archivo Narrow',
    fontFamily: `'Archivo Narrow', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Archivo+Narrow:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&display=swap`,
});
wpEFormFonts.addItem('prozalibre', {
    name: 'Proza Libre',
    fontFamily: `'Proza Libre', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Proza+Libre:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&display=swap`,
});
wpEFormFonts.addItem('cabin', {
    name: 'cabin',
    fontFamily: `'Cabin', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Cabin:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&display=swap`,
});
wpEFormFonts.addItem('raleway', {
    name: 'Raleway',
    fontFamily: `'Raleway', sans-serif`,
    enqueue: `https://fonts.googleapis.com/css2?family=Raleway:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap`,
});
wpEFormFonts.addItem('anonymouspro', {
    name: 'Anonymous Pro',
    fontFamily: `'Anonymous Pro', monospace`,
    enqueue: `https://fonts.googleapis.com/css2?family=Anonymous+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap`,
});
/**
 * Get font family and enqueue from an item in the collection. It safely
 * falls back to inherit and null if the item isn't present.
 *
 * @param item The item from the collection.
 */
function getFontFamilyAndEnqueue(item) {
    if (!wpEFormFonts.hasItem(item)) {
        return ['inherit', null];
    }
    const fontItem = wpEFormFonts.getItem(item);
    return [fontItem.fontFamily, fontItem.enqueue];
}

const planAccessor = {
    starter: 'Starter',
    professional: 'Professional',
    business: 'Business',
};
function fsIsPlanOrHigher(plan) {
    if (!plan) {
        return true;
    }
    const accessor = `isPlan${planAccessor[plan]}OrHigher`;
    return typeof WPEFormGraphQLApp !== 'undefined'
        ? WPEFormGraphQLApp.freemius[accessor]
            ? !!WPEFormGraphQLApp.freemius[accessor]
            : false
        : false;
}

const defaultTheme = wpEFormThemes.getItems()[0].item.config;
const overrideDarkModeContext = createContext(undefined);
function useOverrideDarkMode() {
    return useContext(overrideDarkModeContext);
}
function OverrideDarkModeProvider(props) {
    const { darkMode, children } = props;
    return (jsx(overrideDarkModeContext.Provider, Object.assign({ value: darkMode }, { children: children }), void 0));
}
/**
 * Get ThemeStyle from FormStylesInput.
 *
 * @param formStyle FormStyle as the GraphQL Input.
 * @returns ThemeStyle for use with ThemedContainer.
 */
function getThemeStyleFromFormStyle(formStyle) {
    return {
        scheme: formStyle?.theme?.scheme,
        baseFont: formStyle?.typography?.baseFont,
        boldHeading: formStyle?.typography?.headFontBold,
        italicHeading: formStyle?.typography?.headFontItalic,
        headFamily: formStyle?.typography?.headFamily,
        headFamilyCustom: formStyle?.typography?.headFamilyCustom,
        bodyFamily: formStyle?.typography?.bodyFamily,
        bodyFamilyCustom: formStyle?.typography?.bodyFamilyCustom,
        customPrimaryColor: formStyle?.theme?.customColorPrimary,
        customSecondaryColor: formStyle?.theme?.customColorSecondary,
        customBackgroundColor: formStyle?.theme?.customColorBg,
        customTextColor: formStyle?.theme?.customColorText,
        css: formStyle?.theme?.css,
        maxWidth: formStyle?.appearance?.maxWidth,
        containerLayout: formStyle?.appearance?.containerLayout,
        darkMode: formStyle?.theme?.darkMode,
    };
}
/**
 * Get memoized ThemeStyle object from a formStyle input.
 *
 * @param formStyle Form styles as we have got from GraphQL.
 * @returns A ThemeStyle compatible object.
 */
function useThemeStyleFromFormStyle(formStyle) {
    return useMemo(() => getThemeStyleFromFormStyle(formStyle), [formStyle]);
}
function useFormTheme(styles) {
    const [userPrefersDark, setUserPrefersDark] = useState$1(() => {
        {
            // FS:PREMIUM-ONLY-START
            if (fsIsPlanOrHigher('starter')) {
                return typeof window !== 'undefined'
                    ? window.matchMedia &&
                        window.matchMedia('(prefers-color-scheme: dark)').matches
                    : false;
            }
            // FS:PREMIUM-ONLY-END
        }
        return false;
    });
    useEffect(() => {
        {
            // FS:PREMIUM-ONLY-START
            if (fsIsPlanOrHigher('starter')) {
                if (typeof window === 'undefined') {
                    return () => { };
                }
                const handler = (e) => {
                    setUserPrefersDark(e.matches);
                };
                // add event listener
                const listener = window.matchMedia('(prefers-color-scheme: dark)');
                listener.addEventListener('change', handler);
                return () => {
                    listener.removeEventListener('change', handler);
                };
            }
            // FS:PREMIUM-ONLY-END
        }
        return () => { };
    }, []);
    const overrideDarkMode = useOverrideDarkMode();
    return useMemo(() => {
        const { baseFont, bodyFamily, boldHeading, customBackgroundColor, customPrimaryColor, customSecondaryColor, customTextColor, headFamily, italicHeading, scheme, darkMode, } = styles ?? {};
        let customTheme = deepCopyWithJson(defaultTheme);
        // get scheme from collection
        if (scheme) {
            if (wpEFormThemes.hasItem(scheme)) {
                customTheme = deepCopyWithJson(wpEFormThemes.getItem(scheme).config);
            }
        }
        // adjust font sizes
        if (baseFont && baseFont !== 16 && baseFont >= 12) {
            customTheme = {
                ...customTheme,
                controlHeightBase: getNextEvenNumber(baseFont * 2.5),
                borderRadiusBase: getNextEvenNumber(baseFont * 0.25),
                gutter: Math.min(Math.max(getNextEvenNumber(baseFont * 1.25), 10), 40),
                fz: {
                    small2: Math.ceil(baseFont * 0.75),
                    small1: Math.ceil(baseFont * 0.875),
                    base: baseFont,
                    large1: Math.ceil(baseFont * 1.125),
                    large2: Math.ceil(baseFont * 1.25),
                    large3: Math.ceil(baseFont * 1.5),
                    large4: Math.ceil(baseFont * 1.875),
                    large5: Math.ceil(baseFont * 2.25),
                    large6: Math.ceil(baseFont * 3),
                    large7: Math.ceil(baseFont * 3.75),
                    large8: Math.ceil(baseFont * 4.5),
                },
            };
        }
        const fontEnqueues = [];
        // adjust font, bold and italic
        customTheme.boldHeading = !!boldHeading;
        customTheme.italicHeading = !!italicHeading;
        if (headFamily) {
            let family = 'inherit';
            if (headFamily === 'custom') {
                family = styles?.headFamilyCustom ?? 'inherit';
            }
            else {
                const [fontFamily, enqueue] = getFontFamilyAndEnqueue(headFamily);
                family = fontFamily;
                if (enqueue) {
                    fontEnqueues.push(enqueue);
                }
            }
            customTheme.fontFamilyHeading = family;
        }
        if (bodyFamily) {
            let family = 'inherit';
            if (bodyFamily === 'custom') {
                family = styles?.bodyFamilyCustom ?? 'inherit';
            }
            else {
                const [fontFamily, enqueue] = getFontFamilyAndEnqueue(bodyFamily);
                family = fontFamily;
                if (enqueue) {
                    fontEnqueues.push(enqueue);
                }
            }
            customTheme.fontFamilyBody = family;
        }
        // add dark mode if needed
        let isDarkMode = false;
        {
            // FS:PREMIUM-ONLY-START
            if (fsIsPlanOrHigher('starter')) {
                if (overrideDarkMode !== false &&
                    ((userPrefersDark && darkMode === DarkThemeModeEnum.AUTO) ||
                        darkMode === DarkThemeModeEnum.ALWAYS ||
                        overrideDarkMode === true)) {
                    if (customTheme.dark) {
                        isDarkMode = true;
                        customTheme = {
                            ...customTheme,
                            // override whatever dark mode has to offer
                            ...customTheme.dark,
                        };
                    }
                }
            }
            // FS:PREMIUM-ONLY-END
        }
        const darker = isDarkMode ? curriedLighten : curriedDarken;
        const lighter = isDarkMode ? curriedDarken : curriedLighten;
        if (customPrimaryColor) {
            customTheme.primaryColor = customPrimaryColor;
            customTheme.primaryDarkColor = darker(0.1, customPrimaryColor);
            customTheme.primaryLightColor = lighter(0.1, customPrimaryColor);
            customTheme.accentColor = complement(customPrimaryColor);
            customTheme.primaryBgText = curriedLighten(0.7, customPrimaryColor);
            customTheme.primaryBackgroundColor = lighter(0.6, customPrimaryColor);
            customTheme.linkColor = customPrimaryColor;
            customTheme.boxShadowFocus = `0 0 0 2px ${curriedTransparentize(0.5, customPrimaryColor)}`;
            // 12 is the small2 font size
            customTheme.boxShadowControlFocus = `0 0 0 ${numToCssSize(12 / 4)} ${curriedTransparentize(0.8, customPrimaryColor)}`;
        }
        if (customSecondaryColor) {
            customTheme.borderColorBase = customSecondaryColor;
            customTheme.borderColorSplit = lighter(0.1, customSecondaryColor);
            customTheme.disabledColor = lighter(0.28, customSecondaryColor);
            customTheme.disabledBackgroundColor = lighter(0.45, customSecondaryColor);
            customTheme.backgroundControl = lighter(0.44, customSecondaryColor);
            console.log(customTheme.backgroundControl);
            customTheme.backgroundShade = curriedDesaturate(0.01, lighter(0.4, customSecondaryColor));
            customTheme.backgroundHover = curriedDesaturate(0.01, lighter(0.42, customSecondaryColor));
        }
        if (customBackgroundColor) {
            customTheme.appBackgroundColor = customBackgroundColor;
        }
        if (customTextColor) {
            customTheme.textColor = customTextColor;
            customTheme.textColorSecondary = lighter(0.4, customTextColor);
            customTheme.headingColor = lighter(0.1, customTextColor);
        }
        return [customTheme, deDupArray(fontEnqueues)];
    }, [styles, userPrefersDark, overrideDarkMode]);
}

// A helper for rendering stylesheet when doing SSR
// Forked From ReactShadow
// https://github.com/Wildhoney/ReactShadow/blob/af122b1a587969e4ea246baf1ec09b058d0fa9fe/src/styled-components/index.js#L6
function getStyleSheets(children) {
    const sheet = new ServerStyleSheet();
    let elements;
    try {
        renderToString(jsx(StyleSheetManager, Object.assign({ sheet: sheet.instance }, { children: jsx(Fragment, { children: children }, void 0) }), void 0));
        elements = sheet.getStyleElement();
    }
    catch (e) {
        console.log(e);
        elements = null;
    }
    finally {
        sheet.seal();
    }
    return elements;
}
function ThemeContainerChildren(props) {
    const { children, ssr, mode, themeStyle, widthOverride, containerLayoutOverride, theme, } = props;
    return (jsx(ThemeProvider, Object.assign({ theme: theme }, { children: ssr ? (jsx(ResponsiveContainer.Ssr, Object.assign({ width: widthOverride ?? themeStyle?.maxWidth, containerLayout: containerLayoutOverride ?? themeStyle?.containerLayout, noHorizontalPadding: mode === 'preview', noVerticalPadding: mode === 'preview' }, { children: children }), void 0)) : (jsx(ResponsiveContainer, Object.assign({ width: widthOverride ?? themeStyle?.maxWidth, containerLayout: containerLayoutOverride ?? themeStyle?.containerLayout, noHorizontalPadding: mode === 'preview', noVerticalPadding: mode === 'preview' }, { children: children }), void 0)) }), void 0));
}
function LocalizedStyledManager(props) {
    const { children } = props;
    const target = useScSlot();
    return (jsx(StyleSheetManager, Object.assign({ target: target }, { children: jsx(Fragment, { children: children }, void 0) }), void 0));
}
/**
 * ThemedContainer component encapsulates themeStyle rendering along with a
 * observed responsive container.
 */
function ThemedContainer(props) {
    const { mode, themeStyle, ssr = false } = props;
    const [theme, enqueues] = useFormTheme(themeStyle);
    const css = themeStyle?.css;
    const inShadow = useIsShadow();
    useEffect(() => {
        if (inShadow) {
            if (typeof window !== 'undefined' && enqueues && enqueues.length) {
                enqueues.forEach(href => {
                    const id = slugify(href);
                    if (!document.head.querySelector(`#${id}`)) {
                        const linkTag = document.createElement('link');
                        linkTag.setAttribute('href', href);
                        linkTag.setAttribute('id', id);
                        linkTag.setAttribute('rel', 'stylesheet');
                        document.head.append(linkTag);
                    }
                });
            }
        }
    }, [enqueues, inShadow]);
    const renderChildren = jsx(ThemeContainerChildren, Object.assign({ theme: theme }, props), void 0);
    // lazy load injecting custom style sheets because we don't want
    // errors in rehydration
    const [injectCustomStyles, setInjectCustomStyles] = useState$1(false);
    useEffect(() => {
        setInjectCustomStyles(true);
    }, []);
    return (jsxs(Fragment, { children: [inShadow && injectCustomStyles
                ? enqueues.map(e => jsx("link", { rel: "stylesheet", href: e }, e))
                : null, css && mode === 'live' ? (
            // eslint-disable-next-line react/no-danger
            jsx("style", { type: "text/css", dangerouslySetInnerHTML: { __html: css } }, void 0)) : null, ssr ? (jsxs(Fragment, { children: [getStyleSheets(renderChildren), jsx("div", Object.assign({ className: "wpeform-root-slot__react-app" }, { children: renderChildren }), void 0)] }, void 0)) : (jsx(LocalizedStyledManager, { children: renderChildren }, void 0))] }, void 0));
}

const CONTROLCLASS$o = 'wpeform-component-skeleton';
const SKELETONCLASS = getBemElement(CONTROLCLASS$o, 'gutter');
const Gutter = styled.div `
	${cssReset};
	&.${CONTROLCLASS$o}--large {
		margin-bottom: ${props => numToCssSize(props.theme.gutter)};
	}
	&.${CONTROLCLASS$o}--small {
		margin-bottom: ${props => numToCssSize(props.theme.gutter / 2)};
	}
	&.${CONTROLCLASS$o}--para {
		margin-bottom: ${props => numToCssSize(props.theme.fz.base * 0.75)};
	}
	&.${CONTROLCLASS$o}--h1 {
		margin-bottom: ${props => numToCssSize(props.theme.fz.large5 * 1.5 * 0.6)};
	}
	&.${CONTROLCLASS$o}--h2 {
		margin-bottom: ${props => numToCssSize(props.theme.fz.large3 * 1.5 * 0.6)};
	}
	&.${CONTROLCLASS$o}--h3 {
		margin-bottom: ${props => numToCssSize(props.theme.fz.large2 * 1.5 * 0.6)};
	}
	&.${CONTROLCLASS$o}--h4 {
		margin-bottom: ${props => numToCssSize(props.theme.fz.base * 1.5 * 0.6)};
	}
	&.${CONTROLCLASS$o}--h5 {
		margin-bottom: ${props => numToCssSize(props.theme.fz.small1 * 1.5 * 0.6)};
	}
	&.${CONTROLCLASS$o}--h6 {
		margin-bottom: ${props => numToCssSize(props.theme.fz.small2 * 1.5 * 0.6)};
	}
	&.${CONTROLCLASS$o}--mb {
		margin-bottom: ${props => numToCssSize(props.marginBottom ?? 0)};
	}
	&:last-child {
		margin-bottom: 0;
	}
	&.${CONTROLCLASS$o}--inline {
		display: inline-block;
		margin-left: 0.25em;
		margin-right: 0.25em;
		vertical-align: middle;
		&:first-child {
			margin-left: 0;
		}
		&:last-child {
			margin-right: 0;
		}
	}
`;
const animation = keyframes `
	0% {
		background-position: 100% 50%;
	}

	100% {
		background-position: 0 50%;
	}
`;
const SkeletonContainer$2 = styled.div `
	background-image: linear-gradient(
		90deg,
		${props => curriedDarken(0.01, props.theme.backgroundControl)} 25%,
		${props => curriedDarken(0.05, props.theme.backgroundControl)} 37%,
		${props => curriedDarken(0.01, props.theme.backgroundControl)} 63%
	);
	background-size: 400% 100%;
	animation: ${animation} 1.4s ease infinite;
	will-change: background-position;
	&.${SKELETONCLASS}--shape-rectangle {
		border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	}
	&.${SKELETONCLASS}--shape-circle {
		border-radius: 50%;
	}
	max-width: 100%;
	&.${SKELETONCLASS}--color-darker {
		background-image: linear-gradient(
			90deg,
			${props => curriedDarken(0.03, props.theme.backgroundControl)} 25%,
			${props => curriedDarken(0.08, props.theme.backgroundControl)} 37%,
			${props => curriedDarken(0.03, props.theme.backgroundControl)} 63%
		);
	}
	&.${SKELETONCLASS}--inline {
		display: inline-block;
		vertical-align: middle;
	}
`;
function Skeleton(props) {
    const { height, shape, width, className, marginBottom, color = 'normal', inline = false, } = props;
    const containerClassModifiers = {};
    if (typeof marginBottom === 'string') {
        containerClassModifiers[`${marginBottom}`] = true;
    }
    else if (typeof marginBottom === 'number') {
        containerClassModifiers.mb = true;
    }
    containerClassModifiers.inline = inline;
    const containerClass = getBemClassName(CONTROLCLASS$o, containerClassModifiers, className);
    const skeletonClass = getBemClassName(SKELETONCLASS, {
        [`shape-${shape}`]: true,
        [`color-${color}`]: true,
        inline,
    }, className);
    return (jsx(Gutter, Object.assign({ className: containerClass, marginBottom: typeof marginBottom === 'number' ? marginBottom : undefined }, { children: jsx(SkeletonContainer$2, { className: skeletonClass, style: {
                width: typeof width === 'number' ? numToCssSize(width) : width,
                height: typeof height === 'number' ? numToCssSize(height) : height,
            } }, void 0) }), void 0));
}
function Paragraph(props) {
    const theme = useTheme();
    const { width, className, marginBottom, inline } = props;
    return (jsx(Skeleton, { marginBottom: typeof marginBottom === 'number' ? marginBottom : 'para', width: width, height: theme.fz.base * 1.5, shape: "rectangle", className: className, inline: inline }, void 0));
}
function Heading$1(props) {
    const theme = useTheme();
    const { width, level, className, marginBottom } = props;
    let height = theme.fz.large5 * 1.5;
    if (level === 2) {
        height = theme.fz.large3 * 1.5;
    }
    else if (level === 3) {
        height = theme.fz.large2 * 1.5;
    }
    else if (level === 4) {
        height = theme.fz.large1 * 1.5;
    }
    else if (level === 5) {
        height = theme.fz.small1 * 1.5;
    }
    else if (level === 6) {
        height = theme.fz.small2 * 1.5;
    }
    return (jsx(Skeleton, { marginBottom: typeof marginBottom === 'number' ? marginBottom : `h${level}`, width: width, height: height, shape: "rectangle", className: className }, void 0));
}
function Avatar(props) {
    return jsx(Skeleton, Object.assign({}, props, { width: props.height, shape: "circle" }), void 0);
}
function Checkbox$1(props) {
    const { className } = props;
    const theme = useTheme();
    const height = getNextEvenNumber(theme.controlHeightBase * 0.7);
    return (jsx(Skeleton, { height: height, width: height, className: className, shape: "rectangle" }, void 0));
}
function Radio$1(props) {
    const { className } = props;
    const theme = useTheme();
    const height = getNextEvenNumber(theme.controlHeightBase * 0.7);
    return (jsx(Skeleton, { height: height, width: height, className: className, shape: "circle" }, void 0));
}
const MCQContainer = styled.div `
	display: flex;
	flex-flow: row nowrap;
	align-items: center;
	justify-content: flex-start;
`;
const MCQControl = styled.div `
	flex: 0 0
		${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7))};
	margin: 0 ${props => numToCssSize(props.theme.gutter / 2)} 0 0;
`;
const MCQLabel = styled.div `
	flex: 1 0 auto;
`;
const MCQOPTIONCLASS = getBemElement(CONTROLCLASS$o, 'mcq-option');
function MCQOption(props) {
    const theme = useTheme();
    const { className, type, width } = props;
    const labelHeight = theme.fz.base;
    return (jsxs(MCQContainer, Object.assign({ className: getBemClassName(MCQOPTIONCLASS, { [`type-${type}`]: true }, className) }, { children: [jsx(MCQControl, { children: type === 'radio' ? jsx(Radio$1, {}, void 0) : jsx(Checkbox$1, {}, void 0) }, void 0), jsx(MCQLabel, { children: jsx(Skeleton, { shape: "rectangle", height: labelHeight, width: width }, void 0) }, void 0)] }), void 0));
}
const LABELCLASS$1 = getBemElement(CONTROLCLASS$o, 'label');
const LabelContainer = styled.div `
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
`;
function Label$3(props) {
    const theme = useTheme();
    const { titleWidth, subtitleWidth, className } = props;
    return (jsxs(LabelContainer, Object.assign({ className: getBemClassName(LABELCLASS$1, undefined, className) }, { children: [jsx(Paragraph, { width: titleWidth, marginBottom: theme.gutter / 4 }, void 0), jsx(Heading$1, { width: subtitleWidth, marginBottom: theme.fz.base - theme.fz.small2, level: 6 }, void 0)] }), void 0));
}
function Text$3(props) {
    const theme = useTheme();
    return (jsx(Skeleton, Object.assign({ height: theme.controlHeightBase, shape: "rectangle", width: "100%" }, props), void 0));
}
function Textarea$1(props) {
    const theme = useTheme();
    return (jsx(Skeleton, Object.assign({ height: theme.controlHeightBase * 4, shape: "rectangle", width: "100%" }, props), void 0));
}
Skeleton.Paragraph = Paragraph;
Skeleton.Heading = Heading$1;
Skeleton.Avatar = Avatar;
Skeleton.Checkbox = Checkbox$1;
Skeleton.Radio = Radio$1;
Skeleton.Text = Text$3;
Skeleton.Textarea = Textarea$1;
Skeleton.MCQOption = MCQOption;
Skeleton.Label = Label$3;

const CONTROLCLASS$n = 'wpeform-component-grid';
const GridContainer = styled.div `
	${cssReset};
	padding: ${props => numToCssSize(props.theme.gutter * 0.75)};
	&.${CONTROLCLASS$n}--no-padding {
		padding: 0;
		margin: ${props => numToCssSize(props.theme.gutter * -0.75)};
		margin-bottom: 0;
	}
`;
const GridContainerInner = styled.div `
	margin: 0;
	display: flex;
	flex-flow: row wrap;
`;
/**
 * A Grid component for layout. Use it with conjunction with `Grid.Item` and
 * pass widths and initialWidths to `Grid.Item`. Make sure to put Grid inside
 * a `ResponsiveContainer` component, else the responsiveness will not work.
 *
 * #### `Grid.Item`
 *
 * Compose Grid with this component for responsiveness. It accepts the following
 * props.
 *
 * ```ts
 * type Width {
 * 	containerMinWidth: number;
 * 	elementWidth: string;
 * }
 * ```
 *
 * | Prop name | Type | Default | Description |
 * | --------- | ---- | ------- | ----------- |
 * | **basicWidth** | `string` | 100% | Basic Width of the GridItem. |
 * | **widths** | `Width[]` | Required | Widths configuration of the Grid Item. This is same as Appearance config of EForm elements. |
 * | **children** | `ReactNode` | Required | Children of Grid Item. |
 * | **className** | `string | undefined` |  | Additional className. |
 *
 * **Example Usage**
 *
 * <Grid>
 * 	<Grid.Item>
 * 		<Grid.Gutter>
 * 			<SomeComponent />
 * 		</Grid.Gutter>
 * 	</Grid.Item>
 * 	<Grid.Item>
 * 		<Grid.Gutter>
 * 			<SomeComponent />
 * 		</Grid.Gutter>
 * 	</Grid.Item>
 * 	<Grid.Item>
 * 		<Grid.Gutter>
 * 			<SomeComponent />
 * 		</Grid.Gutter>
 * 	</Grid.Item>
 * 	<Grid.Item>
 * 		<Grid.Gutter>
 * 			<SomeComponent />
 * 		</Grid.Gutter>
 * 	</Grid.Item>
 * </Grid>
 */
function Grid(props) {
    const { className, children, noPadding = false } = props;
    return (jsx(GridContainer, Object.assign({ className: getBemClassName(CONTROLCLASS$n, { 'no-padding': noPadding }, className) }, { children: jsx(GridContainerInner, { children: children }, void 0) }), void 0));
}
const GRIDITEMCONTROLCLASS = getBemElement(CONTROLCLASS$n, 'item');
const GridItemContainer = styled.div `
	flex: 0 0 ${props => props.width};
	width: ${props => props.width};
	max-width: 100%;
	box-shadow: 0 0 0 0 ${props => curriedTransparentize(1, props.theme.primaryColor)},
		0 0 0 1px ${props => curriedTransparentize(1, props.theme.primaryColor)};
	transition: ${props => getMultipleTransitionsWithWillChange(['box-shadow'], props.theme.transitionControl)};
	&:focus {
		box-shadow: 0 0 0 4px
				${props => curriedTransparentize(0.85, props.theme.primaryColor)},
			0 0 0 1px ${props => props.theme.primaryColor};
		border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
		outline: none;
	}
`;
function getConfigForWidthsPreset(preset, theme) {
    const config = {
        basicWidth: '100%',
        widths: [],
    };
    if (preset === WidthPresetsEnum.HALF) {
        config.widths = [
            {
                containerMinWidth: theme.breakpoints.tablet - theme.gutter * 2,
                elementWidth: '50%',
            },
            {
                containerMinWidth: theme.breakpoints.desktop - theme.gutter * 2,
                elementWidth: '50%',
            },
            {
                containerMinWidth: theme.breakpoints.desktopHd - theme.gutter * 2,
                elementWidth: '50%',
            },
        ];
    }
    else if (preset === WidthPresetsEnum.ONEFOURTH) {
        config.widths = [
            {
                containerMinWidth: theme.breakpoints.tablet - theme.gutter * 2,
                elementWidth: '25%',
            },
            {
                containerMinWidth: theme.breakpoints.desktop - theme.gutter * 2,
                elementWidth: '25%',
            },
            {
                containerMinWidth: theme.breakpoints.desktopHd - theme.gutter * 2,
                elementWidth: '25%',
            },
        ];
    }
    else if (preset === WidthPresetsEnum.ONETHIRD) {
        config.widths = [
            {
                containerMinWidth: theme.breakpoints.tablet - theme.gutter * 2,
                elementWidth: '33.333333%',
            },
            {
                containerMinWidth: theme.breakpoints.desktop - theme.gutter * 2,
                elementWidth: '33.333333%',
            },
            {
                containerMinWidth: theme.breakpoints.desktopHd - theme.gutter * 2,
                elementWidth: '33.333333%',
            },
        ];
    }
    else if (preset === WidthPresetsEnum.THREEFOURTH) {
        config.widths = [
            {
                containerMinWidth: theme.breakpoints.tablet - theme.gutter * 2,
                elementWidth: '75%',
            },
            {
                containerMinWidth: theme.breakpoints.desktop - theme.gutter * 2,
                elementWidth: '75%',
            },
            {
                containerMinWidth: theme.breakpoints.desktopHd - theme.gutter * 2,
                elementWidth: '75%',
            },
        ];
    }
    else if (preset === WidthPresetsEnum.TWOTHIRD) {
        config.widths = [
            {
                containerMinWidth: theme.breakpoints.tablet - theme.gutter * 2,
                elementWidth: '66.66666%',
            },
            {
                containerMinWidth: theme.breakpoints.desktop - theme.gutter * 2,
                elementWidth: '66.66666%',
            },
            {
                containerMinWidth: theme.breakpoints.desktopHd - theme.gutter * 2,
                elementWidth: '66.66666%',
            },
        ];
    }
    return config;
}
function GridItem(props, ref) {
    const { children, className, columnSize = WidthPresetsEnum.FULL, basicWidth = '100%', widths = [], tabIndex, } = props;
    const size = useContainerSize();
    const theme = useTheme();
    let width;
    if (columnSize === WidthPresetsEnum.MANUAL) {
        width = basicWidth;
        widths.forEach(w => {
            if (size.width >= w.containerMinWidth) {
                width = w.elementWidth;
            }
        });
    }
    else {
        const { basicWidth: pBasicWidth, widths: pWidths = [] } = getConfigForWidthsPreset(columnSize, theme);
        width = pBasicWidth;
        pWidths.forEach(w => {
            if (size.width >= w.containerMinWidth) {
                width = w.elementWidth;
            }
        });
    }
    return (jsx(GridItemContainer, Object.assign({ className: classNames(GRIDITEMCONTROLCLASS, className), width: width, ref: ref, tabIndex: tabIndex }, { children: children }), void 0));
}
// Make Grid a compound component
Grid.Item = forwardRef(GridItem);
const GridGutter = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter * (props.dense ? 0.5 : 0.75))};
`;
Grid.Gutter = GridGutter;
const GridNegateGutter = styled.div `
	margin-left: ${props => numToCssSize(props.theme.gutter * -0.75 * 2)};
	margin-right: ${props => numToCssSize(props.theme.gutter * -0.75 * 2)};
	margin-top: ${props => props.vertical ? numToCssSize(props.theme.gutter * -0.75 * 2) : 0};
	margin-bottom: ${props => props.vertical ? numToCssSize(props.theme.gutter * -0.75 * 2) : 0};
`;
Grid.NegateGutter = GridNegateGutter;
const GridBottomMargin = styled.div `
	margin-bottom: ${props => numToCssSize(props.theme.gutter * 0.75 * 2)};
`;
Grid.Bottom = GridBottomMargin;
const GridNegateVerticalGutter = styled.div `
	margin-top: ${props => numToCssSize(props.theme.gutter * -0.75 * 2)};
	margin-bottom: ${props => numToCssSize(props.theme.gutter * -0.75 * 2)};
`;
Grid.NegateVerticalGutter = GridNegateVerticalGutter;

const SlateMediaContainer$1 = styled.div `
	border: 2px solid;
	border-color: ${props => props.active ? props.theme.primaryDarkColor : props.theme.borderColorBase};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	padding: ${props => numToCssSize(props.theme.gutter / 4)};
	margin-top: ${props => numToCssSize(props.theme.gutter / 2)};
	margin-bottom: ${props => numToCssSize(props.theme.gutter / 2)};
	margin-right: ${props => props.align === 'left'
    ? numToCssSize(props.theme.gutter / 2)
    : props.align === 'center'
        ? 'auto'
        : 0};
	margin-left: ${props => props.align === 'right'
    ? numToCssSize(props.theme.gutter / 2)
    : props.align === 'center'
        ? 'auto'
        : 0};
	float: ${props => props.align === 'left'
    ? 'left'
    : props.align === 'right'
        ? 'right'
        : 'none'};
	clear: ${props => props.align === 'left'
    ? 'right'
    : props.align === 'right'
        ? 'left'
        : 'both'};
	width: ${props => props.width};
	max-width: 100%;
	min-width: 150px;

	img,
	iframe,
	video,
	audio {
		width: 100%;
		max-width: 100%;
		margin: 0;
		display: block;
		min-height: 150px;
		border: 1px solid ${props => props.theme.borderColorSplit};
		border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	}
	audio {
		min-height: auto;
		height: 50px;
	}
	img {
		height: auto;
		min-height: auto;
	}
`;
styled.div `
	position: relative;
`;
styled.div `
	display: flex;
	flex-flow: row wrap;
	align-items: flex-start;
	justify-content: flex-end;
	position: absolute;
	z-index: 1;
	top: 0;
	left: 0;
	height: 100%;
	width: 100%;
	background-color: rgba(255, 255, 255, 0);
	will-change: background-color;
	transition: background-color ${props => props.theme.transition};
	&:hover,
	&.active {
		background-color: rgba(255, 255, 255, 0.9);
	}
	button {
		margin: ${props => numToCssSize(props.theme.gutter / 4)};
		margin-left: 0;
	}
`;
const SlateMediaCaptionContainer = styled.div `
	margin: ${props => numToCssSize(props.theme.gutter / 4)} 0 0 0;
	position: relative;
	text-align: center;
	font-weight: 300;
	font-style: italic;
	&:empty {
		&::before {
			content: '${__('caption…', 'wp-eform')}';
			display: block;
			color: ${props => props.theme.textColorSecondary};
			width: 100%;
			left: 0;
			white-space: pre;
			overflow: hidden;
			text-overflow: ellipsis;
			cursor: text;
			user-select: none;
			text-align: center;
		}
	}
`;

const SlateMediaContainer = styled(SlateMediaContainer$1) `
	border-width: 1px;
	audio,
	img,
	video,
	iframe {
		border: 0 none;
	}
`;
function Media({ element }) {
    const { src, alt, align, height, width, mediaType, caption } = element;
    let mainPreview;
    // embeds first
    if (mediaType === 'youtube' ||
        mediaType === 'vimeo' ||
        mediaType === 'dailymotion' ||
        mediaType === 'wistia') {
        mainPreview = (jsx("iframe", { title: alt, src: src, frameBorder: "0", height: height, allow: "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture", allowFullScreen: true }, void 0));
    }
    else if (mediaType === 'audio') {
        mainPreview = jsx("audio", { src: src, controls: true, title: alt }, void 0);
    }
    else if (mediaType === 'video') {
        mainPreview = jsx("video", { src: src, controls: true, title: alt, height: height }, void 0);
    }
    else {
        mainPreview = jsx("img", { src: src, alt: alt, height: height, width: width }, void 0);
    }
    return (jsxs(SlateMediaContainer, Object.assign({ align: align, width: width, active: false }, { children: [mainPreview, caption !== '' ? (jsx(SlateMediaCaptionContainer, { children: caption }, void 0)) : null] }), void 0));
}

const Latex = lazy(() => import('react-latex-next'));
const LatexContainer = styled.span `
	vertical-align: middle;
	margin-left: 0.25em;
	margin-right: 0.25em;
`;
function LatexRenderer({ element }) {
    return (jsx(LatexContainer, { children: jsx(Suspense, Object.assign({ fallback: jsx(Skeleton.Paragraph, { inline: true, width: "80px", marginBottom: 0 }, void 0) }, { children: jsx(Latex, { children: element.latex }, void 0) }), void 0) }, void 0));
}

const MentionsContainer = styled.span `
	background-color: ${props => props.empty ? props.theme.disabledBackgroundColor : 'transparent'};
	padding: 0 ${props => (props.empty ? '0.25em' : '0')};
	margin: 0 ${props => (props.empty ? '0.25em' : '0')};
	color: ${props => (props.empty ? props.theme.disabledColor : 'inherit')};
`;
const mentionsDataContext = createContext(() => {
    throw new Error('No mentions renderer found. Kindly use MentionsProvider within the app.');
});
function useMentionsData() {
    return useContext(mentionsDataContext);
}
function MentionsProvider(props) {
    const { mentions, children } = props;
    return (jsx(mentionsDataContext.Provider, Object.assign({ value: mentions }, { children: children }), void 0));
}
function MentionsRenderer({ element, additionalMentions, }) {
    const mentions = useMentionsData();
    let mention = mentions(element.character);
    if (mention === undefined || mention === null || mention === '') {
        if (additionalMentions && additionalMentions[element.character]) {
            mention = additionalMentions[element.character];
        }
    }
    return (jsx(MentionsContainer, Object.assign({ empty: mention !== undefined && mention !== null && mention !== ''
            ? false
            : true }, { children: mention !== undefined && mention !== null && mention !== ''
            ? mention
            : '…' }), void 0));
}

const CONTROLCLASS$m = 'wpeform-component-slateview';
const SlateViewContainer = styled.div `
	color: inherit;
	line-height: 1.5;
	${userInputWhiteSpace};

	/** INLINE VIEW */
	&.${CONTROLCLASS$m}--inline {
		display: inline;
		/** Just in case */
		> p:first-child,
		> blockquote:first-child {
			display: inline;
		}
	}

	${proseCss}
`;

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized$2(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var id = 0;

function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}

function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }

  return receiver;
}

var Pluggable = /*#__PURE__*/function () {
  /* istanbul ignore next */
  function Pluggable(augment) {
    if (augment === void 0) {
      augment = {};
    }

    Object.assign(this, augment);
  }

  Pluggable.load = function load(augment) {
    return new this(augment);
  };

  return Pluggable;
}();

var _errors = /*#__PURE__*/_classPrivateFieldLooseKey("errors");

var _shouldInvert = /*#__PURE__*/_classPrivateFieldLooseKey("shouldInvert");

var TinyCheckerBase = /*#__PURE__*/function (_Pluggable) {
  _inheritsLoose(TinyCheckerBase, _Pluggable);

  function TinyCheckerBase() {
    var _this;

    _this = _Pluggable.apply(this, arguments) || this;
    Object.defineProperty(_assertThisInitialized$2(_this), _errors, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(_assertThisInitialized$2(_this), _shouldInvert, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(_assertThisInitialized$2(_this), _errors)[_errors] = [];
    _classPrivateFieldLooseBase(_assertThisInitialized$2(_this), _shouldInvert)[_shouldInvert] = false;
    _this._str = "";
    /**
     * Internal function to be used by plugins for processing the return value
     * @param {boolean} value Return value of the check
     * @param {string} errorMessage Default error message for the check
     * @param {string} [replacer] Value to replace the $value placeholder in the errorMessage
     */

    _this._processValue = function (value, errorMessage, replacer) {
      var finalValue = _classPrivateFieldLooseBase(_assertThisInitialized$2(_this), _shouldInvert)[_shouldInvert] ? !value : value;
      var formattedErrorMessage = replacer != null ? errorMessage.replace("$value", replacer) : errorMessage;
      _classPrivateFieldLooseBase(_assertThisInitialized$2(_this), _errors)[_errors] = finalValue ? _classPrivateFieldLooseBase(_assertThisInitialized$2(_this), _errors)[_errors] : [].concat(_classPrivateFieldLooseBase(_assertThisInitialized$2(_this), _errors)[_errors], [formattedErrorMessage]);
      _classPrivateFieldLooseBase(_assertThisInitialized$2(_this), _shouldInvert)[_shouldInvert] = false;
      return _assertThisInitialized$2(_this);
    };
    /**
     * Sets the string to be checked
     * @param {string} str The string to be checked
     */


    _this.checkIf = function (str) {
      _this._str = str;
      _classPrivateFieldLooseBase(_assertThisInitialized$2(_this), _errors)[_errors] = [];
      _classPrivateFieldLooseBase(_assertThisInitialized$2(_this), _shouldInvert)[_shouldInvert] = false;
      return _assertThisInitialized$2(_this);
    };
    /**
     * Negates following check function
     */


    _this.not = function () {
      _classPrivateFieldLooseBase(_assertThisInitialized$2(_this), _shouldInvert)[_shouldInvert] = true;
      return _assertThisInitialized$2(_this);
    };
    /**
     * Check if string is valid
     * @returns {boolean} Result of the checks
     */


    _this.isValid = function () {
      return _classPrivateFieldLooseBase(_assertThisInitialized$2(_this), _errors)[_errors].length === 0;
    };
    /**
     * Check if string has errors
     * @returns {string[]} Array of the invalid error messages
     */


    _this.hasErrors = function () {
      return _classPrivateFieldLooseBase(_assertThisInitialized$2(_this), _errors)[_errors];
    };

    return _this;
  }

  return TinyCheckerBase;
}(Pluggable);

/**
 * Check if string contains digits
 * @param {number} atLeast Minimum amount of digits
 * @param {string} errorMessage Custom error message
 */
function hasDigit(atLeast, errorMessage) {
  if (atLeast === void 0) {
    atLeast = 1;
  }

  if (errorMessage === void 0) {
    errorMessage = "should have at least $value digit(s)";
  }

  return this._processValue((this._str.match(new RegExp(/\p{Nd}/, "gu")) || []).length >= atLeast, errorMessage, String(atLeast));
}

/**
 * Checks if string has exact length
 * @param {number} length Number of charaters
 * @param {string} errorMessage Custom error message
 */
function hasLength(length, errorMessage) {
  if (length === void 0) {
    length = 0;
  }

  if (errorMessage === void 0) {
    errorMessage = "should have exactly $value characters";
  }

  return this._processValue(this._str.length === length, errorMessage, String(length));
}

/**
 * Checks if string has minimum length of characters
 * @param {number} length Minimum number of charaters
 * @param {string} errorMessage Custom error message
 */
function hasMinLength(length, errorMessage) {
  if (length === void 0) {
    length = 1;
  }

  if (errorMessage === void 0) {
    errorMessage = "should have a minimum length of $value";
  }

  return this._processValue(this._str.length >= length, errorMessage, String(length));
}

/**
 * Checks if string has maximum length of characters
 * @param {number} length Maximum number of charaters
 * @param {string} errorMessage Custom error message
 */
function hasMaxLength(length, errorMessage) {
  if (length === void 0) {
    length = 1;
  }

  if (errorMessage === void 0) {
    errorMessage = "should have a maximum length of $value";
  }

  return this._processValue(this._str.length <= length, errorMessage, String(length));
}

/**
 * Check if string has minimum of lower case characters
 * @param {number} atLeast Minimium amount of lower case characters
 * @param {string} errorMessage Custom error message
 */
function hasLowerCase(atLeast, errorMessage) {
  if (atLeast === void 0) {
    atLeast = 1;
  }

  if (errorMessage === void 0) {
    errorMessage = "should have at least $value lowercase character(s)";
  }

  return this._processValue((this._str.match(new RegExp(/\p{Ll}/, "gu")) || []).length >= atLeast, errorMessage, String(atLeast));
}

/**
 * Check if string has minimum of upper case characters
 * @param {number} atLeast Minimium amount of upper case characters
 * @param {string} errorMessage Custom error message
 */
function hasUpperCase(atLeast, errorMessage) {
  if (atLeast === void 0) {
    atLeast = 1;
  }

  if (errorMessage === void 0) {
    errorMessage = "should have at least $value uppercase character(s)";
  }

  return this._processValue((this._str.match(new RegExp(/\p{Lu}/, "gu")) || []).length >= atLeast, errorMessage, String(atLeast));
}

/**
 * Checks if string is email format
 * @param {string} errorMessage Custom error message
 */
function isEmail(errorMessage) {
  if (errorMessage === void 0) {
    errorMessage = "should be a valid email address";
  }

  return this._processValue(this._str.match(new RegExp(/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/)) !== null, errorMessage);
}

/**
 * Checks if string matched a given regular expression
 * @param {string | RegExp} regex Regular expression
 * @param {string} errorMessage Custom error message
 */
function matches(regex, errorMessage) {
  if (errorMessage === void 0) {
    errorMessage = "should match the pattern";
  }

  return this._processValue(this._str.match(regex) !== null, errorMessage, String(regex));
}

var defaultValidators = {
  hasDigit: hasDigit,
  hasLength: hasLength,
  hasMinLength: hasMinLength,
  hasMaxLength: hasMaxLength,
  hasLowerCase: hasLowerCase,
  hasUpperCase: hasUpperCase,
  isEmail: isEmail,
  matches: matches
};
var TinyChecker = /*#__PURE__*/TinyCheckerBase.load(defaultValidators); // Export main function to use in client

var checkIf = TinyChecker.checkIf;

function n(n){for(var t=arguments.length,r=Array(t>1?t-1:0),e=1;e<t;e++)r[e-1]=arguments[e];throw Error("[Immer] minified error nr: "+n+(r.length?" "+r.map((function(n){return "'"+n+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function t(n){return !!n&&!!n[Q]}function r(n){return !!n&&(function(n){if(!n||"object"!=typeof n)return !1;var t=Object.getPrototypeOf(n);if(null===t)return !0;var r=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return r===Object||"function"==typeof r&&Function.toString.call(r)===Z}(n)||Array.isArray(n)||!!n[L]||!!n.constructor[L]||s(n)||v(n))}function i(n,t,r){void 0===r&&(r=!1),0===o(n)?(r?Object.keys:nn)(n).forEach((function(e){r&&"symbol"==typeof e||t(e,n[e],n);})):n.forEach((function(r,e){return t(e,r,n)}));}function o(n){var t=n[Q];return t?t.i>3?t.i-4:t.i:Array.isArray(n)?1:s(n)?2:v(n)?3:0}function u(n,t){return 2===o(n)?n.has(t):Object.prototype.hasOwnProperty.call(n,t)}function a(n,t){return 2===o(n)?n.get(t):n[t]}function f(n,t,r){var e=o(n);2===e?n.set(t,r):3===e?(n.delete(t),n.add(r)):n[t]=r;}function c(n,t){return n===t?0!==n||1/n==1/t:n!=n&&t!=t}function s(n){return X&&n instanceof Map}function v(n){return q&&n instanceof Set}function p(n){return n.o||n.t}function l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var t=tn(n);delete t[Q];for(var r=nn(t),e=0;e<r.length;e++){var i=r[e],o=t[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(t[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]});}return Object.create(Object.getPrototypeOf(n),t)}function d(n,e){return void 0===e&&(e=!1),y(n)||t(n)||!r(n)?n:(o(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),e&&i(n,(function(n,t){return d(t,!0)}),!0),n)}function h(){n(2);}function y(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function b(t){var r=rn[t];return r||n(18,t),r}function _(){return U}function j(n,t){t&&(b("Patches"),n.u=[],n.s=[],n.v=t);}function O(n){g(n),n.p.forEach(S),n.p=null;}function g(n){n===U&&(U=n.l);}function w(n){return U={p:[],l:U,h:n,m:!0,_:0}}function S(n){var t=n[Q];0===t.i||1===t.i?t.j():t.O=!0;}function P(t,e){e._=e.p.length;var i=e.p[0],o=void 0!==t&&t!==i;return e.h.g||b("ES5").S(e,t,o),o?(i[Q].P&&(O(e),n(4)),r(t)&&(t=M(e,t),e.l||x(e,t)),e.u&&b("Patches").M(i[Q],t,e.u,e.s)):t=M(e,i,[]),O(e),e.u&&e.v(e.u,e.s),t!==H?t:void 0}function M(n,t,r){if(y(t))return t;var e=t[Q];if(!e)return i(t,(function(i,o){return A(n,e,t,i,o,r)}),!0),t;if(e.A!==n)return t;if(!e.P)return x(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l(e.k):e.o;i(3===e.i?new Set(o):o,(function(t,i){return A(n,e,o,t,i,r)})),x(n,o,!1),r&&n.u&&b("Patches").R(e,r,n.u,n.s);}return e.o}function A(e,i,o,a,c,s){if(t(c)){var v=M(e,c,s&&i&&3!==i.i&&!u(i.D,a)?s.concat(a):void 0);if(f(o,a,v),!t(v))return;e.m=!1;}if(r(c)&&!y(c)){if(!e.h.F&&e._<1)return;M(e,c),i&&i.A.l||x(e,c);}}function x(n,t,r){void 0===r&&(r=!1),n.h.F&&n.m&&d(t,r);}function z(n,t){var r=n[Q];return (r?p(r):n)[t]}function I(n,t){if(t in n)for(var r=Object.getPrototypeOf(n);r;){var e=Object.getOwnPropertyDescriptor(r,t);if(e)return e;r=Object.getPrototypeOf(r);}}function k(n){n.P||(n.P=!0,n.l&&k(n.l));}function E(n){n.o||(n.o=l(n.t));}function R(n,t,r){var e=s(t)?b("MapSet").N(t,r):v(t)?b("MapSet").T(t,r):n.g?function(n,t){var r=Array.isArray(n),e={i:r?1:0,A:t?t.A:_(),P:!1,I:!1,D:{},l:t,t:n,k:null,o:null,j:null,C:!1},i=e,o=en;r&&(i=[e],o=on);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(t,r):b("ES5").J(t,r);return (r?r.A:_()).p.push(e),e}function D(e){return t(e)||n(22,e),function n(t){if(!r(t))return t;var e,u=t[Q],c=o(t);if(u){if(!u.P&&(u.i<4||!b("ES5").K(u)))return u.t;u.I=!0,e=F(t,c),u.I=!1;}else e=F(t,c);return i(e,(function(t,r){u&&a(u.t,t)===r||f(e,t,n(r));})),3===c?new Set(e):e}(e)}function F(n,t){switch(t){case 2:return new Map(n);case 3:return Array.from(n)}return l(n)}var G,U,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H=W?Symbol.for("immer-nothing"):((G={})["immer-nothing"]=!0,G),L=W?Symbol.for("immer-draftable"):"__$immer_draftable",Q=W?Symbol.for("immer-state"):"__$immer_state",Z=""+Object.prototype.constructor,nn="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,tn=Object.getOwnPropertyDescriptors||function(n){var t={};return nn(n).forEach((function(r){t[r]=Object.getOwnPropertyDescriptor(n,r);})),t},rn={},en={get:function(n,t){if(t===Q)return n;var e=p(n);if(!u(e,t))return function(n,t,r){var e,i=I(t,r);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,t);var i=e[t];return n.I||!r(i)?i:i===z(n.t,t)?(E(n),n.o[t]=R(n.A.h,i,n)):i},has:function(n,t){return t in p(n)},ownKeys:function(n){return Reflect.ownKeys(p(n))},set:function(n,t,r){var e=I(p(n),t);if(null==e?void 0:e.set)return e.set.call(n.k,r),!0;if(!n.P){var i=z(p(n),t),o=null==i?void 0:i[Q];if(o&&o.t===r)return n.o[t]=r,n.D[t]=!1,!0;if(c(r,i)&&(void 0!==r||u(n.t,t)))return !0;E(n),k(n);}return n.o[t]===r&&"number"!=typeof r&&(void 0!==r||t in n.o)||(n.o[t]=r,n.D[t]=!0,!0)},deleteProperty:function(n,t){return void 0!==z(n.t,t)||t in n.t?(n.D[t]=!1,E(n),k(n)):delete n.D[t],n.o&&delete n.o[t],!0},getOwnPropertyDescriptor:function(n,t){var r=p(n),e=Reflect.getOwnPropertyDescriptor(r,t);return e?{writable:!0,configurable:1!==n.i||"length"!==t,enumerable:e.enumerable,value:r[t]}:e},defineProperty:function(){n(11);},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n(12);}},on={};i(en,(function(n,t){on[n]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)};})),on.deleteProperty=function(t,r){return en.deleteProperty.call(this,t[0],r)},on.set=function(t,r,e){return en.set.call(this,t[0],r,e,t[0])};var un=function(){function e(t){var e=this;this.g=B,this.F=!0,this.produce=function(t,i,o){if("function"==typeof t&&"function"!=typeof i){var u=i;i=t;var a=e;return function(n){var t=this;void 0===n&&(n=u);for(var r=arguments.length,e=Array(r>1?r-1:0),o=1;o<r;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var r;return (r=i).call.apply(r,[t,n].concat(e))}))}}var f;if("function"!=typeof i&&n(6),void 0!==o&&"function"!=typeof o&&n(7),r(t)){var c=w(e),s=R(e,t,void 0),v=!0;try{f=i(s),v=!1;}finally{v?O(c):g(c);}return "undefined"!=typeof Promise&&f instanceof Promise?f.then((function(n){return j(c,o),P(n,c)}),(function(n){throw O(c),n})):(j(c,o),P(f,c))}if(!t||"object"!=typeof t){if((f=i(t))===H)return;return void 0===f&&(f=t),e.F&&d(f,!0),f}n(21,t);},this.produceWithPatches=function(n,t){return "function"==typeof n?function(t){for(var r=arguments.length,i=Array(r>1?r-1:0),o=1;o<r;o++)i[o-1]=arguments[o];return e.produceWithPatches(t,(function(t){return n.apply(void 0,[t].concat(i))}))}:[e.produce(n,t,(function(n,t){r=n,i=t;})),r,i];var r,i;},"boolean"==typeof(null==t?void 0:t.useProxies)&&this.setUseProxies(t.useProxies),"boolean"==typeof(null==t?void 0:t.autoFreeze)&&this.setAutoFreeze(t.autoFreeze);}var i=e.prototype;return i.createDraft=function(e){r(e)||n(8),t(e)&&(e=D(e));var i=w(this),o=R(this,e,void 0);return o[Q].C=!0,g(i),o},i.finishDraft=function(t,r){var e=t&&t[Q];var i=e.A;return j(i,r),P(void 0,i)},i.setAutoFreeze=function(n){this.F=n;},i.setUseProxies=function(t){t&&!B&&n(20),this.g=t;},i.applyPatches=function(n,r){var e;for(e=r.length-1;e>=0;e--){var i=r[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}var o=b("Patches").$;return t(n)?o(n,r):this.produce(n,(function(n){return o(n,r.slice(e+1))}))},e}(),an=new un,fn=an.produce;an.produceWithPatches.bind(an);an.setAutoFreeze.bind(an);an.setUseProxies.bind(an);an.applyPatches.bind(an);an.createDraft.bind(an);an.finishDraft.bind(an);var produce = fn;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked, or until the next browser frame is drawn. The debounced function
 * comes with a `cancel` method to cancel delayed `func` invocations and a
 * `flush` method to immediately invoke them. Provide `options` to indicate
 * whether `func` should be invoked on the leading and/or trailing edge of the
 * `wait` timeout. The `func` is invoked with the last arguments provided to the
 * debounced function. Subsequent calls to the debounced function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`
 * invocation will be deferred until the next frame is drawn (typically about
 * 16ms).
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `debounce` and `throttle`.
 *
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0]
 *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is
 *  used (if available, otherwise it will be setTimeout(...,0)).
 * @param {Object} [options={}] The options object.
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.leading=false]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {number} [options.maxWait]
 *  Specify invoking on the trailing edge of the timeout.
 * @param {boolean} [options.trailing=true]
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * const resizeHandler = useDebouncedCallback(calculateLayout, 150);
 * window.addEventListener('resize', resizeHandler)
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * const clickHandler = useDebouncedCallback(sendMail, 300, {
 *   leading: true,
 *   trailing: false,
 * })
 * <button onClick={clickHandler}>click me</button>
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * const debounced = useDebouncedCallback(batchLog, 250, { 'maxWait': 1000 })
 * const source = new EventSource('/stream')
 * source.addEventListener('message', debounced)
 *
 * // Cancel the trailing debounced invocation.
 * window.addEventListener('popstate', debounced.cancel)
 *
 * // Check for pending invocations.
 * const status = debounced.pending() ? "Pending..." : "Ready"
 */
function useDebouncedCallback(func, wait, options) {
    var _this = this;
    var lastCallTime = useRef(null);
    var lastInvokeTime = useRef(0);
    var timerId = useRef(null);
    var lastArgs = useRef([]);
    var lastThis = useRef();
    var result = useRef();
    var funcRef = useRef(func);
    var mounted = useRef(true);
    funcRef.current = func;
    // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.
    var useRAF = !wait && wait !== 0 && typeof window !== 'undefined';
    if (typeof func !== 'function') {
        throw new TypeError('Expected a function');
    }
    wait = +wait || 0;
    options = options || {};
    var leading = !!options.leading;
    var trailing = 'trailing' in options ? !!options.trailing : true; // `true` by default
    var maxing = 'maxWait' in options;
    var maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : null;
    useEffect(function () {
        mounted.current = true;
        return function () {
            mounted.current = false;
        };
    }, []);
    // You may have a question, why we have so many code under the useMemo definition.
    //
    // This was made as we want to escape from useCallback hell and
    // not to initialize a number of functions each time useDebouncedCallback is called.
    //
    // It means that we have less garbage for our GC calls which improves performance.
    // Also, it makes this library smaller.
    //
    // And the last reason, that the code without lots of useCallback with deps is easier to read.
    // You have only one place for that.
    var debounced = useMemo(function () {
        var invokeFunc = function (time) {
            var args = lastArgs.current;
            var thisArg = lastThis.current;
            lastArgs.current = lastThis.current = null;
            lastInvokeTime.current = time;
            return (result.current = funcRef.current.apply(thisArg, args));
        };
        var startTimer = function (pendingFunc, wait) {
            if (useRAF)
                cancelAnimationFrame(timerId.current);
            timerId.current = useRAF ? requestAnimationFrame(pendingFunc) : setTimeout(pendingFunc, wait);
        };
        var shouldInvoke = function (time) {
            if (!mounted.current)
                return false;
            var timeSinceLastCall = time - lastCallTime.current;
            var timeSinceLastInvoke = time - lastInvokeTime.current;
            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return (!lastCallTime.current ||
                timeSinceLastCall >= wait ||
                timeSinceLastCall < 0 ||
                (maxing && timeSinceLastInvoke >= maxWait));
        };
        var trailingEdge = function (time) {
            timerId.current = null;
            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (trailing && lastArgs.current) {
                return invokeFunc(time);
            }
            lastArgs.current = lastThis.current = null;
            return result.current;
        };
        var timerExpired = function () {
            var time = Date.now();
            if (shouldInvoke(time)) {
                return trailingEdge(time);
            }
            // https://github.com/xnimorz/use-debounce/issues/97
            if (!mounted.current) {
                return;
            }
            // Remaining wait calculation
            var timeSinceLastCall = time - lastCallTime.current;
            var timeSinceLastInvoke = time - lastInvokeTime.current;
            var timeWaiting = wait - timeSinceLastCall;
            var remainingWait = maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            // Restart the timer
            startTimer(timerExpired, remainingWait);
        };
        var func = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var time = Date.now();
            var isInvoking = shouldInvoke(time);
            lastArgs.current = args;
            lastThis.current = _this;
            lastCallTime.current = time;
            if (isInvoking) {
                if (!timerId.current && mounted.current) {
                    // Reset any `maxWait` timer.
                    lastInvokeTime.current = lastCallTime.current;
                    // Start the timer for the trailing edge.
                    startTimer(timerExpired, wait);
                    // Invoke the leading edge.
                    return leading ? invokeFunc(lastCallTime.current) : result.current;
                }
                if (maxing) {
                    // Handle invocations in a tight loop.
                    startTimer(timerExpired, wait);
                    return invokeFunc(lastCallTime.current);
                }
            }
            if (!timerId.current) {
                startTimer(timerExpired, wait);
            }
            return result.current;
        };
        func.cancel = function () {
            if (timerId.current) {
                useRAF ? cancelAnimationFrame(timerId.current) : clearTimeout(timerId.current);
            }
            lastInvokeTime.current = 0;
            lastArgs.current = lastCallTime.current = lastThis.current = timerId.current = null;
        };
        func.isPending = function () {
            return !!timerId.current;
        };
        func.flush = function () {
            return !timerId.current ? result.current : trailingEdge(Date.now());
        };
        return func;
    }, [leading, maxing, wait, maxWait, trailing, useRAF]);
    return debounced;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf$1(subClass, superClass);
}

function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf$1(o);
}

function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf$1(o, p);
}

function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose$2(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized$1(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn$1(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized$1(self);
}

function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn$1(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf$1(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function set(target, property, value, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.set) {
    set = Reflect.set;
  } else {
    set = function set(target, property, value, receiver) {
      var base = _superPropBase(target, property);

      var desc;

      if (base) {
        desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.set) {
          desc.set.call(receiver, value);
          return true;
        } else if (!desc.writable) {
          return false;
        }
      }

      desc = Object.getOwnPropertyDescriptor(receiver, property);

      if (desc) {
        if (!desc.writable) {
          return false;
        }

        desc.value = value;
        Object.defineProperty(receiver, property, desc);
      } else {
        _defineProperty(receiver, property, value);
      }

      return true;
    };
  }

  return set(target, property, value, receiver);
}

function _set(target, property, value, receiver, isStrict) {
  var s = set(target, property, value, receiver || target);

  if (!s && isStrict) {
    throw new Error('failed to set property');
  }

  return value;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/** Checks if value is string */
function isString(str) {
  return typeof str === 'string' || str instanceof String;
}
/**
  Direction
  @prop {string} NONE
  @prop {string} LEFT
  @prop {string} FORCE_LEFT
  @prop {string} RIGHT
  @prop {string} FORCE_RIGHT
*/

var DIRECTION = {
  NONE: 'NONE',
  LEFT: 'LEFT',
  FORCE_LEFT: 'FORCE_LEFT',
  RIGHT: 'RIGHT',
  FORCE_RIGHT: 'FORCE_RIGHT'
};
/** */

function forceDirection(direction) {
  switch (direction) {
    case DIRECTION.LEFT:
      return DIRECTION.FORCE_LEFT;

    case DIRECTION.RIGHT:
      return DIRECTION.FORCE_RIGHT;

    default:
      return direction;
  }
}
/** Escapes regular expression control chars */

function escapeRegExp(str) {
  return str.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
} // cloned from https://github.com/epoberezkin/fast-deep-equal with small changes

function objectIncludes(b, a) {
  if (a === b) return true;
  var arrA = Array.isArray(a),
      arrB = Array.isArray(b),
      i;

  if (arrA && arrB) {
    if (a.length != b.length) return false;

    for (i = 0; i < a.length; i++) {
      if (!objectIncludes(a[i], b[i])) return false;
    }

    return true;
  }

  if (arrA != arrB) return false;

  if (a && b && _typeof(a) === 'object' && _typeof(b) === 'object') {
    var dateA = a instanceof Date,
        dateB = b instanceof Date;
    if (dateA && dateB) return a.getTime() == b.getTime();
    if (dateA != dateB) return false;
    var regexpA = a instanceof RegExp,
        regexpB = b instanceof RegExp;
    if (regexpA && regexpB) return a.toString() == b.toString();
    if (regexpA != regexpB) return false;
    var keys = Object.keys(a); // if (keys.length !== Object.keys(b).length) return false;

    for (i = 0; i < keys.length; i++) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
    }

    for (i = 0; i < keys.length; i++) {
      if (!objectIncludes(b[keys[i]], a[keys[i]])) return false;
    }

    return true;
  } else if (a && b && typeof a === 'function' && typeof b === 'function') {
    return a.toString() === b.toString();
  }

  return false;
}

/** Provides details of changing input */

var ActionDetails = /*#__PURE__*/function () {
  /** Current input value */

  /** Current cursor position */

  /** Old input value */

  /** Old selection */
  function ActionDetails(value, cursorPos, oldValue, oldSelection) {
    _classCallCheck$1(this, ActionDetails);

    this.value = value;
    this.cursorPos = cursorPos;
    this.oldValue = oldValue;
    this.oldSelection = oldSelection; // double check if left part was changed (autofilling, other non-standard input triggers)

    while (this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos)) {
      --this.oldSelection.start;
    }
  }
  /**
    Start changing position
    @readonly
  */


  _createClass$1(ActionDetails, [{
    key: "startChangePos",
    get: function get() {
      return Math.min(this.cursorPos, this.oldSelection.start);
    }
    /**
      Inserted symbols count
      @readonly
    */

  }, {
    key: "insertedCount",
    get: function get() {
      return this.cursorPos - this.startChangePos;
    }
    /**
      Inserted symbols
      @readonly
    */

  }, {
    key: "inserted",
    get: function get() {
      return this.value.substr(this.startChangePos, this.insertedCount);
    }
    /**
      Removed symbols count
      @readonly
    */

  }, {
    key: "removedCount",
    get: function get() {
      // Math.max for opposite operation
      return Math.max(this.oldSelection.end - this.startChangePos || // for Delete
      this.oldValue.length - this.value.length, 0);
    }
    /**
      Removed symbols
      @readonly
    */

  }, {
    key: "removed",
    get: function get() {
      return this.oldValue.substr(this.startChangePos, this.removedCount);
    }
    /**
      Unchanged head symbols
      @readonly
    */

  }, {
    key: "head",
    get: function get() {
      return this.value.substring(0, this.startChangePos);
    }
    /**
      Unchanged tail symbols
      @readonly
    */

  }, {
    key: "tail",
    get: function get() {
      return this.value.substring(this.startChangePos + this.insertedCount);
    }
    /**
      Remove direction
      @readonly
    */

  }, {
    key: "removeDirection",
    get: function get() {
      if (!this.removedCount || this.insertedCount) return DIRECTION.NONE; // align right if delete at right or if range removed (event with backspace)

      return this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos ? DIRECTION.RIGHT : DIRECTION.LEFT;
    }
  }]);

  return ActionDetails;
}();

/**
  Provides details of changing model value
  @param {Object} [details]
  @param {string} [details.inserted] - Inserted symbols
  @param {boolean} [details.skip] - Can skip chars
  @param {number} [details.removeCount] - Removed symbols count
  @param {number} [details.tailShift] - Additional offset if any changes occurred before tail
*/
var ChangeDetails = /*#__PURE__*/function () {
  /** Inserted symbols */

  /** Can skip chars */

  /** Additional offset if any changes occurred before tail */

  /** Raw inserted is used by dynamic mask */
  function ChangeDetails(details) {
    _classCallCheck$1(this, ChangeDetails);

    Object.assign(this, {
      inserted: '',
      rawInserted: '',
      skip: false,
      tailShift: 0
    }, details);
  }
  /**
    Aggregate changes
    @returns {ChangeDetails} `this`
  */


  _createClass$1(ChangeDetails, [{
    key: "aggregate",
    value: function aggregate(details) {
      this.rawInserted += details.rawInserted;
      this.skip = this.skip || details.skip;
      this.inserted += details.inserted;
      this.tailShift += details.tailShift;
      return this;
    }
    /** Total offset considering all changes */

  }, {
    key: "offset",
    get: function get() {
      return this.tailShift + this.inserted.length;
    }
  }]);

  return ChangeDetails;
}();

/** Provides details of continuous extracted tail */
var ContinuousTailDetails = /*#__PURE__*/function () {
  /** Tail value as string */

  /** Tail start position */

  /** Start position */
  function ContinuousTailDetails() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var stop = arguments.length > 2 ? arguments[2] : undefined;

    _classCallCheck$1(this, ContinuousTailDetails);

    this.value = value;
    this.from = from;
    this.stop = stop;
  }

  _createClass$1(ContinuousTailDetails, [{
    key: "toString",
    value: function toString() {
      return this.value;
    }
  }, {
    key: "extend",
    value: function extend(tail) {
      this.value += String(tail);
    }
  }, {
    key: "appendTo",
    value: function appendTo(masked) {
      return masked.append(this.toString(), {
        tail: true
      }).aggregate(masked._appendPlaceholder());
    }
  }, {
    key: "state",
    get: function get() {
      return {
        value: this.value,
        from: this.from,
        stop: this.stop
      };
    },
    set: function set(state) {
      Object.assign(this, state);
    }
  }, {
    key: "shiftBefore",
    value: function shiftBefore(pos) {
      if (this.from >= pos || !this.value.length) return '';
      var shiftChar = this.value[0];
      this.value = this.value.slice(1);
      return shiftChar;
    }
  }]);

  return ContinuousTailDetails;
}();

/**
 * Applies mask on element.
 * @constructor
 * @param {HTMLInputElement|HTMLTextAreaElement|MaskElement} el - Element to apply mask
 * @param {Object} opts - Custom mask options
 * @return {InputMask}
 */
function IMask(el) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  // currently available only for input-like elements
  return new IMask.InputMask(el, opts);
}

/** Supported mask type */

/** Provides common masking stuff */
var Masked = /*#__PURE__*/function () {
  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773

  /** @type {Mask} */

  /** */
  // $FlowFixMe no ideas

  /** Transforms value before mask processing */

  /** Validates if value is acceptable */

  /** Does additional processing in the end of editing */

  /** Format typed value to string */

  /** Parse strgin to get typed value */

  /** Enable characters overwriting */

  /** */
  function Masked(opts) {
    _classCallCheck$1(this, Masked);

    this._value = '';

    this._update(Object.assign({}, Masked.DEFAULTS, opts));

    this.isInitialized = true;
  }
  /** Sets and applies new options */


  _createClass$1(Masked, [{
    key: "updateOptions",
    value: function updateOptions(opts) {
      if (!Object.keys(opts).length) return;
      this.withValueRefresh(this._update.bind(this, opts));
    }
    /**
      Sets new options
      @protected
    */

  }, {
    key: "_update",
    value: function _update(opts) {
      Object.assign(this, opts);
    }
    /** Mask state */

  }, {
    key: "state",
    get: function get() {
      return {
        _value: this.value
      };
    },
    set: function set(state) {
      this._value = state._value;
    }
    /** Resets value */

  }, {
    key: "reset",
    value: function reset() {
      this._value = '';
    }
    /** */

  }, {
    key: "value",
    get: function get() {
      return this._value;
    },
    set: function set(value) {
      this.resolve(value);
    }
    /** Resolve new value */

  }, {
    key: "resolve",
    value: function resolve(value) {
      this.reset();
      this.append(value, {
        input: true
      }, '');
      this.doCommit();
      return this.value;
    }
    /** */

  }, {
    key: "unmaskedValue",
    get: function get() {
      return this.value;
    },
    set: function set(value) {
      this.reset();
      this.append(value, {}, '');
      this.doCommit();
    }
    /** */

  }, {
    key: "typedValue",
    get: function get() {
      return this.doParse(this.value);
    },
    set: function set(value) {
      this.value = this.doFormat(value);
    }
    /** Value that includes raw user input */

  }, {
    key: "rawInputValue",
    get: function get() {
      return this.extractInput(0, this.value.length, {
        raw: true
      });
    },
    set: function set(value) {
      this.reset();
      this.append(value, {
        raw: true
      }, '');
      this.doCommit();
    }
    /** */

  }, {
    key: "isComplete",
    get: function get() {
      return true;
    }
    /** Finds nearest input position in direction */

  }, {
    key: "nearestInputPos",
    value: function nearestInputPos(cursorPos, direction) {
      return cursorPos;
    }
    /** Extracts value in range considering flags */

  }, {
    key: "extractInput",
    value: function extractInput() {
      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
      return this.value.slice(fromPos, toPos);
    }
    /** Extracts tail in range */

  }, {
    key: "extractTail",
    value: function extractTail() {
      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
      return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);
    }
    /** Appends tail */
    // $FlowFixMe no ideas

  }, {
    key: "appendTail",
    value: function appendTail(tail) {
      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));
      return tail.appendTo(this);
    }
    /** Appends char */

  }, {
    key: "_appendCharRaw",
    value: function _appendCharRaw(ch) {
      if (!ch) return new ChangeDetails();
      this._value += ch;
      return new ChangeDetails({
        inserted: ch,
        rawInserted: ch
      });
    }
    /** Appends char */

  }, {
    key: "_appendChar",
    value: function _appendChar(ch) {
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var checkTail = arguments.length > 2 ? arguments[2] : undefined;
      var consistentState = this.state;

      var details = this._appendCharRaw(this.doPrepare(ch, flags), flags);

      if (details.inserted) {
        var consistentTail;
        var appended = this.doValidate(flags) !== false;

        if (appended && checkTail != null) {
          // validation ok, check tail
          var beforeTailState = this.state;

          if (this.overwrite) {
            consistentTail = checkTail.state;
            checkTail.shiftBefore(this.value.length);
          }

          var tailDetails = this.appendTail(checkTail);
          appended = tailDetails.rawInserted === checkTail.toString(); // if ok, rollback state after tail

          if (appended && tailDetails.inserted) this.state = beforeTailState;
        } // revert all if something went wrong


        if (!appended) {
          details = new ChangeDetails();
          this.state = consistentState;
          if (checkTail && consistentTail) checkTail.state = consistentTail;
        }
      }

      return details;
    }
    /** Appends optional placeholder at end */

  }, {
    key: "_appendPlaceholder",
    value: function _appendPlaceholder() {
      return new ChangeDetails();
    }
    /** Appends symbols considering flags */
    // $FlowFixMe no ideas

  }, {
    key: "append",
    value: function append(str, flags, tail) {
      if (!isString(str)) throw new Error('value should be string');
      var details = new ChangeDetails();
      var checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;
      if (flags && flags.tail) flags._beforeTailState = this.state;

      for (var ci = 0; ci < str.length; ++ci) {
        details.aggregate(this._appendChar(str[ci], flags, checkTail));
      } // append tail but aggregate only tailShift


      if (checkTail != null) {
        details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends
        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)
        // this._resetBeforeTailState();
      }

      return details;
    }
    /** */

  }, {
    key: "remove",
    value: function remove() {
      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
      this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);
      return new ChangeDetails();
    }
    /** Calls function and reapplies current value */

  }, {
    key: "withValueRefresh",
    value: function withValueRefresh(fn) {
      if (this._refreshing || !this.isInitialized) return fn();
      this._refreshing = true;
      var rawInput = this.rawInputValue;
      var value = this.value;
      var ret = fn();
      this.rawInputValue = rawInput; // append lost trailing chars at end

      if (this.value && this.value !== value && value.indexOf(this.value) === 0) {
        this.append(value.slice(this.value.length), {}, '');
      }

      delete this._refreshing;
      return ret;
    }
    /** */

  }, {
    key: "runIsolated",
    value: function runIsolated(fn) {
      if (this._isolated || !this.isInitialized) return fn(this);
      this._isolated = true;
      var state = this.state;
      var ret = fn(this);
      this.state = state;
      delete this._isolated;
      return ret;
    }
    /**
      Prepares string before mask processing
      @protected
    */

  }, {
    key: "doPrepare",
    value: function doPrepare(str) {
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.prepare ? this.prepare(str, this, flags) : str;
    }
    /**
      Validates if value is acceptable
      @protected
    */

  }, {
    key: "doValidate",
    value: function doValidate(flags) {
      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));
    }
    /**
      Does additional processing in the end of editing
      @protected
    */

  }, {
    key: "doCommit",
    value: function doCommit() {
      if (this.commit) this.commit(this.value, this);
    }
    /** */

  }, {
    key: "doFormat",
    value: function doFormat(value) {
      return this.format ? this.format(value, this) : value;
    }
    /** */

  }, {
    key: "doParse",
    value: function doParse(str) {
      return this.parse ? this.parse(str, this) : str;
    }
    /** */

  }, {
    key: "splice",
    value: function splice(start, deleteCount, inserted, removeDirection) {
      var tailPos = start + deleteCount;
      var tail = this.extractTail(tailPos);
      var startChangePos = this.nearestInputPos(start, removeDirection);
      var changeDetails = new ChangeDetails({
        tailShift: startChangePos - start // adjust tailShift if start was aligned

      }).aggregate(this.remove(startChangePos)).aggregate(this.append(inserted, {
        input: true
      }, tail));
      return changeDetails;
    }
  }]);

  return Masked;
}();
Masked.DEFAULTS = {
  format: function format(v) {
    return v;
  },
  parse: function parse(v) {
    return v;
  }
};
IMask.Masked = Masked;

/** Get Masked class by mask type */

function maskedClass(mask) {
  if (mask == null) {
    throw new Error('mask property should be defined');
  } // $FlowFixMe


  if (mask instanceof RegExp) return IMask.MaskedRegExp; // $FlowFixMe

  if (isString(mask)) return IMask.MaskedPattern; // $FlowFixMe

  if (mask instanceof Date || mask === Date) return IMask.MaskedDate; // $FlowFixMe

  if (mask instanceof Number || typeof mask === 'number' || mask === Number) return IMask.MaskedNumber; // $FlowFixMe

  if (Array.isArray(mask) || mask === Array) return IMask.MaskedDynamic; // $FlowFixMe

  if (IMask.Masked && mask.prototype instanceof IMask.Masked) return mask; // $FlowFixMe

  if (mask instanceof Function) return IMask.MaskedFunction; // $FlowFixMe

  if (mask instanceof IMask.Masked) return mask.constructor;
  console.warn('Mask not found for mask', mask); // eslint-disable-line no-console
  // $FlowFixMe

  return IMask.Masked;
}
/** Creates new {@link Masked} depending on mask type */

function createMask(opts) {
  // $FlowFixMe
  if (IMask.Masked && opts instanceof IMask.Masked) return opts;
  opts = Object.assign({}, opts);
  var mask = opts.mask; // $FlowFixMe

  if (IMask.Masked && mask instanceof IMask.Masked) return mask;
  var MaskedClass = maskedClass(mask);
  if (!MaskedClass) throw new Error('Masked class is not found for provided mask, appropriate module needs to be import manually before creating mask.');
  return new MaskedClass(opts);
}
IMask.createMask = createMask;

var _excluded$5 = ["mask"];
var DEFAULT_INPUT_DEFINITIONS = {
  '0': /\d/,
  'a': /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
  // http://stackoverflow.com/a/22075070
  '*': /./
};
/** */

var PatternInputDefinition = /*#__PURE__*/function () {
  /** */

  /** */

  /** */

  /** */

  /** */

  /** */
  function PatternInputDefinition(opts) {
    _classCallCheck$1(this, PatternInputDefinition);

    var mask = opts.mask,
        blockOpts = _objectWithoutProperties$1(opts, _excluded$5);

    this.masked = createMask({
      mask: mask
    });
    Object.assign(this, blockOpts);
  }

  _createClass$1(PatternInputDefinition, [{
    key: "reset",
    value: function reset() {
      this._isFilled = false;
      this.masked.reset();
    }
  }, {
    key: "remove",
    value: function remove() {
      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;

      if (fromPos === 0 && toPos >= 1) {
        this._isFilled = false;
        return this.masked.remove(fromPos, toPos);
      }

      return new ChangeDetails();
    }
  }, {
    key: "value",
    get: function get() {
      return this.masked.value || (this._isFilled && !this.isOptional ? this.placeholderChar : '');
    }
  }, {
    key: "unmaskedValue",
    get: function get() {
      return this.masked.unmaskedValue;
    }
  }, {
    key: "isComplete",
    get: function get() {
      return Boolean(this.masked.value) || this.isOptional;
    }
  }, {
    key: "_appendChar",
    value: function _appendChar(str) {
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (this._isFilled) return new ChangeDetails();
      var state = this.masked.state; // simulate input

      var details = this.masked._appendChar(str, flags);

      if (details.inserted && this.doValidate(flags) === false) {
        details.inserted = details.rawInserted = '';
        this.masked.state = state;
      }

      if (!details.inserted && !this.isOptional && !this.lazy && !flags.input) {
        details.inserted = this.placeholderChar;
      }

      details.skip = !details.inserted && !this.isOptional;
      this._isFilled = Boolean(details.inserted);
      return details;
    }
  }, {
    key: "append",
    value: function append() {
      var _this$masked;

      return (_this$masked = this.masked).append.apply(_this$masked, arguments);
    }
  }, {
    key: "_appendPlaceholder",
    value: function _appendPlaceholder() {
      var details = new ChangeDetails();
      if (this._isFilled || this.isOptional) return details;
      this._isFilled = true;
      details.inserted = this.placeholderChar;
      return details;
    }
  }, {
    key: "extractTail",
    value: function extractTail() {
      var _this$masked2;

      return (_this$masked2 = this.masked).extractTail.apply(_this$masked2, arguments);
    }
  }, {
    key: "appendTail",
    value: function appendTail() {
      var _this$masked3;

      return (_this$masked3 = this.masked).appendTail.apply(_this$masked3, arguments);
    }
  }, {
    key: "extractInput",
    value: function extractInput() {
      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
      var flags = arguments.length > 2 ? arguments[2] : undefined;
      return this.masked.extractInput(fromPos, toPos, flags);
    }
  }, {
    key: "nearestInputPos",
    value: function nearestInputPos(cursorPos) {
      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;
      var minPos = 0;
      var maxPos = this.value.length;
      var boundPos = Math.min(Math.max(cursorPos, minPos), maxPos);

      switch (direction) {
        case DIRECTION.LEFT:
        case DIRECTION.FORCE_LEFT:
          return this.isComplete ? boundPos : minPos;

        case DIRECTION.RIGHT:
        case DIRECTION.FORCE_RIGHT:
          return this.isComplete ? boundPos : maxPos;

        case DIRECTION.NONE:
        default:
          return boundPos;
      }
    }
  }, {
    key: "doValidate",
    value: function doValidate() {
      var _this$masked4, _this$parent;

      return (_this$masked4 = this.masked).doValidate.apply(_this$masked4, arguments) && (!this.parent || (_this$parent = this.parent).doValidate.apply(_this$parent, arguments));
    }
  }, {
    key: "doCommit",
    value: function doCommit() {
      this.masked.doCommit();
    }
  }, {
    key: "state",
    get: function get() {
      return {
        masked: this.masked.state,
        _isFilled: this._isFilled
      };
    },
    set: function set(state) {
      this.masked.state = state.masked;
      this._isFilled = state._isFilled;
    }
  }]);

  return PatternInputDefinition;
}();

var PatternFixedDefinition = /*#__PURE__*/function () {
  /** */

  /** */

  /** */

  /** */
  function PatternFixedDefinition(opts) {
    _classCallCheck$1(this, PatternFixedDefinition);

    Object.assign(this, opts);
    this._value = '';
  }

  _createClass$1(PatternFixedDefinition, [{
    key: "value",
    get: function get() {
      return this._value;
    }
  }, {
    key: "unmaskedValue",
    get: function get() {
      return this.isUnmasking ? this.value : '';
    }
  }, {
    key: "reset",
    value: function reset() {
      this._isRawInput = false;
      this._value = '';
    }
  }, {
    key: "remove",
    value: function remove() {
      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._value.length;
      this._value = this._value.slice(0, fromPos) + this._value.slice(toPos);
      if (!this._value) this._isRawInput = false;
      return new ChangeDetails();
    }
  }, {
    key: "nearestInputPos",
    value: function nearestInputPos(cursorPos) {
      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;
      var minPos = 0;
      var maxPos = this._value.length;

      switch (direction) {
        case DIRECTION.LEFT:
        case DIRECTION.FORCE_LEFT:
          return minPos;

        case DIRECTION.NONE:
        case DIRECTION.RIGHT:
        case DIRECTION.FORCE_RIGHT:
        default:
          return maxPos;
      }
    }
  }, {
    key: "extractInput",
    value: function extractInput() {
      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._value.length;
      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return flags.raw && this._isRawInput && this._value.slice(fromPos, toPos) || '';
    }
  }, {
    key: "isComplete",
    get: function get() {
      return true;
    }
  }, {
    key: "_appendChar",
    value: function _appendChar(str) {
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var details = new ChangeDetails();
      if (this._value) return details;
      var appended = this.char === str[0];
      var isResolved = appended && (this.isUnmasking || flags.input || flags.raw) && !flags.tail;
      if (isResolved) details.rawInserted = this.char;
      this._value = details.inserted = this.char;
      this._isRawInput = isResolved && (flags.raw || flags.input);
      return details;
    }
  }, {
    key: "_appendPlaceholder",
    value: function _appendPlaceholder() {
      var details = new ChangeDetails();
      if (this._value) return details;
      this._value = details.inserted = this.char;
      return details;
    }
  }, {
    key: "extractTail",
    value: function extractTail() {
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
      return new ContinuousTailDetails('');
    } // $FlowFixMe no ideas

  }, {
    key: "appendTail",
    value: function appendTail(tail) {
      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));
      return tail.appendTo(this);
    }
  }, {
    key: "append",
    value: function append(str, flags, tail) {
      var details = this._appendChar(str, flags);

      if (tail != null) {
        details.tailShift += this.appendTail(tail).tailShift;
      }

      return details;
    }
  }, {
    key: "doCommit",
    value: function doCommit() {}
  }, {
    key: "state",
    get: function get() {
      return {
        _value: this._value,
        _isRawInput: this._isRawInput
      };
    },
    set: function set(state) {
      Object.assign(this, state);
    }
  }]);

  return PatternFixedDefinition;
}();

var _excluded$4 = ["chunks"];

var ChunksTailDetails = /*#__PURE__*/function () {
  /** */
  function ChunksTailDetails() {
    var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck$1(this, ChunksTailDetails);

    this.chunks = chunks;
    this.from = from;
  }

  _createClass$1(ChunksTailDetails, [{
    key: "toString",
    value: function toString() {
      return this.chunks.map(String).join('');
    } // $FlowFixMe no ideas

  }, {
    key: "extend",
    value: function extend(tailChunk) {
      if (!String(tailChunk)) return;
      if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));
      var lastChunk = this.chunks[this.chunks.length - 1];
      var extendLast = lastChunk && ( // if stops are same or tail has no stop
      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && // if tail chunk goes just after last chunk
      tailChunk.from === lastChunk.from + lastChunk.toString().length;

      if (tailChunk instanceof ContinuousTailDetails) {
        // check the ability to extend previous chunk
        if (extendLast) {
          // extend previous chunk
          lastChunk.extend(tailChunk.toString());
        } else {
          // append new chunk
          this.chunks.push(tailChunk);
        }
      } else if (tailChunk instanceof ChunksTailDetails) {
        if (tailChunk.stop == null) {
          // unwrap floating chunks to parent, keeping `from` pos
          var firstTailChunk;

          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {
            firstTailChunk = tailChunk.chunks.shift();
            firstTailChunk.from += tailChunk.from;
            this.extend(firstTailChunk);
          }
        } // if tail chunk still has value


        if (tailChunk.toString()) {
          // if chunks contains stops, then popup stop to container
          tailChunk.stop = tailChunk.blockIndex;
          this.chunks.push(tailChunk);
        }
      }
    }
  }, {
    key: "appendTo",
    value: function appendTo(masked) {
      // $FlowFixMe
      if (!(masked instanceof IMask.MaskedPattern)) {
        var tail = new ContinuousTailDetails(this.toString());
        return tail.appendTo(masked);
      }

      var details = new ChangeDetails();

      for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {
        var chunk = this.chunks[ci];

        var lastBlockIter = masked._mapPosToBlock(masked.value.length);

        var stop = chunk.stop;
        var chunkBlock = void 0;

        if (stop != null && ( // if block not found or stop is behind lastBlock
        !lastBlockIter || lastBlockIter.index <= stop)) {
          if (chunk instanceof ChunksTailDetails || // for continuous block also check if stop is exist
          masked._stops.indexOf(stop) >= 0) {
            details.aggregate(masked._appendPlaceholder(stop));
          }

          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];
        }

        if (chunkBlock) {
          var tailDetails = chunkBlock.appendTail(chunk);
          tailDetails.skip = false; // always ignore skip, it will be set on last

          details.aggregate(tailDetails);
          masked._value += tailDetails.inserted; // get not inserted chars

          var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);
          if (remainChars) details.aggregate(masked.append(remainChars, {
            tail: true
          }));
        } else {
          details.aggregate(masked.append(chunk.toString(), {
            tail: true
          }));
        }
      }
      return details;
    }
  }, {
    key: "state",
    get: function get() {
      return {
        chunks: this.chunks.map(function (c) {
          return c.state;
        }),
        from: this.from,
        stop: this.stop,
        blockIndex: this.blockIndex
      };
    },
    set: function set(state) {
      var chunks = state.chunks,
          props = _objectWithoutProperties$1(state, _excluded$4);

      Object.assign(this, props);
      this.chunks = chunks.map(function (cstate) {
        var chunk = "chunks" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails(); // $FlowFixMe already checked above

        chunk.state = cstate;
        return chunk;
      });
    }
  }, {
    key: "shiftBefore",
    value: function shiftBefore(pos) {
      if (this.from >= pos || !this.chunks.length) return '';
      var chunkShiftPos = pos - this.from;
      var ci = 0;

      while (ci < this.chunks.length) {
        var chunk = this.chunks[ci];
        var shiftChar = chunk.shiftBefore(chunkShiftPos);

        if (chunk.toString()) {
          // chunk still contains value
          // but not shifted - means no more available chars to shift
          if (!shiftChar) break;
          ++ci;
        } else {
          // clean if chunk has no value
          this.chunks.splice(ci, 1);
        }

        if (shiftChar) return shiftChar;
      }

      return '';
    }
  }]);

  return ChunksTailDetails;
}();

/** Masking by RegExp */

var MaskedRegExp = /*#__PURE__*/function (_Masked) {
  _inherits$1(MaskedRegExp, _Masked);

  var _super = _createSuper$1(MaskedRegExp);

  function MaskedRegExp() {
    _classCallCheck$1(this, MaskedRegExp);

    return _super.apply(this, arguments);
  }

  _createClass$1(MaskedRegExp, [{
    key: "_update",
    value:
    /**
      @override
      @param {Object} opts
    */
    function _update(opts) {
      if (opts.mask) opts.validate = function (value) {
        return value.search(opts.mask) >= 0;
      };

      _get(_getPrototypeOf$1(MaskedRegExp.prototype), "_update", this).call(this, opts);
    }
  }]);

  return MaskedRegExp;
}(Masked);
IMask.MaskedRegExp = MaskedRegExp;

var _excluded$3 = ["_blocks"];

/**
  Pattern mask
  @param {Object} opts
  @param {Object} opts.blocks
  @param {Object} opts.definitions
  @param {string} opts.placeholderChar
  @param {boolean} opts.lazy
*/
var MaskedPattern = /*#__PURE__*/function (_Masked) {
  _inherits$1(MaskedPattern, _Masked);

  var _super = _createSuper$1(MaskedPattern);

  /** */

  /** */

  /** Single char for empty input */

  /** Show placeholder only when needed */
  function MaskedPattern() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck$1(this, MaskedPattern);

    // TODO type $Shape<MaskedPatternOptions>={} does not work
    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);
    return _super.call(this, Object.assign({}, MaskedPattern.DEFAULTS, opts));
  }
  /**
    @override
    @param {Object} opts
  */


  _createClass$1(MaskedPattern, [{
    key: "_update",
    value: function _update() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      opts.definitions = Object.assign({}, this.definitions, opts.definitions);

      _get(_getPrototypeOf$1(MaskedPattern.prototype), "_update", this).call(this, opts);

      this._rebuildMask();
    }
    /** */

  }, {
    key: "_rebuildMask",
    value: function _rebuildMask() {
      var _this = this;

      var defs = this.definitions;
      this._blocks = [];
      this._stops = [];
      this._maskedBlocks = {};
      var pattern = this.mask;
      if (!pattern || !defs) return;
      var unmaskingBlock = false;
      var optionalBlock = false;

      for (var i = 0; i < pattern.length; ++i) {
        if (this.blocks) {
          var _ret = function () {
            var p = pattern.slice(i);
            var bNames = Object.keys(_this.blocks).filter(function (bName) {
              return p.indexOf(bName) === 0;
            }); // order by key length

            bNames.sort(function (a, b) {
              return b.length - a.length;
            }); // use block name with max length

            var bName = bNames[0];

            if (bName) {
              // $FlowFixMe no ideas
              var maskedBlock = createMask(Object.assign({
                parent: _this,
                lazy: _this.lazy,
                placeholderChar: _this.placeholderChar,
                overwrite: _this.overwrite
              }, _this.blocks[bName]));

              if (maskedBlock) {
                _this._blocks.push(maskedBlock); // store block index


                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];

                _this._maskedBlocks[bName].push(_this._blocks.length - 1);
              }

              i += bName.length - 1;
              return "continue";
            }
          }();

          if (_ret === "continue") continue;
        }

        var char = pattern[i];

        var _isInput = (char in defs);

        if (char === MaskedPattern.STOP_CHAR) {
          this._stops.push(this._blocks.length);

          continue;
        }

        if (char === '{' || char === '}') {
          unmaskingBlock = !unmaskingBlock;
          continue;
        }

        if (char === '[' || char === ']') {
          optionalBlock = !optionalBlock;
          continue;
        }

        if (char === MaskedPattern.ESCAPE_CHAR) {
          ++i;
          char = pattern[i];
          if (!char) break;
          _isInput = false;
        }

        var def = _isInput ? new PatternInputDefinition({
          parent: this,
          lazy: this.lazy,
          placeholderChar: this.placeholderChar,
          mask: defs[char],
          isOptional: optionalBlock
        }) : new PatternFixedDefinition({
          char: char,
          isUnmasking: unmaskingBlock
        });

        this._blocks.push(def);
      }
    }
    /**
      @override
    */

  }, {
    key: "state",
    get: function get() {
      return Object.assign({}, _get(_getPrototypeOf$1(MaskedPattern.prototype), "state", this), {
        _blocks: this._blocks.map(function (b) {
          return b.state;
        })
      });
    },
    set: function set(state) {
      var _blocks = state._blocks,
          maskedState = _objectWithoutProperties$1(state, _excluded$3);

      this._blocks.forEach(function (b, bi) {
        return b.state = _blocks[bi];
      });

      _set(_getPrototypeOf$1(MaskedPattern.prototype), "state", maskedState, this, true);
    }
    /**
      @override
    */

  }, {
    key: "reset",
    value: function reset() {
      _get(_getPrototypeOf$1(MaskedPattern.prototype), "reset", this).call(this);

      this._blocks.forEach(function (b) {
        return b.reset();
      });
    }
    /**
      @override
    */

  }, {
    key: "isComplete",
    get: function get() {
      return this._blocks.every(function (b) {
        return b.isComplete;
      });
    }
    /**
      @override
    */

  }, {
    key: "doCommit",
    value: function doCommit() {
      this._blocks.forEach(function (b) {
        return b.doCommit();
      });

      _get(_getPrototypeOf$1(MaskedPattern.prototype), "doCommit", this).call(this);
    }
    /**
      @override
    */

  }, {
    key: "unmaskedValue",
    get: function get() {
      return this._blocks.reduce(function (str, b) {
        return str += b.unmaskedValue;
      }, '');
    },
    set: function set(unmaskedValue) {
      _set(_getPrototypeOf$1(MaskedPattern.prototype), "unmaskedValue", unmaskedValue, this, true);
    }
    /**
      @override
    */

  }, {
    key: "value",
    get: function get() {
      // TODO return _value when not in change?
      return this._blocks.reduce(function (str, b) {
        return str += b.value;
      }, '');
    },
    set: function set(value) {
      _set(_getPrototypeOf$1(MaskedPattern.prototype), "value", value, this, true);
    }
    /**
      @override
    */

  }, {
    key: "appendTail",
    value: function appendTail(tail) {
      return _get(_getPrototypeOf$1(MaskedPattern.prototype), "appendTail", this).call(this, tail).aggregate(this._appendPlaceholder());
    }
    /**
      @override
    */

  }, {
    key: "_appendCharRaw",
    value: function _appendCharRaw(ch) {
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var blockIter = this._mapPosToBlock(this.value.length);

      var details = new ChangeDetails();
      if (!blockIter) return details;

      for (var bi = blockIter.index;; ++bi) {
        var _block = this._blocks[bi];
        if (!_block) break;

        var blockDetails = _block._appendChar(ch, flags);

        var skip = blockDetails.skip;
        details.aggregate(blockDetails);
        if (skip || blockDetails.rawInserted) break; // go next char
      }

      return details;
    }
    /**
      @override
    */

  }, {
    key: "extractTail",
    value: function extractTail() {
      var _this2 = this;

      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
      var chunkTail = new ChunksTailDetails();
      if (fromPos === toPos) return chunkTail;

      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {
        var blockChunk = b.extractTail(bFromPos, bToPos);
        blockChunk.stop = _this2._findStopBefore(bi);
        blockChunk.from = _this2._blockStartPos(bi);
        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;
        chunkTail.extend(blockChunk);
      });

      return chunkTail;
    }
    /**
      @override
    */

  }, {
    key: "extractInput",
    value: function extractInput() {
      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (fromPos === toPos) return '';
      var input = '';

      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {
        input += b.extractInput(fromPos, toPos, flags);
      });

      return input;
    }
  }, {
    key: "_findStopBefore",
    value: function _findStopBefore(blockIndex) {
      var stopBefore;

      for (var si = 0; si < this._stops.length; ++si) {
        var stop = this._stops[si];
        if (stop <= blockIndex) stopBefore = stop;else break;
      }

      return stopBefore;
    }
    /** Appends placeholder depending on laziness */

  }, {
    key: "_appendPlaceholder",
    value: function _appendPlaceholder(toBlockIndex) {
      var _this3 = this;

      var details = new ChangeDetails();
      if (this.lazy && toBlockIndex == null) return details;

      var startBlockIter = this._mapPosToBlock(this.value.length);

      if (!startBlockIter) return details;
      var startBlockIndex = startBlockIter.index;
      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;

      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {
        if (!b.lazy || toBlockIndex != null) {
          // $FlowFixMe `_blocks` may not be present
          var args = b._blocks != null ? [b._blocks.length] : [];

          var bDetails = b._appendPlaceholder.apply(b, args);

          _this3._value += bDetails.inserted;
          details.aggregate(bDetails);
        }
      });

      return details;
    }
    /** Finds block in pos */

  }, {
    key: "_mapPosToBlock",
    value: function _mapPosToBlock(pos) {
      var accVal = '';

      for (var bi = 0; bi < this._blocks.length; ++bi) {
        var _block2 = this._blocks[bi];
        var blockStartPos = accVal.length;
        accVal += _block2.value;

        if (pos <= accVal.length) {
          return {
            index: bi,
            offset: pos - blockStartPos
          };
        }
      }
    }
    /** */

  }, {
    key: "_blockStartPos",
    value: function _blockStartPos(blockIndex) {
      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {
        return pos += b.value.length;
      }, 0);
    }
    /** */

  }, {
    key: "_forEachBlocksInRange",
    value: function _forEachBlocksInRange(fromPos) {
      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
      var fn = arguments.length > 2 ? arguments[2] : undefined;

      var fromBlockIter = this._mapPosToBlock(fromPos);

      if (fromBlockIter) {
        var toBlockIter = this._mapPosToBlock(toPos); // process first block


        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;
        var fromBlockStartPos = fromBlockIter.offset;
        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;
        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);

        if (toBlockIter && !isSameBlock) {
          // process intermediate blocks
          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {
            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);
          } // process last block


          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);
        }
      }
    }
    /**
      @override
    */

  }, {
    key: "remove",
    value: function remove() {
      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;

      var removeDetails = _get(_getPrototypeOf$1(MaskedPattern.prototype), "remove", this).call(this, fromPos, toPos);

      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {
        removeDetails.aggregate(b.remove(bFromPos, bToPos));
      });

      return removeDetails;
    }
    /**
      @override
    */

  }, {
    key: "nearestInputPos",
    value: function nearestInputPos(cursorPos) {
      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;
      // TODO refactor - extract alignblock
      var beginBlockData = this._mapPosToBlock(cursorPos) || {
        index: 0,
        offset: 0
      };
      var beginBlockOffset = beginBlockData.offset,
          beginBlockIndex = beginBlockData.index;
      var beginBlock = this._blocks[beginBlockIndex];
      if (!beginBlock) return cursorPos;
      var beginBlockCursorPos = beginBlockOffset; // if position inside block - try to adjust it

      if (beginBlockCursorPos !== 0 && beginBlockCursorPos < beginBlock.value.length) {
        beginBlockCursorPos = beginBlock.nearestInputPos(beginBlockOffset, forceDirection(direction));
      }

      var cursorAtRight = beginBlockCursorPos === beginBlock.value.length;
      var cursorAtLeft = beginBlockCursorPos === 0; //  cursor is INSIDE first block (not at bounds)

      if (!cursorAtLeft && !cursorAtRight) return this._blockStartPos(beginBlockIndex) + beginBlockCursorPos;
      var searchBlockIndex = cursorAtRight ? beginBlockIndex + 1 : beginBlockIndex;

      if (direction === DIRECTION.NONE) {
        // NONE direction used to calculate start input position if no chars were removed
        // FOR NONE:
        // -
        // input|any
        // ->
        //  any|input
        // <-
        //  filled-input|any
        // check if first block at left is input
        if (searchBlockIndex > 0) {
          var blockIndexAtLeft = searchBlockIndex - 1;
          var blockAtLeft = this._blocks[blockIndexAtLeft];
          var blockInputPos = blockAtLeft.nearestInputPos(0, DIRECTION.NONE); // is input

          if (!blockAtLeft.value.length || blockInputPos !== blockAtLeft.value.length) {
            return this._blockStartPos(searchBlockIndex);
          }
        } // ->


        var firstInputAtRight = searchBlockIndex;

        for (var bi = firstInputAtRight; bi < this._blocks.length; ++bi) {
          var blockAtRight = this._blocks[bi];

          var _blockInputPos = blockAtRight.nearestInputPos(0, DIRECTION.NONE);

          if (!blockAtRight.value.length || _blockInputPos !== blockAtRight.value.length) {
            return this._blockStartPos(bi) + _blockInputPos;
          }
        } // <-
        // find first non-fixed symbol


        for (var _bi = searchBlockIndex - 1; _bi >= 0; --_bi) {
          var _block3 = this._blocks[_bi];

          var _blockInputPos2 = _block3.nearestInputPos(0, DIRECTION.NONE); // is input


          if (!_block3.value.length || _blockInputPos2 !== _block3.value.length) {
            return this._blockStartPos(_bi) + _block3.value.length;
          }
        }

        return cursorPos;
      }

      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {
        // -
        //  any|filled-input
        // <-
        //  any|first not empty is not-len-aligned
        //  not-0-aligned|any
        // ->
        //  any|not-len-aligned or end
        // check if first block at right is filled input
        var firstFilledBlockIndexAtRight;

        for (var _bi2 = searchBlockIndex; _bi2 < this._blocks.length; ++_bi2) {
          if (this._blocks[_bi2].value) {
            firstFilledBlockIndexAtRight = _bi2;
            break;
          }
        }

        if (firstFilledBlockIndexAtRight != null) {
          var filledBlock = this._blocks[firstFilledBlockIndexAtRight];

          var _blockInputPos3 = filledBlock.nearestInputPos(0, DIRECTION.RIGHT);

          if (_blockInputPos3 === 0 && filledBlock.unmaskedValue.length) {
            // filled block is input
            return this._blockStartPos(firstFilledBlockIndexAtRight) + _blockInputPos3;
          }
        } // <-
        // find this vars


        var firstFilledInputBlockIndex = -1;
        var firstEmptyInputBlockIndex; // TODO consider nested empty inputs

        for (var _bi3 = searchBlockIndex - 1; _bi3 >= 0; --_bi3) {
          var _block4 = this._blocks[_bi3];

          var _blockInputPos4 = _block4.nearestInputPos(_block4.value.length, DIRECTION.FORCE_LEFT);

          if (!_block4.value || _blockInputPos4 !== 0) firstEmptyInputBlockIndex = _bi3;

          if (_blockInputPos4 !== 0) {
            if (_blockInputPos4 !== _block4.value.length) {
              // aligned inside block - return immediately
              return this._blockStartPos(_bi3) + _blockInputPos4;
            } else {
              // found filled
              firstFilledInputBlockIndex = _bi3;
              break;
            }
          }
        }

        if (direction === DIRECTION.LEFT) {
          // try find first empty input before start searching position only when not forced
          for (var _bi4 = firstFilledInputBlockIndex + 1; _bi4 <= Math.min(searchBlockIndex, this._blocks.length - 1); ++_bi4) {
            var _block5 = this._blocks[_bi4];

            var _blockInputPos5 = _block5.nearestInputPos(0, DIRECTION.NONE);

            var blockAlignedPos = this._blockStartPos(_bi4) + _blockInputPos5;

            if (blockAlignedPos > cursorPos) break; // if block is not lazy input

            if (_blockInputPos5 !== _block5.value.length) return blockAlignedPos;
          }
        } // process overflow


        if (firstFilledInputBlockIndex >= 0) {
          return this._blockStartPos(firstFilledInputBlockIndex) + this._blocks[firstFilledInputBlockIndex].value.length;
        } // for lazy if has aligned left inside fixed and has came to the start - use start position


        if (direction === DIRECTION.FORCE_LEFT || this.lazy && !this.extractInput() && !isInput(this._blocks[searchBlockIndex])) {
          return 0;
        }

        if (firstEmptyInputBlockIndex != null) {
          return this._blockStartPos(firstEmptyInputBlockIndex);
        } // find first input


        for (var _bi5 = searchBlockIndex; _bi5 < this._blocks.length; ++_bi5) {
          var _block6 = this._blocks[_bi5];

          var _blockInputPos6 = _block6.nearestInputPos(0, DIRECTION.NONE); // is input


          if (!_block6.value.length || _blockInputPos6 !== _block6.value.length) {
            return this._blockStartPos(_bi5) + _blockInputPos6;
          }
        }

        return 0;
      }

      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {
        // ->
        //  any|not-len-aligned and filled
        //  any|not-len-aligned
        // <-
        //  not-0-aligned or start|any
        var firstInputBlockAlignedIndex;
        var firstInputBlockAlignedPos;

        for (var _bi6 = searchBlockIndex; _bi6 < this._blocks.length; ++_bi6) {
          var _block7 = this._blocks[_bi6];

          var _blockInputPos7 = _block7.nearestInputPos(0, DIRECTION.NONE);

          if (_blockInputPos7 !== _block7.value.length) {
            firstInputBlockAlignedPos = this._blockStartPos(_bi6) + _blockInputPos7;
            firstInputBlockAlignedIndex = _bi6;
            break;
          }
        }

        if (firstInputBlockAlignedIndex != null && firstInputBlockAlignedPos != null) {
          for (var _bi7 = firstInputBlockAlignedIndex; _bi7 < this._blocks.length; ++_bi7) {
            var _block8 = this._blocks[_bi7];

            var _blockInputPos8 = _block8.nearestInputPos(0, DIRECTION.FORCE_RIGHT);

            if (_blockInputPos8 !== _block8.value.length) {
              return this._blockStartPos(_bi7) + _blockInputPos8;
            }
          }

          return direction === DIRECTION.FORCE_RIGHT ? this.value.length : firstInputBlockAlignedPos;
        }

        for (var _bi8 = Math.min(searchBlockIndex, this._blocks.length - 1); _bi8 >= 0; --_bi8) {
          var _block9 = this._blocks[_bi8];

          var _blockInputPos9 = _block9.nearestInputPos(_block9.value.length, DIRECTION.LEFT);

          if (_blockInputPos9 !== 0) {
            var alignedPos = this._blockStartPos(_bi8) + _blockInputPos9;

            if (alignedPos >= cursorPos) return alignedPos;
            break;
          }
        }
      }

      return cursorPos;
    }
    /** Get block by name */

  }, {
    key: "maskedBlock",
    value: function maskedBlock(name) {
      return this.maskedBlocks(name)[0];
    }
    /** Get all blocks by name */

  }, {
    key: "maskedBlocks",
    value: function maskedBlocks(name) {
      var _this4 = this;

      var indices = this._maskedBlocks[name];
      if (!indices) return [];
      return indices.map(function (gi) {
        return _this4._blocks[gi];
      });
    }
  }]);

  return MaskedPattern;
}(Masked);
MaskedPattern.DEFAULTS = {
  lazy: true,
  placeholderChar: '_'
};
MaskedPattern.STOP_CHAR = '`';
MaskedPattern.ESCAPE_CHAR = '\\';
MaskedPattern.InputDefinition = PatternInputDefinition;
MaskedPattern.FixedDefinition = PatternFixedDefinition;

function isInput(block) {
  if (!block) return false;
  var value = block.value;
  return !value || block.nearestInputPos(0, DIRECTION.NONE) !== value.length;
}

IMask.MaskedPattern = MaskedPattern;

/** Pattern which accepts ranges */

var MaskedRange = /*#__PURE__*/function (_MaskedPattern) {
  _inherits$1(MaskedRange, _MaskedPattern);

  var _super = _createSuper$1(MaskedRange);

  function MaskedRange() {
    _classCallCheck$1(this, MaskedRange);

    return _super.apply(this, arguments);
  }

  _createClass$1(MaskedRange, [{
    key: "_matchFrom",
    get:
    /**
      Optionally sets max length of pattern.
      Used when pattern length is longer then `to` param length. Pads zeros at start in this case.
    */

    /** Min bound */

    /** Max bound */

    /** */
    function get() {
      return this.maxLength - String(this.from).length;
    }
    /**
      @override
    */

  }, {
    key: "_update",
    value: function _update(opts) {
      // TODO type
      opts = Object.assign({
        to: this.to || 0,
        from: this.from || 0
      }, opts);
      var maxLength = String(opts.to).length;
      if (opts.maxLength != null) maxLength = Math.max(maxLength, opts.maxLength);
      opts.maxLength = maxLength;
      var fromStr = String(opts.from).padStart(maxLength, '0');
      var toStr = String(opts.to).padStart(maxLength, '0');
      var sameCharsCount = 0;

      while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) {
        ++sameCharsCount;
      }

      opts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\0') + '0'.repeat(maxLength - sameCharsCount);

      _get(_getPrototypeOf$1(MaskedRange.prototype), "_update", this).call(this, opts);
    }
    /**
      @override
    */

  }, {
    key: "isComplete",
    get: function get() {
      return _get(_getPrototypeOf$1(MaskedRange.prototype), "isComplete", this) && Boolean(this.value);
    }
  }, {
    key: "boundaries",
    value: function boundaries(str) {
      var minstr = '';
      var maxstr = '';

      var _ref = str.match(/^(\D*)(\d*)(\D*)/) || [],
          _ref2 = _slicedToArray(_ref, 3),
          placeholder = _ref2[1],
          num = _ref2[2];

      if (num) {
        minstr = '0'.repeat(placeholder.length) + num;
        maxstr = '9'.repeat(placeholder.length) + num;
      }

      minstr = minstr.padEnd(this.maxLength, '0');
      maxstr = maxstr.padEnd(this.maxLength, '9');
      return [minstr, maxstr];
    }
    /**
      @override
    */

  }, {
    key: "doPrepare",
    value: function doPrepare(str) {
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      str = _get(_getPrototypeOf$1(MaskedRange.prototype), "doPrepare", this).call(this, str, flags).replace(/\D/g, '');
      if (!this.autofix) return str;
      var fromStr = String(this.from).padStart(this.maxLength, '0');
      var toStr = String(this.to).padStart(this.maxLength, '0');
      var val = this.value;
      var prepStr = '';

      for (var ci = 0; ci < str.length; ++ci) {
        var nextVal = val + prepStr + str[ci];

        var _this$boundaries = this.boundaries(nextVal),
            _this$boundaries2 = _slicedToArray(_this$boundaries, 2),
            minstr = _this$boundaries2[0],
            maxstr = _this$boundaries2[1];

        if (Number(maxstr) < this.from) prepStr += fromStr[nextVal.length - 1];else if (Number(minstr) > this.to) prepStr += toStr[nextVal.length - 1];else prepStr += str[ci];
      }

      return prepStr;
    }
    /**
      @override
    */

  }, {
    key: "doValidate",
    value: function doValidate() {
      var _get2;

      var str = this.value;
      var firstNonZero = str.search(/[^0]/);
      if (firstNonZero === -1 && str.length <= this._matchFrom) return true;

      var _this$boundaries3 = this.boundaries(str),
          _this$boundaries4 = _slicedToArray(_this$boundaries3, 2),
          minstr = _this$boundaries4[0],
          maxstr = _this$boundaries4[1];

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.from <= Number(maxstr) && Number(minstr) <= this.to && (_get2 = _get(_getPrototypeOf$1(MaskedRange.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));
    }
  }]);

  return MaskedRange;
}(MaskedPattern);
IMask.MaskedRange = MaskedRange;

/** Date mask */

var MaskedDate = /*#__PURE__*/function (_MaskedPattern) {
  _inherits$1(MaskedDate, _MaskedPattern);

  var _super = _createSuper$1(MaskedDate);

  /** Pattern mask for date according to {@link MaskedDate#format} */

  /** Start date */

  /** End date */

  /** */

  /**
    @param {Object} opts
  */
  function MaskedDate(opts) {
    _classCallCheck$1(this, MaskedDate);

    return _super.call(this, Object.assign({}, MaskedDate.DEFAULTS, opts));
  }
  /**
    @override
  */


  _createClass$1(MaskedDate, [{
    key: "_update",
    value: function _update(opts) {
      if (opts.mask === Date) delete opts.mask;
      if (opts.pattern) opts.mask = opts.pattern;
      var blocks = opts.blocks;
      opts.blocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS()); // adjust year block

      if (opts.min) opts.blocks.Y.from = opts.min.getFullYear();
      if (opts.max) opts.blocks.Y.to = opts.max.getFullYear();

      if (opts.min && opts.max && opts.blocks.Y.from === opts.blocks.Y.to) {
        opts.blocks.m.from = opts.min.getMonth() + 1;
        opts.blocks.m.to = opts.max.getMonth() + 1;

        if (opts.blocks.m.from === opts.blocks.m.to) {
          opts.blocks.d.from = opts.min.getDate();
          opts.blocks.d.to = opts.max.getDate();
        }
      }

      Object.assign(opts.blocks, blocks); // add autofix

      Object.keys(opts.blocks).forEach(function (bk) {
        var b = opts.blocks[bk];
        if (!('autofix' in b)) b.autofix = opts.autofix;
      });

      _get(_getPrototypeOf$1(MaskedDate.prototype), "_update", this).call(this, opts);
    }
    /**
      @override
    */

  }, {
    key: "doValidate",
    value: function doValidate() {
      var _get2;

      var date = this.date;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_get2 = _get(_getPrototypeOf$1(MaskedDate.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args)) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));
    }
    /** Checks if date is exists */

  }, {
    key: "isDateExist",
    value: function isDateExist(str) {
      return this.format(this.parse(str, this), this).indexOf(str) >= 0;
    }
    /** Parsed Date */

  }, {
    key: "date",
    get: function get() {
      return this.typedValue;
    },
    set: function set(date) {
      this.typedValue = date;
    }
    /**
      @override
    */

  }, {
    key: "typedValue",
    get: function get() {
      return this.isComplete ? _get(_getPrototypeOf$1(MaskedDate.prototype), "typedValue", this) : null;
    },
    set: function set(value) {
      _set(_getPrototypeOf$1(MaskedDate.prototype), "typedValue", value, this, true);
    }
  }]);

  return MaskedDate;
}(MaskedPattern);
MaskedDate.DEFAULTS = {
  pattern: 'd{.}`m{.}`Y',
  format: function format(date) {
    var day = String(date.getDate()).padStart(2, '0');
    var month = String(date.getMonth() + 1).padStart(2, '0');
    var year = date.getFullYear();
    return [day, month, year].join('.');
  },
  parse: function parse(str) {
    var _str$split = str.split('.'),
        _str$split2 = _slicedToArray(_str$split, 3),
        day = _str$split2[0],
        month = _str$split2[1],
        year = _str$split2[2];

    return new Date(year, month - 1, day);
  }
};

MaskedDate.GET_DEFAULT_BLOCKS = function () {
  return {
    d: {
      mask: MaskedRange,
      from: 1,
      to: 31,
      maxLength: 2
    },
    m: {
      mask: MaskedRange,
      from: 1,
      to: 12,
      maxLength: 2
    },
    Y: {
      mask: MaskedRange,
      from: 1900,
      to: 9999
    }
  };
};

IMask.MaskedDate = MaskedDate;

/**
  Generic element API to use with mask
  @interface
*/
var MaskElement = /*#__PURE__*/function () {
  function MaskElement() {
    _classCallCheck$1(this, MaskElement);
  }

  _createClass$1(MaskElement, [{
    key: "selectionStart",
    get:
    /** */

    /** */

    /** */

    /** Safely returns selection start */
    function get() {
      var start;

      try {
        start = this._unsafeSelectionStart;
      } catch (e) {}

      return start != null ? start : this.value.length;
    }
    /** Safely returns selection end */

  }, {
    key: "selectionEnd",
    get: function get() {
      var end;

      try {
        end = this._unsafeSelectionEnd;
      } catch (e) {}

      return end != null ? end : this.value.length;
    }
    /** Safely sets element selection */

  }, {
    key: "select",
    value: function select(start, end) {
      if (start == null || end == null || start === this.selectionStart && end === this.selectionEnd) return;

      try {
        this._unsafeSelect(start, end);
      } catch (e) {}
    }
    /** Should be overriden in subclasses */

  }, {
    key: "_unsafeSelect",
    value: function _unsafeSelect(start, end) {}
    /** Should be overriden in subclasses */

  }, {
    key: "isActive",
    get: function get() {
      return false;
    }
    /** Should be overriden in subclasses */

  }, {
    key: "bindEvents",
    value: function bindEvents(handlers) {}
    /** Should be overriden in subclasses */

  }, {
    key: "unbindEvents",
    value: function unbindEvents() {}
  }]);

  return MaskElement;
}();
IMask.MaskElement = MaskElement;

/** Bridge between HTMLElement and {@link Masked} */

var HTMLMaskElement = /*#__PURE__*/function (_MaskElement) {
  _inherits$1(HTMLMaskElement, _MaskElement);

  var _super = _createSuper$1(HTMLMaskElement);

  /** Mapping between HTMLElement events and mask internal events */

  /** HTMLElement to use mask on */

  /**
    @param {HTMLInputElement|HTMLTextAreaElement} input
  */
  function HTMLMaskElement(input) {
    var _this;

    _classCallCheck$1(this, HTMLMaskElement);

    _this = _super.call(this);
    _this.input = input;
    _this._handlers = {};
    return _this;
  }
  /** */
  // $FlowFixMe https://github.com/facebook/flow/issues/2839


  _createClass$1(HTMLMaskElement, [{
    key: "rootElement",
    get: function get() {
      return this.input.getRootNode ? this.input.getRootNode() : document;
    }
    /**
      Is element in focus
      @readonly
    */

  }, {
    key: "isActive",
    get: function get() {
      //$FlowFixMe
      return this.input === this.rootElement.activeElement;
    }
    /**
      Returns HTMLElement selection start
      @override
    */

  }, {
    key: "_unsafeSelectionStart",
    get: function get() {
      return this.input.selectionStart;
    }
    /**
      Returns HTMLElement selection end
      @override
    */

  }, {
    key: "_unsafeSelectionEnd",
    get: function get() {
      return this.input.selectionEnd;
    }
    /**
      Sets HTMLElement selection
      @override
    */

  }, {
    key: "_unsafeSelect",
    value: function _unsafeSelect(start, end) {
      this.input.setSelectionRange(start, end);
    }
    /**
      HTMLElement value
      @override
    */

  }, {
    key: "value",
    get: function get() {
      return this.input.value;
    },
    set: function set(value) {
      this.input.value = value;
    }
    /**
      Binds HTMLElement events to mask internal events
      @override
    */

  }, {
    key: "bindEvents",
    value: function bindEvents(handlers) {
      var _this2 = this;

      Object.keys(handlers).forEach(function (event) {
        return _this2._toggleEventHandler(HTMLMaskElement.EVENTS_MAP[event], handlers[event]);
      });
    }
    /**
      Unbinds HTMLElement events to mask internal events
      @override
    */

  }, {
    key: "unbindEvents",
    value: function unbindEvents() {
      var _this3 = this;

      Object.keys(this._handlers).forEach(function (event) {
        return _this3._toggleEventHandler(event);
      });
    }
    /** */

  }, {
    key: "_toggleEventHandler",
    value: function _toggleEventHandler(event, handler) {
      if (this._handlers[event]) {
        this.input.removeEventListener(event, this._handlers[event]);
        delete this._handlers[event];
      }

      if (handler) {
        this.input.addEventListener(event, handler);
        this._handlers[event] = handler;
      }
    }
  }]);

  return HTMLMaskElement;
}(MaskElement);
HTMLMaskElement.EVENTS_MAP = {
  selectionChange: 'keydown',
  input: 'input',
  drop: 'drop',
  click: 'click',
  focus: 'focus',
  commit: 'blur'
};
IMask.HTMLMaskElement = HTMLMaskElement;

var HTMLContenteditableMaskElement = /*#__PURE__*/function (_HTMLMaskElement) {
  _inherits$1(HTMLContenteditableMaskElement, _HTMLMaskElement);

  var _super = _createSuper$1(HTMLContenteditableMaskElement);

  function HTMLContenteditableMaskElement() {
    _classCallCheck$1(this, HTMLContenteditableMaskElement);

    return _super.apply(this, arguments);
  }

  _createClass$1(HTMLContenteditableMaskElement, [{
    key: "_unsafeSelectionStart",
    get:
    /**
      Returns HTMLElement selection start
      @override
    */
    function get() {
      var root = this.rootElement;
      var selection = root.getSelection && root.getSelection();
      return selection && selection.anchorOffset;
    }
    /**
      Returns HTMLElement selection end
      @override
    */

  }, {
    key: "_unsafeSelectionEnd",
    get: function get() {
      var root = this.rootElement;
      var selection = root.getSelection && root.getSelection();
      return selection && this._unsafeSelectionStart + String(selection).length;
    }
    /**
      Sets HTMLElement selection
      @override
    */

  }, {
    key: "_unsafeSelect",
    value: function _unsafeSelect(start, end) {
      if (!this.rootElement.createRange) return;
      var range = this.rootElement.createRange();
      range.setStart(this.input.firstChild || this.input, start);
      range.setEnd(this.input.lastChild || this.input, end);
      var root = this.rootElement;
      var selection = root.getSelection && root.getSelection();

      if (selection) {
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }
    /**
      HTMLElement value
      @override
    */

  }, {
    key: "value",
    get: function get() {
      // $FlowFixMe
      return this.input.textContent;
    },
    set: function set(value) {
      this.input.textContent = value;
    }
  }]);

  return HTMLContenteditableMaskElement;
}(HTMLMaskElement);
IMask.HTMLContenteditableMaskElement = HTMLContenteditableMaskElement;

var _excluded$2 = ["mask"];
/** Listens to element events and controls changes between element and {@link Masked} */

var InputMask = /*#__PURE__*/function () {
  /**
    View element
    @readonly
  */

  /**
    Internal {@link Masked} model
    @readonly
  */

  /**
    @param {MaskElement|HTMLInputElement|HTMLTextAreaElement} el
    @param {Object} opts
  */
  function InputMask(el, opts) {
    _classCallCheck$1(this, InputMask);

    this.el = el instanceof MaskElement ? el : el.isContentEditable && el.tagName !== 'INPUT' && el.tagName !== 'TEXTAREA' ? new HTMLContenteditableMaskElement(el) : new HTMLMaskElement(el);
    this.masked = createMask(opts);
    this._listeners = {};
    this._value = '';
    this._unmaskedValue = '';
    this._saveSelection = this._saveSelection.bind(this);
    this._onInput = this._onInput.bind(this);
    this._onChange = this._onChange.bind(this);
    this._onDrop = this._onDrop.bind(this);
    this._onFocus = this._onFocus.bind(this);
    this._onClick = this._onClick.bind(this);
    this.alignCursor = this.alignCursor.bind(this);
    this.alignCursorFriendly = this.alignCursorFriendly.bind(this);

    this._bindEvents(); // refresh


    this.updateValue();

    this._onChange();
  }
  /** Read or update mask */


  _createClass$1(InputMask, [{
    key: "mask",
    get: function get() {
      return this.masked.mask;
    },
    set: function set(mask) {
      if (this.maskEquals(mask)) return;

      if (!(mask instanceof IMask.Masked) && this.masked.constructor === maskedClass(mask)) {
        this.masked.updateOptions({
          mask: mask
        });
        return;
      }

      var masked = createMask({
        mask: mask
      });
      masked.unmaskedValue = this.masked.unmaskedValue;
      this.masked = masked;
    }
    /** Raw value */

  }, {
    key: "maskEquals",
    value: function maskEquals(mask) {
      return mask == null || mask === this.masked.mask || mask === Date && this.masked instanceof MaskedDate;
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    },
    set: function set(str) {
      this.masked.value = str;
      this.updateControl();
      this.alignCursor();
    }
    /** Unmasked value */

  }, {
    key: "unmaskedValue",
    get: function get() {
      return this._unmaskedValue;
    },
    set: function set(str) {
      this.masked.unmaskedValue = str;
      this.updateControl();
      this.alignCursor();
    }
    /** Typed unmasked value */

  }, {
    key: "typedValue",
    get: function get() {
      return this.masked.typedValue;
    },
    set: function set(val) {
      this.masked.typedValue = val;
      this.updateControl();
      this.alignCursor();
    }
    /**
      Starts listening to element events
      @protected
    */

  }, {
    key: "_bindEvents",
    value: function _bindEvents() {
      this.el.bindEvents({
        selectionChange: this._saveSelection,
        input: this._onInput,
        drop: this._onDrop,
        click: this._onClick,
        focus: this._onFocus,
        commit: this._onChange
      });
    }
    /**
      Stops listening to element events
      @protected
     */

  }, {
    key: "_unbindEvents",
    value: function _unbindEvents() {
      if (this.el) this.el.unbindEvents();
    }
    /**
      Fires custom event
      @protected
     */

  }, {
    key: "_fireEvent",
    value: function _fireEvent(ev) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var listeners = this._listeners[ev];
      if (!listeners) return;
      listeners.forEach(function (l) {
        return l.apply(void 0, args);
      });
    }
    /**
      Current selection start
      @readonly
    */

  }, {
    key: "selectionStart",
    get: function get() {
      return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
    }
    /** Current cursor position */

  }, {
    key: "cursorPos",
    get: function get() {
      return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
    },
    set: function set(pos) {
      if (!this.el || !this.el.isActive) return;
      this.el.select(pos, pos);

      this._saveSelection();
    }
    /**
      Stores current selection
      @protected
    */

  }, {
    key: "_saveSelection",
    value: function _saveSelection()
    /* ev */
    {
      if (this.value !== this.el.value) {
        console.warn('Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly.'); // eslint-disable-line no-console
      }

      this._selection = {
        start: this.selectionStart,
        end: this.cursorPos
      };
    }
    /** Syncronizes model value from view */

  }, {
    key: "updateValue",
    value: function updateValue() {
      this.masked.value = this.el.value;
      this._value = this.masked.value;
    }
    /** Syncronizes view from model value, fires change events */

  }, {
    key: "updateControl",
    value: function updateControl() {
      var newUnmaskedValue = this.masked.unmaskedValue;
      var newValue = this.masked.value;
      var isChanged = this.unmaskedValue !== newUnmaskedValue || this.value !== newValue;
      this._unmaskedValue = newUnmaskedValue;
      this._value = newValue;
      if (this.el.value !== newValue) this.el.value = newValue;
      if (isChanged) this._fireChangeEvents();
    }
    /** Updates options with deep equal check, recreates @{link Masked} model if mask type changes */

  }, {
    key: "updateOptions",
    value: function updateOptions(opts) {
      var mask = opts.mask,
          restOpts = _objectWithoutProperties$1(opts, _excluded$2);

      var updateMask = !this.maskEquals(mask);
      var updateOpts = !objectIncludes(this.masked, restOpts);
      if (updateMask) this.mask = mask;
      if (updateOpts) this.masked.updateOptions(restOpts);
      if (updateMask || updateOpts) this.updateControl();
    }
    /** Updates cursor */

  }, {
    key: "updateCursor",
    value: function updateCursor(cursorPos) {
      if (cursorPos == null) return;
      this.cursorPos = cursorPos; // also queue change cursor for mobile browsers

      this._delayUpdateCursor(cursorPos);
    }
    /**
      Delays cursor update to support mobile browsers
      @private
    */

  }, {
    key: "_delayUpdateCursor",
    value: function _delayUpdateCursor(cursorPos) {
      var _this = this;

      this._abortUpdateCursor();

      this._changingCursorPos = cursorPos;
      this._cursorChanging = setTimeout(function () {
        if (!_this.el) return; // if was destroyed

        _this.cursorPos = _this._changingCursorPos;

        _this._abortUpdateCursor();
      }, 10);
    }
    /**
      Fires custom events
      @protected
    */

  }, {
    key: "_fireChangeEvents",
    value: function _fireChangeEvents() {
      this._fireEvent('accept', this._inputEvent);

      if (this.masked.isComplete) this._fireEvent('complete', this._inputEvent);
    }
    /**
      Aborts delayed cursor update
      @private
    */

  }, {
    key: "_abortUpdateCursor",
    value: function _abortUpdateCursor() {
      if (this._cursorChanging) {
        clearTimeout(this._cursorChanging);
        delete this._cursorChanging;
      }
    }
    /** Aligns cursor to nearest available position */

  }, {
    key: "alignCursor",
    value: function alignCursor() {
      this.cursorPos = this.masked.nearestInputPos(this.cursorPos, DIRECTION.LEFT);
    }
    /** Aligns cursor only if selection is empty */

  }, {
    key: "alignCursorFriendly",
    value: function alignCursorFriendly() {
      if (this.selectionStart !== this.cursorPos) return; // skip if range is selected

      this.alignCursor();
    }
    /** Adds listener on custom event */

  }, {
    key: "on",
    value: function on(ev, handler) {
      if (!this._listeners[ev]) this._listeners[ev] = [];

      this._listeners[ev].push(handler);

      return this;
    }
    /** Removes custom event listener */

  }, {
    key: "off",
    value: function off(ev, handler) {
      if (!this._listeners[ev]) return this;

      if (!handler) {
        delete this._listeners[ev];
        return this;
      }

      var hIndex = this._listeners[ev].indexOf(handler);

      if (hIndex >= 0) this._listeners[ev].splice(hIndex, 1);
      return this;
    }
    /** Handles view input event */

  }, {
    key: "_onInput",
    value: function _onInput(e) {
      this._inputEvent = e;

      this._abortUpdateCursor(); // fix strange IE behavior


      if (!this._selection) return this.updateValue();
      var details = new ActionDetails( // new state
      this.el.value, this.cursorPos, // old state
      this.value, this._selection);
      var oldRawValue = this.masked.rawInputValue;
      var offset = this.masked.splice(details.startChangePos, details.removed.length, details.inserted, details.removeDirection).offset; // force align in remove direction only if no input chars were removed
      // otherwise we still need to align with NONE (to get out from fixed symbols for instance)

      var removeDirection = oldRawValue === this.masked.rawInputValue ? details.removeDirection : DIRECTION.NONE;
      var cursorPos = this.masked.nearestInputPos(details.startChangePos + offset, removeDirection);
      this.updateControl();
      this.updateCursor(cursorPos);
      delete this._inputEvent;
    }
    /** Handles view change event and commits model value */

  }, {
    key: "_onChange",
    value: function _onChange() {
      if (this.value !== this.el.value) {
        this.updateValue();
      }

      this.masked.doCommit();
      this.updateControl();

      this._saveSelection();
    }
    /** Handles view drop event, prevents by default */

  }, {
    key: "_onDrop",
    value: function _onDrop(ev) {
      ev.preventDefault();
      ev.stopPropagation();
    }
    /** Restore last selection on focus */

  }, {
    key: "_onFocus",
    value: function _onFocus(ev) {
      this.alignCursorFriendly();
    }
    /** Restore last selection on focus */

  }, {
    key: "_onClick",
    value: function _onClick(ev) {
      this.alignCursorFriendly();
    }
    /** Unbind view events and removes element reference */

  }, {
    key: "destroy",
    value: function destroy() {
      this._unbindEvents(); // $FlowFixMe why not do so?


      this._listeners.length = 0; // $FlowFixMe

      delete this.el;
    }
  }]);

  return InputMask;
}();
IMask.InputMask = InputMask;

/** Pattern which validates enum values */

var MaskedEnum = /*#__PURE__*/function (_MaskedPattern) {
  _inherits$1(MaskedEnum, _MaskedPattern);

  var _super = _createSuper$1(MaskedEnum);

  function MaskedEnum() {
    _classCallCheck$1(this, MaskedEnum);

    return _super.apply(this, arguments);
  }

  _createClass$1(MaskedEnum, [{
    key: "_update",
    value:
    /**
      @override
      @param {Object} opts
    */
    function _update(opts) {
      // TODO type
      if (opts.enum) opts.mask = '*'.repeat(opts.enum[0].length);

      _get(_getPrototypeOf$1(MaskedEnum.prototype), "_update", this).call(this, opts);
    }
    /**
      @override
    */

  }, {
    key: "doValidate",
    value: function doValidate() {
      var _this = this,
          _get2;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.enum.some(function (e) {
        return e.indexOf(_this.unmaskedValue) >= 0;
      }) && (_get2 = _get(_getPrototypeOf$1(MaskedEnum.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args));
    }
  }]);

  return MaskedEnum;
}(MaskedPattern);
IMask.MaskedEnum = MaskedEnum;

/**
  Number mask
  @param {Object} opts
  @param {string} opts.radix - Single char
  @param {string} opts.thousandsSeparator - Single char
  @param {Array<string>} opts.mapToRadix - Array of single chars
  @param {number} opts.min
  @param {number} opts.max
  @param {number} opts.scale - Digits after point
  @param {boolean} opts.signed - Allow negative
  @param {boolean} opts.normalizeZeros - Flag to remove leading and trailing zeros in the end of editing
  @param {boolean} opts.padFractionalZeros - Flag to pad trailing zeros after point in the end of editing
*/
var MaskedNumber = /*#__PURE__*/function (_Masked) {
  _inherits$1(MaskedNumber, _Masked);

  var _super = _createSuper$1(MaskedNumber);

  /** Single char */

  /** Single char */

  /** Array of single chars */

  /** */

  /** */

  /** Digits after point */

  /** */

  /** Flag to remove leading and trailing zeros in the end of editing */

  /** Flag to pad trailing zeros after point in the end of editing */
  function MaskedNumber(opts) {
    _classCallCheck$1(this, MaskedNumber);

    return _super.call(this, Object.assign({}, MaskedNumber.DEFAULTS, opts));
  }
  /**
    @override
  */


  _createClass$1(MaskedNumber, [{
    key: "_update",
    value: function _update(opts) {
      _get(_getPrototypeOf$1(MaskedNumber.prototype), "_update", this).call(this, opts);

      this._updateRegExps();
    }
    /** */

  }, {
    key: "_updateRegExps",
    value: function _updateRegExps() {
      // use different regexp to process user input (more strict, input suffix) and tail shifting
      var start = '^' + (this.allowNegative ? '[+|\\-]?' : '');
      var midInput = '(0|([1-9]+\\d*))?';
      var mid = '\\d*';
      var end = (this.scale ? '(' + escapeRegExp(this.radix) + '\\d{0,' + this.scale + '})?' : '') + '$';
      this._numberRegExpInput = new RegExp(start + midInput + end);
      this._numberRegExp = new RegExp(start + mid + end);
      this._mapToRadixRegExp = new RegExp('[' + this.mapToRadix.map(escapeRegExp).join('') + ']', 'g');
      this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');
    }
    /** */

  }, {
    key: "_removeThousandsSeparators",
    value: function _removeThousandsSeparators(value) {
      return value.replace(this._thousandsSeparatorRegExp, '');
    }
    /** */

  }, {
    key: "_insertThousandsSeparators",
    value: function _insertThousandsSeparators(value) {
      // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript
      var parts = value.split(this.radix);
      parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator);
      return parts.join(this.radix);
    }
    /**
      @override
    */

  }, {
    key: "doPrepare",
    value: function doPrepare(str) {
      var _get2;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_get2 = _get(_getPrototypeOf$1(MaskedNumber.prototype), "doPrepare", this)).call.apply(_get2, [this, this._removeThousandsSeparators(str.replace(this._mapToRadixRegExp, this.radix))].concat(args));
    }
    /** */

  }, {
    key: "_separatorsCount",
    value: function _separatorsCount(to) {
      var extendOnSeparators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var count = 0;

      for (var pos = 0; pos < to; ++pos) {
        if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {
          ++count;
          if (extendOnSeparators) to += this.thousandsSeparator.length;
        }
      }

      return count;
    }
    /** */

  }, {
    key: "_separatorsCountFromSlice",
    value: function _separatorsCountFromSlice() {
      var slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._value;
      return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);
    }
    /**
      @override
    */

  }, {
    key: "extractInput",
    value: function extractInput() {
      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;
      var flags = arguments.length > 2 ? arguments[2] : undefined;

      var _this$_adjustRangeWit = this._adjustRangeWithSeparators(fromPos, toPos);

      var _this$_adjustRangeWit2 = _slicedToArray(_this$_adjustRangeWit, 2);

      fromPos = _this$_adjustRangeWit2[0];
      toPos = _this$_adjustRangeWit2[1];
      return this._removeThousandsSeparators(_get(_getPrototypeOf$1(MaskedNumber.prototype), "extractInput", this).call(this, fromPos, toPos, flags));
    }
    /**
      @override
    */

  }, {
    key: "_appendCharRaw",
    value: function _appendCharRaw(ch) {
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!this.thousandsSeparator) return _get(_getPrototypeOf$1(MaskedNumber.prototype), "_appendCharRaw", this).call(this, ch, flags);
      var prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;

      var prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);

      this._value = this._removeThousandsSeparators(this.value);

      var appendDetails = _get(_getPrototypeOf$1(MaskedNumber.prototype), "_appendCharRaw", this).call(this, ch, flags);

      this._value = this._insertThousandsSeparators(this._value);
      var beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;

      var beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);

      appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;
      appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;
      return appendDetails;
    }
    /** */

  }, {
    key: "_findSeparatorAround",
    value: function _findSeparatorAround(pos) {
      if (this.thousandsSeparator) {
        var searchFrom = pos - this.thousandsSeparator.length + 1;
        var separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);
        if (separatorPos <= pos) return separatorPos;
      }

      return -1;
    }
  }, {
    key: "_adjustRangeWithSeparators",
    value: function _adjustRangeWithSeparators(from, to) {
      var separatorAroundFromPos = this._findSeparatorAround(from);

      if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;

      var separatorAroundToPos = this._findSeparatorAround(to);

      if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;
      return [from, to];
    }
    /**
      @override
    */

  }, {
    key: "remove",
    value: function remove() {
      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;

      var _this$_adjustRangeWit3 = this._adjustRangeWithSeparators(fromPos, toPos);

      var _this$_adjustRangeWit4 = _slicedToArray(_this$_adjustRangeWit3, 2);

      fromPos = _this$_adjustRangeWit4[0];
      toPos = _this$_adjustRangeWit4[1];
      var valueBeforePos = this.value.slice(0, fromPos);
      var valueAfterPos = this.value.slice(toPos);

      var prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);

      this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));

      var beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);

      return new ChangeDetails({
        tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length
      });
    }
    /**
      @override
    */

  }, {
    key: "nearestInputPos",
    value: function nearestInputPos(cursorPos, direction) {
      if (!this.thousandsSeparator) return cursorPos;

      switch (direction) {
        case DIRECTION.NONE:
        case DIRECTION.LEFT:
        case DIRECTION.FORCE_LEFT:
          {
            var separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);

            if (separatorAtLeftPos >= 0) {
              var separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;

              if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {
                return separatorAtLeftPos;
              }
            }

            break;
          }

        case DIRECTION.RIGHT:
        case DIRECTION.FORCE_RIGHT:
          {
            var separatorAtRightPos = this._findSeparatorAround(cursorPos);

            if (separatorAtRightPos >= 0) {
              return separatorAtRightPos + this.thousandsSeparator.length;
            }
          }
      }

      return cursorPos;
    }
    /**
      @override
    */

  }, {
    key: "doValidate",
    value: function doValidate(flags) {
      var regexp = flags.input ? this._numberRegExpInput : this._numberRegExp; // validate as string

      var valid = regexp.test(this._removeThousandsSeparators(this.value));

      if (valid) {
        // validate as number
        var number = this.number;
        valid = valid && !isNaN(number) && ( // check min bound for negative values
        this.min == null || this.min >= 0 || this.min <= this.number) && ( // check max bound for positive values
        this.max == null || this.max <= 0 || this.number <= this.max);
      }

      return valid && _get(_getPrototypeOf$1(MaskedNumber.prototype), "doValidate", this).call(this, flags);
    }
    /**
      @override
    */

  }, {
    key: "doCommit",
    value: function doCommit() {
      if (this.value) {
        var number = this.number;
        var validnum = number; // check bounds

        if (this.min != null) validnum = Math.max(validnum, this.min);
        if (this.max != null) validnum = Math.min(validnum, this.max);
        if (validnum !== number) this.unmaskedValue = String(validnum);
        var formatted = this.value;
        if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);
        if (this.padFractionalZeros) formatted = this._padFractionalZeros(formatted);
        this._value = formatted;
      }

      _get(_getPrototypeOf$1(MaskedNumber.prototype), "doCommit", this).call(this);
    }
    /** */

  }, {
    key: "_normalizeZeros",
    value: function _normalizeZeros(value) {
      var parts = this._removeThousandsSeparators(value).split(this.radix); // remove leading zeros


      parts[0] = parts[0].replace(/^(\D*)(0*)(\d*)/, function (match, sign, zeros, num) {
        return sign + num;
      }); // add leading zero

      if (value.length && !/\d$/.test(parts[0])) parts[0] = parts[0] + '0';

      if (parts.length > 1) {
        parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros

        if (!parts[1].length) parts.length = 1; // remove fractional
      }

      return this._insertThousandsSeparators(parts.join(this.radix));
    }
    /** */

  }, {
    key: "_padFractionalZeros",
    value: function _padFractionalZeros(value) {
      if (!value) return value;
      var parts = value.split(this.radix);
      if (parts.length < 2) parts.push('');
      parts[1] = parts[1].padEnd(this.scale, '0');
      return parts.join(this.radix);
    }
    /**
      @override
    */

  }, {
    key: "unmaskedValue",
    get: function get() {
      return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, '.');
    },
    set: function set(unmaskedValue) {
      _set(_getPrototypeOf$1(MaskedNumber.prototype), "unmaskedValue", unmaskedValue.replace('.', this.radix), this, true);
    }
    /**
      @override
    */

  }, {
    key: "typedValue",
    get: function get() {
      return Number(this.unmaskedValue);
    },
    set: function set(n) {
      _set(_getPrototypeOf$1(MaskedNumber.prototype), "unmaskedValue", String(n), this, true);
    }
    /** Parsed Number */

  }, {
    key: "number",
    get: function get() {
      return this.typedValue;
    },
    set: function set(number) {
      this.typedValue = number;
    }
    /**
      Is negative allowed
      @readonly
    */

  }, {
    key: "allowNegative",
    get: function get() {
      return this.signed || this.min != null && this.min < 0 || this.max != null && this.max < 0;
    }
  }]);

  return MaskedNumber;
}(Masked);
MaskedNumber.DEFAULTS = {
  radix: ',',
  thousandsSeparator: '',
  mapToRadix: ['.'],
  scale: 2,
  signed: false,
  normalizeZeros: true,
  padFractionalZeros: false
};
IMask.MaskedNumber = MaskedNumber;

/** Masking by custom Function */

var MaskedFunction = /*#__PURE__*/function (_Masked) {
  _inherits$1(MaskedFunction, _Masked);

  var _super = _createSuper$1(MaskedFunction);

  function MaskedFunction() {
    _classCallCheck$1(this, MaskedFunction);

    return _super.apply(this, arguments);
  }

  _createClass$1(MaskedFunction, [{
    key: "_update",
    value:
    /**
      @override
      @param {Object} opts
    */
    function _update(opts) {
      if (opts.mask) opts.validate = opts.mask;

      _get(_getPrototypeOf$1(MaskedFunction.prototype), "_update", this).call(this, opts);
    }
  }]);

  return MaskedFunction;
}(Masked);
IMask.MaskedFunction = MaskedFunction;

var _excluded$1 = ["compiledMasks", "currentMaskRef", "currentMask"];

/** Dynamic mask for choosing apropriate mask in run-time */
var MaskedDynamic = /*#__PURE__*/function (_Masked) {
  _inherits$1(MaskedDynamic, _Masked);

  var _super = _createSuper$1(MaskedDynamic);

  /** Currently chosen mask */

  /** Compliled {@link Masked} options */

  /** Chooses {@link Masked} depending on input value */

  /**
    @param {Object} opts
  */
  function MaskedDynamic(opts) {
    var _this;

    _classCallCheck$1(this, MaskedDynamic);

    _this = _super.call(this, Object.assign({}, MaskedDynamic.DEFAULTS, opts));
    _this.currentMask = null;
    return _this;
  }
  /**
    @override
  */


  _createClass$1(MaskedDynamic, [{
    key: "_update",
    value: function _update(opts) {
      _get(_getPrototypeOf$1(MaskedDynamic.prototype), "_update", this).call(this, opts);

      if ('mask' in opts) {
        // mask could be totally dynamic with only `dispatch` option
        this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(function (m) {
          return createMask(m);
        }) : [];
      }
    }
    /**
      @override
    */

  }, {
    key: "_appendCharRaw",
    value: function _appendCharRaw(ch) {
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var details = this._applyDispatch(ch, flags);

      if (this.currentMask) {
        details.aggregate(this.currentMask._appendChar(ch, flags));
      }

      return details;
    }
  }, {
    key: "_applyDispatch",
    value: function _applyDispatch() {
      var appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;
      var inputValue = this.rawInputValue;
      var insertValue = flags.tail && flags._beforeTailState != null ? // $FlowFixMe - tired to fight with type system
      flags._beforeTailState._rawInputValue : inputValue;
      var tailValue = inputValue.slice(insertValue.length);
      var prevMask = this.currentMask;
      var details = new ChangeDetails();
      var prevMaskState = prevMask && prevMask.state; // clone flags to prevent overwriting `_beforeTailState`

      this.currentMask = this.doDispatch(appended, Object.assign({}, flags)); // restore state after dispatch

      if (this.currentMask) {
        if (this.currentMask !== prevMask) {
          // if mask changed reapply input
          this.currentMask.reset();

          if (insertValue) {
            // $FlowFixMe - it's ok, we don't change current mask above
            var d = this.currentMask.append(insertValue, {
              raw: true
            });
            details.tailShift = d.inserted.length - prevValueBeforeTail.length;
          }

          if (tailValue) {
            // $FlowFixMe - it's ok, we don't change current mask above
            details.tailShift += this.currentMask.append(tailValue, {
              raw: true,
              tail: true
            }).tailShift;
          }
        } else {
          // Dispatch can do something bad with state, so
          // restore prev mask state
          this.currentMask.state = prevMaskState;
        }
      }

      return details;
    }
  }, {
    key: "_appendPlaceholder",
    value: function _appendPlaceholder() {
      var details = this._applyDispatch.apply(this, arguments);

      if (this.currentMask) {
        details.aggregate(this.currentMask._appendPlaceholder());
      }

      return details;
    }
    /**
      @override
    */

  }, {
    key: "doDispatch",
    value: function doDispatch(appended) {
      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.dispatch(appended, this, flags);
    }
    /**
      @override
    */

  }, {
    key: "doValidate",
    value: function doValidate() {
      var _get2, _this$currentMask;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_get2 = _get(_getPrototypeOf$1(MaskedDynamic.prototype), "doValidate", this)).call.apply(_get2, [this].concat(args)) && (!this.currentMask || (_this$currentMask = this.currentMask).doValidate.apply(_this$currentMask, args));
    }
    /**
      @override
    */

  }, {
    key: "reset",
    value: function reset() {
      if (this.currentMask) this.currentMask.reset();
      this.compiledMasks.forEach(function (m) {
        return m.reset();
      });
    }
    /**
      @override
    */

  }, {
    key: "value",
    get: function get() {
      return this.currentMask ? this.currentMask.value : '';
    },
    set: function set(value) {
      _set(_getPrototypeOf$1(MaskedDynamic.prototype), "value", value, this, true);
    }
    /**
      @override
    */

  }, {
    key: "unmaskedValue",
    get: function get() {
      return this.currentMask ? this.currentMask.unmaskedValue : '';
    },
    set: function set(unmaskedValue) {
      _set(_getPrototypeOf$1(MaskedDynamic.prototype), "unmaskedValue", unmaskedValue, this, true);
    }
    /**
      @override
    */

  }, {
    key: "typedValue",
    get: function get() {
      return this.currentMask ? this.currentMask.typedValue : '';
    } // probably typedValue should not be used with dynamic
    ,
    set: function set(value) {
      var unmaskedValue = String(value); // double check it

      if (this.currentMask) {
        this.currentMask.typedValue = value;
        unmaskedValue = this.currentMask.unmaskedValue;
      }

      this.unmaskedValue = unmaskedValue;
    }
    /**
      @override
    */

  }, {
    key: "isComplete",
    get: function get() {
      return !!this.currentMask && this.currentMask.isComplete;
    }
    /**
      @override
    */

  }, {
    key: "remove",
    value: function remove() {
      var details = new ChangeDetails();

      if (this.currentMask) {
        var _this$currentMask2;

        details.aggregate((_this$currentMask2 = this.currentMask).remove.apply(_this$currentMask2, arguments)) // update with dispatch
        .aggregate(this._applyDispatch());
      }

      return details;
    }
    /**
      @override
    */

  }, {
    key: "state",
    get: function get() {
      return Object.assign({}, _get(_getPrototypeOf$1(MaskedDynamic.prototype), "state", this), {
        _rawInputValue: this.rawInputValue,
        compiledMasks: this.compiledMasks.map(function (m) {
          return m.state;
        }),
        currentMaskRef: this.currentMask,
        currentMask: this.currentMask && this.currentMask.state
      });
    },
    set: function set(state) {
      var compiledMasks = state.compiledMasks,
          currentMaskRef = state.currentMaskRef,
          currentMask = state.currentMask,
          maskedState = _objectWithoutProperties$1(state, _excluded$1);

      this.compiledMasks.forEach(function (m, mi) {
        return m.state = compiledMasks[mi];
      });

      if (currentMaskRef != null) {
        this.currentMask = currentMaskRef;
        this.currentMask.state = currentMask;
      }

      _set(_getPrototypeOf$1(MaskedDynamic.prototype), "state", maskedState, this, true);
    }
    /**
      @override
    */

  }, {
    key: "extractInput",
    value: function extractInput() {
      var _this$currentMask3;

      return this.currentMask ? (_this$currentMask3 = this.currentMask).extractInput.apply(_this$currentMask3, arguments) : '';
    }
    /**
      @override
    */

  }, {
    key: "extractTail",
    value: function extractTail() {
      var _this$currentMask4, _get3;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return this.currentMask ? (_this$currentMask4 = this.currentMask).extractTail.apply(_this$currentMask4, args) : (_get3 = _get(_getPrototypeOf$1(MaskedDynamic.prototype), "extractTail", this)).call.apply(_get3, [this].concat(args));
    }
    /**
      @override
    */

  }, {
    key: "doCommit",
    value: function doCommit() {
      if (this.currentMask) this.currentMask.doCommit();

      _get(_getPrototypeOf$1(MaskedDynamic.prototype), "doCommit", this).call(this);
    }
    /**
      @override
    */

  }, {
    key: "nearestInputPos",
    value: function nearestInputPos() {
      var _this$currentMask5, _get4;

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this.currentMask ? (_this$currentMask5 = this.currentMask).nearestInputPos.apply(_this$currentMask5, args) : (_get4 = _get(_getPrototypeOf$1(MaskedDynamic.prototype), "nearestInputPos", this)).call.apply(_get4, [this].concat(args));
    }
  }, {
    key: "overwrite",
    get: function get() {
      return this.currentMask ? this.currentMask.overwrite : _get(_getPrototypeOf$1(MaskedDynamic.prototype), "overwrite", this);
    },
    set: function set(overwrite) {
      console.warn('"overwrite" option is not available in dynamic mask, use this option in siblings');
    }
  }]);

  return MaskedDynamic;
}(Masked);
MaskedDynamic.DEFAULTS = {
  dispatch: function dispatch(appended, masked, flags) {
    if (!masked.compiledMasks.length) return;
    var inputValue = masked.rawInputValue; // simulate input

    var inputs = masked.compiledMasks.map(function (m, index) {
      m.reset();
      m.append(inputValue, {
        raw: true
      });
      m.append(appended, flags);
      var weight = m.rawInputValue.length;
      return {
        weight: weight,
        index: index
      };
    }); // pop masks with longer values first

    inputs.sort(function (i1, i2) {
      return i2.weight - i1.weight;
    });
    return masked.compiledMasks[inputs[0].index];
  }
};
IMask.MaskedDynamic = MaskedDynamic;

/** Mask pipe source and destination types */

var PIPE_TYPE = {
  MASKED: 'value',
  UNMASKED: 'unmaskedValue',
  TYPED: 'typedValue'
};
/** Creates new pipe function depending on mask type, source and destination options */

function createPipe(mask) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PIPE_TYPE.MASKED;
  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PIPE_TYPE.MASKED;
  var masked = createMask(mask);
  return function (value) {
    return masked.runIsolated(function (m) {
      m[from] = value;
      return m[to];
    });
  };
}
/** Pipes value through mask depending on mask type, source and destination options */

function pipe(value) {
  for (var _len = arguments.length, pipeArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    pipeArgs[_key - 1] = arguments[_key];
  }

  return createPipe.apply(void 0, pipeArgs)(value);
}
IMask.PIPE_TYPE = PIPE_TYPE;
IMask.createPipe = createPipe;
IMask.pipe = pipe;

try {
  globalThis.IMask = IMask;
} catch (e) {}

var propTypes = {exports: {}};

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret$1 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

Function.call.bind(Object.prototype.hasOwnProperty);

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret = ReactPropTypesSecret_1;

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  }  shim.isRequired = shim;
  function getShim() {
    return shim;
  }  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

{
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  propTypes.exports = factoryWithThrowingShims();
}

var PropTypes = propTypes.exports;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose$1(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

var MASK_PROPS = {
  // common
  mask: PropTypes.oneOfType([PropTypes.array, PropTypes.func, PropTypes.string, PropTypes.instanceOf(RegExp), PropTypes.oneOf([Date, Number, IMask.Masked]), PropTypes.instanceOf(IMask.Masked)]),
  value: PropTypes.any,
  unmask: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['typed'])]),
  prepare: PropTypes.func,
  validate: PropTypes.func,
  commit: PropTypes.func,
  overwrite: PropTypes.bool,
  // events
  onAccept: PropTypes.func,
  onComplete: PropTypes.func,
  // pattern
  placeholderChar: PropTypes.string,
  lazy: PropTypes.bool,
  definitions: PropTypes.object,
  blocks: PropTypes.object,
  // date
  pattern: PropTypes.string,
  format: PropTypes.func,
  parse: PropTypes.func,
  autofix: PropTypes.bool,
  // number
  radix: PropTypes.string,
  thousandsSeparator: PropTypes.string,
  mapToRadix: PropTypes.arrayOf(PropTypes.string),
  scale: PropTypes.number,
  signed: PropTypes.bool,
  normalizeZeros: PropTypes.bool,
  padFractionalZeros: PropTypes.bool,
  min: PropTypes.oneOfType([PropTypes.number, PropTypes.instanceOf(Date)]),
  max: PropTypes.oneOfType([PropTypes.number, PropTypes.instanceOf(Date)]),
  // dynamic
  dispatch: PropTypes.func,
  // ref
  inputRef: PropTypes.func
};
var MASK_PROPS_NAMES = Object.keys(MASK_PROPS);
var NON_MASK_OPTIONS_PROPS_NAMES = ['value', 'unmask', 'onAccept', 'onComplete', 'inputRef'];
var MASK_OPTIONS_PROPS_NAMES = MASK_PROPS_NAMES.filter(function (pName) {
  return NON_MASK_OPTIONS_PROPS_NAMES.indexOf(pName) < 0;
});
function IMaskMixin(ComposedComponent) {
  var MaskedComponent = /*#__PURE__*/function (_React$Component) {
    _inherits(MaskedComponent, _React$Component);

    var _super = _createSuper(MaskedComponent);

    function MaskedComponent() {
      var _this;

      _classCallCheck(this, MaskedComponent);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this._inputRef = _this._inputRef.bind(_assertThisInitialized(_this));
      return _this;
    }

    _createClass(MaskedComponent, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (!this.props.mask) return;
        this.initMask();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var props = this.props;

        var maskOptions = this._extractMaskOptionsFromProps(props);

        if (maskOptions.mask) {
          if (this.maskRef) {
            this.maskRef.updateOptions(maskOptions);

            if ('value' in props && (props.value !== this.maskValue || // handle cases like Number('') === 0,
            // for details see https://github.com/uNmAnNeR/imaskjs/issues/134
            typeof props.value !== 'string' && this.maskRef.value === '' && !this.maskRef.el.isActive)) {
              this.maskValue = props.value;
            }
          } else {
            this.initMask(maskOptions);
            if (props.value !== this.maskValue) this._onAccept();
          }
        } else {
          this.destroyMask();
          if ('value' in props) this.element.value = props.value;
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.destroyMask();
      }
    }, {
      key: "_inputRef",
      value: function _inputRef(el) {
        this.element = el;
        if (this.props.inputRef) this.props.inputRef(el);
      }
    }, {
      key: "render",
      value: function render() {
        return React__default.createElement(ComposedComponent, Object.assign({}, this._extractNonMaskProps(this.props), {
          defaultValue: this.props.value,
          inputRef: this._inputRef
        }));
      }
    }, {
      key: "initMask",
      value: function initMask() {
        var maskOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._extractMaskOptionsFromProps(Object.assign({}, this.props));
        this.maskRef = IMask(this.element, maskOptions).on('accept', this._onAccept.bind(this)).on('complete', this._onComplete.bind(this));
        this.maskValue = this.props.value;
      }
    }, {
      key: "destroyMask",
      value: function destroyMask() {
        if (this.maskRef) {
          this.maskRef.destroy();
          delete this.maskRef;
        }
      }
    }, {
      key: "_extractMaskOptionsFromProps",
      value: function _extractMaskOptionsFromProps(props) {
        props = Object.assign({}, props); // keep only mask options props

        Object.keys(props).filter(function (prop) {
          return MASK_OPTIONS_PROPS_NAMES.indexOf(prop) < 0;
        }).forEach(function (nonMaskProp) {
          delete props[nonMaskProp];
        });
        return props;
      }
    }, {
      key: "_extractNonMaskProps",
      value: function _extractNonMaskProps(props) {
        props = Object.assign({}, props);
        MASK_PROPS_NAMES.forEach(function (maskProp) {
          delete props[maskProp];
        });
        return props;
      }
    }, {
      key: "maskValue",
      get: function get() {
        if (this.props.unmask === 'typed') return this.maskRef.typedValue;
        if (this.props.unmask) return this.maskRef.unmaskedValue;
        return this.maskRef.value;
      },
      set: function set(value) {
        value = value == null ? '' : value;
        if (this.props.unmask === 'typed') this.maskRef.typedValue = value;else if (this.props.unmask) this.maskRef.unmaskedValue = value;else this.maskRef.value = value;
      }
    }, {
      key: "_onAccept",
      value: function _onAccept() {
        var _this$props;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (this.props.onAccept) (_this$props = this.props).onAccept.apply(_this$props, [this.maskValue, this.maskRef].concat(args));
      }
    }, {
      key: "_onComplete",
      value: function _onComplete() {
        var _this$props2;

        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        if (this.props.onComplete) (_this$props2 = this.props).onComplete.apply(_this$props2, [this.maskValue, this.maskRef].concat(args));
      }
    }]);

    return MaskedComponent;
  }(React__default.Component);

  MaskedComponent.propTypes = MASK_PROPS;
  var nestedComponentName = ComposedComponent.displayName || ComposedComponent.name || 'Component';
  MaskedComponent.displayName = "IMask(".concat(nestedComponentName, ")");
  return MaskedComponent;
}

var _excluded = ["inputRef"];

var InputComponent = function InputComponent(_ref) {
  var inputRef = _ref.inputRef,
      props = _objectWithoutProperties(_ref, _excluded);

  return React__default.createElement('input', Object.assign({}, props, {
    ref: inputRef
  }));
};

IMaskMixin(InputComponent);

const wpEFormMasks = new Collections('EForm Masks');
wpEFormMasks.addItem('us-phone-number', {
    name: __('US phone number', 'wp-eform'),
    mask: '+1 (000) 000-0000',
    placeholder: _x('_', 'wp-eform-mask-placeholder', 'wp-eform'),
    overrideInputType: 'tel',
    title: __('Mobile or telephone number.', 'wp-eform'),
});
wpEFormMasks.addItem('us-ssn', {
    name: __('US Social Security Number (SSN)', 'wp-eform'),
    mask: '000 00 0000',
    placeholder: _x('_', 'wp-eform-mask-placeholder', 'wp-eform'),
    overrideInputType: 'tel',
    title: __('Digits only', 'wp-eform'),
});
wpEFormMasks.addItem('us-zip', {
    name: __('US Zip code', 'wp-eform'),
    mask: '00000',
    placeholder: _x('_', 'wp-eform-mask-placeholder', 'wp-eform'),
    overrideInputType: 'tel',
    title: __('Digits only', 'wp-eform'),
});
wpEFormMasks.addItem('date-mm-dd-yy', {
    name: __('Date MM-DD-YY', 'wp-eform'),
    mask: '00-00-00',
    overrideInputType: 'tel',
    placeholder: _x('_', 'wp-eform-mask-placeholder', 'wp-eform'),
});
wpEFormMasks.addItem('date-yyyy-mm-dd', {
    name: __('Date YYYY-MM-DD', 'wp-eform'),
    mask: '0000-00-00',
    overrideInputType: 'tel',
    placeholder: _x('_', 'wp-eform-mask-placeholder', 'wp-eform'),
});
wpEFormMasks.addItem('date-dd/mm/yy', {
    name: __('Date DD/MM/YY', 'wp-eform'),
    mask: '00/00/00',
    overrideInputType: 'tel',
    placeholder: _x('_', 'wp-eform-mask-placeholder', 'wp-eform'),
});
wpEFormMasks.addItem('twitter-url', {
    name: __('Twitter URL', 'wp-eform'),
    mask: `https://twitter.com/*[${'*'.repeat(50)}]`,
    placeholder: _x('_', 'wp-eform-mask-placeholder', 'wp-eform'),
});
wpEFormMasks.addItem('facebook-url', {
    name: __('Facebook URL', 'wp-eform'),
    mask: `https://f\\acebook.com/*[${'*'.repeat(50)}]`,
    placeholder: _x('_', 'wp-eform-mask-placeholder', 'wp-eform'),
});
wpEFormMasks.addItem('instagram-url', {
    name: __('Instagram URL', 'wp-eform'),
    mask: `https://inst\\agr\\am.com/*[${'*'.repeat(50)}]`,
    placeholder: _x('_', 'wp-eform-mask-placeholder', 'wp-eform'),
});
wpEFormMasks.addItem('url', {
    name: __('General URL', 'wp-eform'),
    mask: `http[a]://[${'*'.repeat(255)}]`,
    placeholder: _x('_', 'wp-eform-mask-placeholder', 'wp-eform'),
});
wpEFormMasks.addItem('rgb-hex-color', {
    name: __('RGB or HEX color code', 'wp-eform'),
    mask: [
        {
            mask: 'RGB,RGB,RGB',
            blocks: {
                RGB: {
                    mask: IMask.MaskedRange,
                    // @ts-ignore
                    from: 0,
                    to: 255,
                },
            },
        },
        {
            mask: /^#[0-9a-f]{0,6}$/i,
        },
    ],
    placeholder: _x('_', 'wp-eform-mask-placeholder', 'wp-eform'),
});
wpEFormMasks.addItem('rgb-color', {
    name: __('RGB color code', 'wp-eform'),
    mask: [
        {
            mask: 'RGB,RGB,RGB',
            blocks: {
                RGB: {
                    mask: IMask.MaskedRange,
                    // @ts-ignore
                    from: 0,
                    to: 255,
                },
            },
        },
    ],
    placeholder: _x('_', 'wp-eform-mask-placeholder', 'wp-eform'),
});

/**
 * Get a random value between two integers. Both min and max are inclusive.
 *
 * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random#Getting_a_random_integer_between_two_values_inclusive
 */
function getRandomInt(min, max) {
    const minVal = Math.ceil(min);
    const maxVal = Math.floor(max);
    return Math.floor(Math.random() * (maxVal - minVal + 1)) + minVal;
}
/**
 * Get numeric value from a possibly number. Uses parseFloat.
 *
 * @param possibleNum Possibly number variable.
 * @param defaultValue Default value to return if variable is not a number.
 */
function getNumericValue(possibleNum, defaultValue = 0) {
    const num = Number.parseFloat(possibleNum);
    if (Number.isNaN(num) || !Number.isFinite(num)) {
        return defaultValue;
    }
    return num;
}
/**
 * Get integer value from a possibly number which should be greater than the
 * provided. Otherwise, return the default one.
 *
 * @param possibleNum Possibly number variable.
 * @param defaultValue Default value to return.
 * @param greaterThan Must be greater than this value.
 */
function getIntValueGreaterThan(possibleNum, defaultValue, greaterThan = 0) {
    const num = Number.parseInt(possibleNum, 10);
    if (!Number.isNaN(num) && Number.isFinite(num) && num > greaterThan) {
        return num;
    }
    return defaultValue;
}
/**
 * Get a positive integer value by parsing a variable. If the number is not a
 * number or if it is negative, then 0 is returned.
 *
 * @param possibleNum Possibly number variable.
 */
function getPositiveIntValue(possibleNum) {
    return getIntValueGreaterThan(possibleNum, 0, 0);
}
/**
 * Precie a number to a decimal point.
 *
 * @param num The number to convert to precision.
 * @param precision Decimal precision.
 */
function formatNumber(num, precision, decimalSeparator = '.', thousandsSeparator = ',') {
    let formattedNumber;
    // eslint-disable-next-line eqeqeq
    const isNegative = num != undefined && num < 0;
    // eslint-disable-next-line eqeqeq
    if (num == undefined) {
        formattedNumber = (0).toFixed(precision);
    }
    else {
        formattedNumber = Math.abs(num).toFixed(precision);
    }
    // first split out the decimal
    const numParts = formattedNumber.split('.');
    // format the integer part
    let intParts = numParts[0];
    const thousandsParts = [];
    while (intParts.length > 3) {
        thousandsParts.unshift(intParts.substr(intParts.length - 3));
        intParts = intParts.substr(0, intParts.length - 3);
    }
    if (intParts.length > 0) {
        thousandsParts.unshift(intParts);
    }
    let output = thousandsParts.join(thousandsSeparator);
    if (isNegative) {
        output = `-${output}`;
    }
    if (numParts.length > 1) {
        output = `${output}${decimalSeparator}${numParts[1]}`;
    }
    return output;
}
function getHoursMinutesSeconds(timestampDiff, format = 'string') {
    let remainingSeconds = timestampDiff / 1000;
    const totalHours = Math.floor(remainingSeconds / 3600);
    remainingSeconds = remainingSeconds - totalHours * 3600;
    const totalMinutes = Math.floor(remainingSeconds / 60);
    remainingSeconds = Math.floor(remainingSeconds - totalMinutes * 60);
    if (format === 'string') {
        return {
            hours: totalHours.toString().padStart(2, '0'),
            minutes: totalMinutes.toString().padStart(2, '0'),
            seconds: remainingSeconds.toString().padStart(2, '0'),
        };
    }
    return {
        hours: totalHours,
        minutes: totalMinutes,
        seconds: remainingSeconds,
    };
}
/**
 * Round a number to a given precision.
 *
 * @link https://stackoverflow.com/a/11832950/2754557
 * @param num Input number.
 * @param precision Decimal precision.
 * @returns Rounded value.
 */
function roundNumber(num, precision = 2) {
    if (precision < 1) {
        return Math.round(num);
    }
    const multiplier = 10 ** precision;
    return Math.round((num + Number.EPSILON) * multiplier) / multiplier;
}
/**
 * Parse and get a float value from a possibly number. If given value is not
 * a number or is not finite, then fallback is returned.
 *
 * @param possiblyNum Possibly number.
 * @param fallback Fallback value if parsing fails. Default is 0.
 * @returns Parsed number.
 */
function getFloatValue(possiblyNum, fallback = 0) {
    let parsedValue;
    if (typeof possiblyNum === 'string') {
        parsedValue = Number.parseFloat(possiblyNum);
    }
    else if (typeof possiblyNum === 'number') {
        parsedValue = possiblyNum;
    }
    else {
        parsedValue = fallback;
    }
    if (!Number.isFinite(parsedValue)) {
        parsedValue = fallback;
    }
    return parsedValue;
}
/**
 * Check whether a value is in steps.
 *
 * @param value Currently selected value.
 * @param step Step increase/decrease.
 * @param start Start value to calculate for step, default 0.
 * @param precision Decimal precision to calculate.
 * @returns boolean True if in step, false otherwise.
 */
function validateValueInStep(value, step, start = 0, precision = 2) {
    if (step <= 0) {
        throw new Error(`Step cannot be less than or equal to 0, currently it is ${step}`);
    }
    if (precision < 0) {
        throw new Error(`Precision cannot be less than or equal to 0, currently it is ${precision}`);
    }
    // first take the precision into account and round everything
    const multiplier = 10 ** Math.round(Math.abs(precision));
    const normalizedStep = Math.round(step * multiplier);
    const normalizedMin = Math.round(start * multiplier);
    const normalizedValue = Math.round(value * multiplier);
    // now calculate the remainder
    const remainder = Math.abs(normalizedValue - normalizedMin) % normalizedStep;
    return remainder === 0;
}
/**
 * Get the nearest value which is in step of the given boundaries.
 *
 * @param value Currently selected value.
 * @param step Step increase/decrease.
 * @param start Start value to calculate for step, default 0.
 * @param precision Decimal precision to calculate.
 * @returns nearest number in step (preferably less than the given value).
 */
function getNearestValueInStep(value, step, start, precision = 2) {
    if (step <= 0) {
        throw new Error(`Step cannot be less than or equal to 0, currently it is ${step}`);
    }
    if (precision < 0) {
        throw new Error(`Precision cannot be less than or equal to 0, currently it is ${precision}`);
    }
    // first take the precision into account and round everything
    const multiplier = 10 ** Math.round(Math.abs(precision));
    const normalizedStep = Math.round(step * multiplier);
    const normalizedMin = Math.round(start * multiplier);
    const normalizedValue = Math.round(value * multiplier);
    let normalizedNearest = normalizedValue - ((normalizedValue - normalizedMin) % normalizedStep);
    if (normalizedNearest < normalizedMin) {
        normalizedNearest = normalizedMin;
    }
    // return Number.parseFloat((normalizedNearest / multiplier).toFixed(precision));
    return roundNumber(normalizedNearest / multiplier, precision);
}

const CONTROLCLASS$l = 'wpeform-control-text';
const MaterialBorder$2 = styled.div `
	position: absolute;
	height: 2px;
	bottom: 0;
	left: 0;
	right: 0;
	transform-origin: 50% 50%;
	background-color: ${props => props.theme.primaryColor};
	pointer-events: none;
	transform: scaleX(0);
	transition: ${props => getMultipleTransitionsWithWillChange(['transform'], props.theme.transitionBeizer)};
`;
const StyledInput = styled.input `
	${cssReset};
	${inputCssReset};
	display: block;
	width: 100%;
	height: ${props => numToCssSize(props.theme.controlHeightBase)};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	box-shadow: 0 0 0 0 transparent;
	color: ${props => props.theme.textColor};
	padding: ${props => numToCssSize(props.theme.controlHeightBase / 4)};
	border: 1px solid ${props => props.theme.borderColorBase};
	background-color: ${props => props.theme.appBackgroundColor};
	box-shadow: ${props => props.theme.boxShadowNoneFocus};
	transition: ${props => getMultipleTransitionsWithWillChange(['border-color', 'box-shadow'], props.theme.transitionControl)};

	&:hover {
		color: ${props => props.theme.textColor};
		border-color: ${props => props.theme.primaryColor};
	}

	&:active,
	&:focus {
		color: ${props => props.theme.textColor};
		border-color: ${props => props.theme.primaryColor};
		box-shadow: ${props => props.theme.boxShadowControlFocus};
	}

	&::placeholder {
		color: ${props => props.theme.textColorSecondary};
	}

	&.${CONTROLCLASS$l}__input--has-error {
		border-color: ${props => props.theme.borderColorError};

		&:hover {
			border-color: ${props => props.theme.borderColorError};
		}

		&:active,
		&:focus {
			border-color: ${props => props.theme.borderColorError};
			box-shadow: ${props => props.theme.boxShadowControlFocusError};
		}
	}

	&:disabled {
		background-color: ${props => props.theme.disabledBackgroundColor};
		color: ${props => props.theme.disabledColor};
		border-color: ${props => props.theme.disabledColor};
		cursor: not-allowed;
		box-shadow: none;
	}

	&:read-only {
		background-color: ${props => props.theme.disabledBackgroundColor};
		border-color: ${props => props.theme.disabledColor};
		box-shadow: none;
	}

	&.${CONTROLCLASS$l}__input--type-MATERIAL {
		border: 0 none;
		border-bottom: 2px solid ${props => props.theme.borderColorBase};
		border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)}
			${props => numToCssSize(props.theme.borderRadiusBase)} 0 0;
		box-shadow: none;
		background-color: ${props => props.theme.backgroundControl};
		transition: ${props => getMultipleTransitionsWithWillChange(['background-color'], props.theme.transitionControl)};

		&:hover {
			border-color: ${props => props.theme.borderColorBase};
		}

		&:active,
		&:focus {
			background-color: ${props => curriedTransparentize(0.5, props.theme.backgroundControl)};
			border-color: ${props => props.theme.borderColorBase};
			box-shadow: none;
		}

		&:hover
			+ ${MaterialBorder$2},
			&:active
			+ ${MaterialBorder$2},
			&:focus
			+ ${MaterialBorder$2} {
			transform: scaleX(1);
		}

		&.${CONTROLCLASS$l}__input--has-error {
			border-bottom-color: ${props => props.theme.borderColorError};

			&:hover {
				border-bottom-color: ${props => props.theme.borderColorError};
			}

			&:active,
			&:focus {
				border-bottom-color: ${props => props.theme.borderColorError};
			}

			+ ${MaterialBorder$2} {
				background-color: ${props => props.theme.borderColorError};
			}
		}

		&:disabled {
			background-color: ${props => props.theme.disabledBackgroundColor};
			color: ${props => props.theme.disabledColor};
			border-color: ${props => props.theme.disabledColor};
			cursor: not-allowed;
			+ ${MaterialBorder$2} {
				transform: scaleX(0);
				background-color: ${props => props.theme.disabledColor};
			}
		}

		&:read-only {
			background-color: ${props => props.theme.disabledBackgroundColor};
			border-color: ${props => props.theme.disabledColor};
			+ ${MaterialBorder$2} {
				transform: scaleX(0);
				background-color: ${props => props.theme.disabledColor};
			}
		}
	}

	/** SIZES */
	&.${CONTROLCLASS$l}__input--size-SMALL {
		height: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
		padding: ${props => numToCssSize(props.theme.controlHeightBase / 8)};
		font-size: ${props => numToCssSize(props.theme.fz.small1)};
	}
	&.${CONTROLCLASS$l}__input--size-LARGE {
		height: ${props => numToCssSize(props.theme.controlHeightBase * 1.2)};
		padding: ${props => numToCssSize(props.theme.controlHeightBase / 4)};
	}

	&[type='number'] {
		&::-webkit-inner-spin-button,
		&::-webkit-outer-spin-button {
			appearance: none;
			margin: 0;
		}
	}
`;
const Placeholder$1 = styled.div `
	position: absolute;
	display: flex;
	align-items: center;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
	/** So that we can click through it to the input */
	pointer-events: none;
	font-size: ${props => numToCssSize(props.theme.fz.base)};

	color: ${props => props.theme.textColorSecondary};
	transition: ${props => getMultipleTransitionsWithWillChange(['top', 'left', 'bottom', 'font-size'], props.theme.transitionControl)};

	> * {
		margin: 0;
		padding: 0;
		max-width: 100%;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
`;
const Prefix$2 = styled.div `
	position: absolute;
	top: 0;
	left: ${props => numToCssSize(props.theme.controlHeightBase / 4)};
	bottom: 0;
	display: flex;
	align-items: center;
	justify-content: center;
	/** So that we can click through it to the input */
	pointer-events: none;
	color: ${props => props.theme.greyLightColor};
`;
const Container$6 = styled.div `
	${cssReset};
	position: relative;
	padding: 0;

	/** Position the default placeholder */
	${Placeholder$1} {
		top: ${props => numToCssSize(props.theme.controlHeightBase / 4)};
		left: ${props => numToCssSize(props.theme.controlHeightBase / 4)};
		right: ${props => numToCssSize(props.theme.controlHeightBase / 4)};
		bottom: ${props => numToCssSize(props.theme.controlHeightBase / 4)};
	}
	&.${CONTROLCLASS$l}--align-LEFT {
		${Placeholder$1} {
			text-align: left;
			justify-content: flex-start;
		}
	}
	&.${CONTROLCLASS$l}--align-CENTER {
		${Placeholder$1} {
			text-align: center;
			justify-content: center;
		}
	}
	&.${CONTROLCLASS$l}--align-RIGHT {
		${Placeholder$1} {
			text-align: right;
			justify-content: flex-end;
		}
	}

	&.${CONTROLCLASS$l}--has-prefix {
		${StyledInput} {
			/** [gutter + prefix + gutter] where gutter is controlHeightBase / 4 & prefix is fz.base */
			padding-left: ${props => numToCssSize(props.theme.fz.base + (props.theme.controlHeightBase / 4) * 2)};
		}
		${Placeholder$1} {
			left: ${props => numToCssSize(props.theme.fz.base + (props.theme.controlHeightBase / 4) * 2)};
		}
		&.${CONTROLCLASS$l}--size-SMALL {
			${StyledInput} {
				/** [gutter + prefix + gutter] where gutter is controlHeightBase / 8 & prefix is fz.base */
				padding-left: ${props => numToCssSize(props.theme.fz.base + (props.theme.controlHeightBase / 8) * 2 + 4)};
			}
			${Placeholder$1} {
				left: ${props => numToCssSize(props.theme.fz.base + (props.theme.controlHeightBase / 8) * 2)};
			}
		}

		&.${CONTROLCLASS$l}--has-error {
			${Prefix$2} {
				color: ${props => props.theme.errorColor};
			}
		}
	}

	/** Changes when focused */
	&.${CONTROLCLASS$l}--is-focused, &.${CONTROLCLASS$l}--is-not-empty {
		${Placeholder$1} {
			top: ${props => numToCssSize((props.theme.controlHeightBase / 2) * -1)};
			left: 0;
			bottom: ${props => numToCssSize(props.theme.controlHeightBase)};
			font-size: ${props => numToCssSize(props.theme.fz.small1)};
		}
	}
`;

const MaskedStyledInput = IMaskMixin(({ inputRef, ...props }) => (jsx(StyledInput, Object.assign({}, props, { ref: inputRef }), void 0)));
/**
 * A controlled Text Input component. Apart from being a normal input type text
 * it can also accept prefix and suffix.
 */
function Text$2(props) {
    const { id, onChange, value, prefix, placeholder, controlType = SettingsAppearanceControlTypeEnum.BOXY, controlAlignment = SettingsAppearanceControlAlignmentEnum.LEFT, disabled = false, readOnly = false, hasError = false, type = 'text', masks, onBlur, innerRef, className, size = GenericSizeEnum.DEFAULT, ...inputProps } = props;
    let inputType = type;
    let title;
    const [focused, setFocused] = useState$1(false);
    // localize the input value for performance, we don't want every keystroke
    // update the whole outer state
    const [localValue, setLocalValue] = useState$1(value);
    const debouncedOnChange = useDebouncedCallback((newValue, updater) => {
        updater(newValue);
    }, 300);
    const localOnChange = (newValue) => {
        if (type === 'number') {
            let parsedValue = getFloatValue(newValue, 0);
            if (typeof inputProps.min !== 'undefined' &&
                parsedValue < inputProps.min) {
                parsedValue = inputProps.min;
            }
            if (typeof inputProps.max !== 'undefined' &&
                parsedValue > inputProps.max) {
                parsedValue = inputProps.max;
            }
            newValue = parsedValue.toString();
        }
        setLocalValue(newValue);
        debouncedOnChange(newValue, onChange);
    };
    // sync it back from the props
    useEffect(() => {
        setLocalValue(value);
    }, [value]);
    const containerClasses = getBemClassName(CONTROLCLASS$l, {
        'has-prefix': !!prefix,
        'is-not-empty': value !== '',
        'is-focused': focused,
        [`type-${controlType}`]: true,
        'has-error': hasError,
        [`align-${controlAlignment}`]: true,
        [`size-${size}`]: true,
    }, className);
    let mask;
    let hasMask = false;
    let maskPlaceholder = masks ? masks.placeholder : '_';
    if (masks && masks.maskType !== MaskTypeEnum.NONE) {
        if (masks.maskType === MaskTypeEnum.STRING) {
            mask = masks.maskString || '';
            hasMask = true;
        }
        else if (masks.maskType === MaskTypeEnum.REGEXP) {
            mask = [];
            masks.maskRegExps.forEach(reg => {
                mask.push({
                    mask: new RegExp(reg.pattern, reg.caseSensitive ? 'i' : undefined),
                    lazy: masks.alwaysShowMask ? false : !focused,
                });
            });
            hasMask = true;
        }
        else {
            const preset = masks.maskPreset || '';
            if (wpEFormMasks.hasItem(preset)) {
                const maskItem = wpEFormMasks.getItem(preset);
                mask = maskItem.mask;
                if (maskItem.overrideInputType) {
                    inputType = maskItem.overrideInputType;
                }
                title = maskItem.title;
                if (maskItem.placeholder) {
                    maskPlaceholder = maskItem.placeholder;
                }
                hasMask = true;
            }
        }
    }
    const inputClassName = getBemClassName(getBemElement(CONTROLCLASS$l, 'input'), {
        [`type-${controlType}`]: true,
        'has-error': hasError,
        [`size-${size}`]: true,
    });
    return (jsxs(Container$6, Object.assign({ className: containerClasses }, { children: [prefix ? jsx(Prefix$2, { children: prefix }, void 0) : null, typeof placeholder !== 'string' &&
                (!hasMask || (hasMask && masks && !masks.alwaysShowMask)) ? (jsx(Placeholder$1, { children: placeholder }, void 0)) : null, hasMask && mask && masks ? (jsx(MaskedStyledInput, { mask: mask, radix: ".", unmask: false, inputRef: innerRef, onAccept: newValue => {
                    localOnChange(newValue);
                }, overwrite: true, value: localValue, onFocus: () => {
                    setFocused(true);
                }, onBlur: event => {
                    setFocused(false);
                    debouncedOnChange.cancel();
                    onChange(localValue);
                    onBlur?.(event);
                }, disabled: disabled, readOnly: readOnly, lazy: masks.alwaysShowMask ? false : !focused, placeholderChar: maskPlaceholder, placeholder: typeof placeholder === 'string' ? placeholder : undefined, title: title, type: inputType }, void 0)) : (jsx(StyledInput, Object.assign({ id: id, type: type, className: inputClassName, value: localValue, onChange: e => {
                    localOnChange(e.target.value);
                }, onFocus: () => {
                    setFocused(true);
                }, onBlur: event => {
                    setFocused(false);
                    debouncedOnChange.cancel();
                    onChange(localValue);
                    onBlur?.(event);
                }, disabled: disabled, readOnly: readOnly, placeholder: typeof placeholder === 'string' ? placeholder : undefined, ref: innerRef }, inputProps), void 0)), controlType === SettingsAppearanceControlTypeEnum.MATERIAL ? (jsx(MaterialBorder$2, {}, void 0)) : null] }), void 0));
}

const CONTROLCLASS$k = 'wpeform-icon';
const IconContainer$1 = styled.span `
	color: inherit;
	font-size: 1em;
	height: 1em;
	width: 1em;
	display: inline-flex;
	align-items: center;
	justify-content: center;
	font-weight: normal;
	font-style: normal;

	svg:not(.svg-inline--fa) {
		height: 1em;
		width: 1em;
		fill: currentColor;
		display: block;
	}
	${dom.css()}
`;
/**
 * An icon component to safely render iconfont icons or SVG icons inline
 * within the component. Other components can modify the styling by overriding
 * `wpeform-icon` class inside them. It inherits color and size directly from
 * the parent component.
 */
function Icon(props) {
    const { iconClass, children = null, component, className, title } = props;
    // check to see if its a fontawesome icon
    let isFontAwesome = false;
    const fontAwesomeIconClasses = [];
    let additionalClasses = '';
    if (iconClass?.startsWith('fas ') ||
        iconClass?.startsWith('fab ') ||
        iconClass?.startsWith('far ')) {
        const fsClassNames = iconClass.split(' ');
        if (fsClassNames.length >= 2 && fsClassNames[1]) {
            fontAwesomeIconClasses.push(fsClassNames[0]);
            // remove the `fa-` part from the second part
            fontAwesomeIconClasses.push(fsClassNames[1].replace('fa-', ''));
            isFontAwesome = true;
            if (fsClassNames.length > 2) {
                additionalClasses = fsClassNames.slice(2).join(' ');
            }
        }
    }
    return (jsx(IconContainer$1, Object.assign({ role: "img", "aria-hidden": props['aria-label'] ? undefined : true, "aria-label": props['aria-label'], className: classNames(CONTROLCLASS$k, isFontAwesome ? additionalClasses : iconClass, {
            'is-fallback-antd': !!component,
            anticon: !!component,
        }, className), title: title }, { children: component ? (createElement(component, {})) : isFontAwesome ? (jsx(FontAwesomeIcon, { icon: fontAwesomeIconClasses }, void 0)) : (children) }), void 0));
}

const CONTROLCLASS$j = 'wpeform-answer-preview';
const TITLECLASS$1 = getBemElement(CONTROLCLASS$j, 'title');
const SUBTITLECLASS = getBemElement(CONTROLCLASS$j, 'subtitle');
const ANSWERCLASS = getBemElement(CONTROLCLASS$j, 'answer');
const SCORETABLECLASS = getBemElement(CONTROLCLASS$j, 'score-table');
const SCORETABLECONTAINERCLASS = getBemElement(CONTROLCLASS$j, 'score-table-container');
const SCOREVALUECLASS = getBemElement(CONTROLCLASS$j, 'score-value');
const Generic = styled.div `
	ul,
	ol {
		margin: 0 0 0 ${props => numToCssSize(props.theme.gutter)};
		padding: 0;
		list-style: disc;
	}
	ol {
		list-style: decimal;
	}
	p,
	div.para {
		margin: 0 0 ${props => numToCssSize(props.theme.gutter)} 0;
	}
	> p:only-child,
	> div.para:only-child {
		margin-bottom: 0;
	}
	/* Headings */
	h1,
	h2,
	h3,
	h4,
	h5,
	h6 {
		margin: 0.6em 0;
		line-height: 1.2;
		clear: both;
		color: ${props => props.theme.headingColor};
	}
	h1 {
		font-size: ${props => numToCssSize(props.theme.fz.large5 / props.theme.fz.base, 'em')};
		line-height: 1.2;
	}
	h2 {
		font-size: ${props => numToCssSize(props.theme.fz.large3 / props.theme.fz.base, 'em')};
	}
	h3 {
		font-size: ${props => numToCssSize(props.theme.fz.large2 / props.theme.fz.base, 'em')};
	}
	h4 {
		font-size: ${props => numToCssSize(props.theme.fz.large1 / props.theme.fz.base, 'em')};
	}
	h5 {
		font-size: ${props => numToCssSize(props.theme.fz.small1 / props.theme.fz.base, 'em')};
	}
	h6 {
		font-size: ${props => numToCssSize(props.theme.fz.small2 / props.theme.fz.base, 'em')};
	}
	> *:last-child {
		margin-bottom: 0;
	}
`;
const UserInput = styled.div `
	${userInputWhiteSpace};
`;
const Answer = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter / 2)}
		${props => numToCssSize(props.theme.gutter)};
	border: 1px solid ${props => props.theme.borderColorLight};
	min-height: ${props => numToCssSize(props.theme.controlHeightBase)};
`;
const Title$1 = styled.h3 `
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	font-weight: bold;
	font-family: ${props => props.theme.fontFamilyHeading};
	color: ${props => props.theme.headingColor};
	padding: 0;
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
`;
const Subtitle = styled.h5 `
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	color: ${props => props.theme.textColorSecondary};
	font-weight: normal;
	font-style: italic;
	text-align: left;
	line-height: 1.2;
`;
const Description = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter)};
	border: 1px solid ${props => props.theme.borderColorLight};
	border-top: 0 none;
	background-color: ${props => props.theme.backgroundControl};
	color: ${props => props.theme.textColor};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
`;
const ScoreTableContainer = styled.div `
	width: 100%;
	overflow-y: auto;
`;
const ScoreTable = styled.table `
	border-collapse: collapse;
	border: 1px solid ${props => props.theme.borderColorLight};
	border-top: 0 none;
	width: 100%;
	text-align: left;
	td,
	th {
		text-align: left;
		border-collapse: collapse;
		border-right: 1px solid ${props => props.theme.borderColorLight};
		border-bottom: 1px solid ${props => props.theme.borderColorLight};
		padding: ${props => numToCssSize(props.theme.gutter / 2)}
			${props => numToCssSize(props.theme.gutter)};
		&.${SCOREVALUECLASS} {
			font-variant-numeric: tabular-nums;
			width: 70px;
			text-align: right;
		}
	}

	&.${SCORETABLECLASS}--has-header {
		border-top: 1px solid ${props => props.theme.borderColorLight};

		thead {
			th {
				font-weight: bold;
				color: ${props => props.theme.textColorSecondary};
				font-size: ${props => numToCssSize(props.theme.fz.small2)};
			}
		}
	}
`;
const Container$5 = styled.div `
	${cssReset};
	padding: 0;
	margin: 0 0 ${props => numToCssSize(props.theme.gutter)} 0;
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	@media print {
		break-inside: avoid-page;
	}
`;
const Divider = styled.hr `
	width: 35%;
	max-width: 150px;
	height: 2px;
	border: 0 none;
	border-radius: 2px;
	background-color: ${props => props.theme.borderColorSplit};
	margin: ${props => numToCssSize(props.theme.gutter)} 0 0;
	padding: 0;
	display: block;
`;
const Separator = styled.hr `
	margin: ${props => numToCssSize(props.theme.gutter / 2)} 0;
	height: 2px;
	border: 0 none;
	display: block;
	width: 30px;
	border-radius: 2px;
	background-color: ${props => props.isLight ? props.theme.backgroundShade : props.theme.borderColorLight};
`;
function ScoreTableRenderer(props) {
    const { scores, scorePrecision, hasHeader = false } = props;
    return (jsx(ScoreTableContainer, Object.assign({ className: SCORETABLECONTAINERCLASS }, { children: jsxs(ScoreTable, Object.assign({ className: getBemClassName(SCORETABLECLASS, {
                'has-header': hasHeader,
            }) }, { children: [hasHeader ? (jsx("thead", { children: jsxs("tr", { children: [jsx("th", { children: __('Outcome', 'wp-eform') }, void 0), jsx("th", Object.assign({ className: SCOREVALUECLASS }, { children: __('Obtained', 'wp-eform') }), void 0), jsx("th", Object.assign({ className: SCOREVALUECLASS }, { children: __('Out of', 'wp-eform') }), void 0), jsx("th", Object.assign({ className: SCOREVALUECLASS }, { children: __('%-age', 'wp-eform') }), void 0)] }, void 0) }, void 0)) : null, jsx("tbody", { children: scores.map(sc => (jsxs(React__default.Fragment, { children: [jsxs("tr", { children: [jsx("th", { children: sc.title }, void 0), jsx("td", Object.assign({ className: SCOREVALUECLASS }, { children: formatNumber(sc.obtained, scorePrecision) }), void 0), jsx("td", Object.assign({ className: SCOREVALUECLASS }, { children: formatNumber(sc.outof, scorePrecision) }), void 0), jsxs("td", Object.assign({ className: SCOREVALUECLASS }, { children: [formatNumber((sc.obtained / sc.outof) * 100, scorePrecision), "%"] }), void 0)] }, void 0), sc.description ? (jsx("tr", { children: jsx("td", Object.assign({ colSpan: 4 }, { children: sc.description }), void 0) }, void 0)) : null] }, sc.scoreId))) }, void 0)] }), void 0) }), void 0));
}
function AnswerPreview(props) {
    const { answer, title, subtitle, answerDescription, scores, scorePrecision } = props;
    return (jsxs(Container$5, Object.assign({ className: CONTROLCLASS$j }, { children: [jsx(Title$1, Object.assign({ className: TITLECLASS$1 }, { children: title }), void 0), subtitle ? (jsx(Subtitle, Object.assign({ className: SUBTITLECLASS }, { children: subtitle }), void 0)) : null, jsx(Answer, Object.assign({ className: ANSWERCLASS }, { children: answer }), void 0), answerDescription ? (jsx(Description, { children: answerDescription }, void 0)) : null, scores && scores.length ? (jsx(ScoreTableRenderer, { scorePrecision: scorePrecision, scores: scores }, void 0)) : null, jsx(Divider, {}, void 0)] }), void 0));
}
AnswerPreview.Generic = Generic;
AnswerPreview.UserInput = UserInput;
AnswerPreview.Separator = Separator;
AnswerPreview.OptionDescription = styled.div `
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	color: ${props => props.theme.textColorSecondary};
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
`;
AnswerPreview.ScoreTable = ScoreTableRenderer;

const validationMessages = {
    requiredInput: __('The element is required, kindly enter a value.', 'wp-eform'),
    minStringInput: __('Length of input must be %1$d, currently it is %2$d.', 'wp-eform'),
    maxStringInput: __('Length of input can not be greater than %1$d, currently it is %2$d.', 'wp-eform'),
    inputNoLetter: __('No letters are allowed.', 'wp-eform'),
    inputNoNumber: __('No numbers are allowed.', 'wp-eform'),
    inputEmail: __('The email address is incorrect.', 'wp-eform'),
    inputInteger: __('Only integers are allowed.', 'wp-eform'),
    inputNumber: __('Only numbers are allowed.', 'wp-eform'),
    inputNumMin: __('Minimum required value is %1$s, currently it is %2$s.', 'wp-eform'),
    inputNumMax: __('Maximum allowed value is %1$s, currently it is %2$s.', 'wp-eform'),
    inputPhone: __('Please enter a valid phone number.', 'wp-eform'),
    inputUrl: __('Please enter a valid phone URL.', 'wp-eform'),
    requiredOptions: __('Required, please select an option.', 'wp-eform'),
    maxOptions: __('A maximum of %1$d option(s) allowed, you have selected %2$d.', 'wp-eform'),
    minOptions: __('A minimum of %1$d option(s) required, you have selected %2$d.', 'wp-eform'),
    requiredOther: __('Please fill in your custom choice.', 'wp-eform'),
    requiredCaptcha: __('The captcha is required.', 'wp-eform'),
    incorrectCaptcha: __('The answer is incorrect. Correct answer would be %1$s.', 'wp-eform'),
    requiredCheckbox: __('This checkbox is required.', 'wp-eform'),
    requiredToggle: __('Please check this toggle element.', 'wp-eform'),
    sliderMinUnderFlow: __('Value cannot be less than {min}.', 'wp-eform'),
    sliderMaxOverFlow: __('Value cannot be greater than {max}.', 'wp-eform'),
    sliderStepOverFlow: __('Value must be in the steps of {step}.', 'wp-eform'),
    rangeStepOverFlow: __('Value {value} must be in the steps of {step}', 'wp-eform'),
    rangeInvariant: __('Minimum value {min} must be less than or equal to maximum value {max}.', 'wp-eform'),
    requiredRating: __('The rating is required.', 'wp-eform'),
    requiredRatingFeedback: __('Please fill in the feedback.', 'wp-eform'),
    ratingInvariant: __('Rating value is greater than maximum.', 'wp-eform'),
    requiredMatrixChoice: __('Required, please select at-least one option every row.', 'wp-eform'),
    requiredDateTimeInput: __('Please enter a value.', 'wp-eform'),
    dateTimeInputMustBeLess: __('Value must not be less than %1$s.', 'wp-eform'),
    dateTimeInputMustBeGreater: __('Value must not be greater than %1$s.', 'wp-eform'),
    dateTimeInputInvalid: __('Invalid value used in date time input.', 'wp-eform'),
    requiredMatrixInput: __('Please fill all the items in the table.', 'wp-eform'),
    requiredAddress: __('Please fill in the address.', 'wp-eform'),
};

const text = {
    id: 'text',
    hasSubmission: true,
    FormUi({ id, elementData, submissionData, updateSubmissionData, setElementTouched, controlType, controlLayout, controlAlignment, elementTitle, hasError = false, }) {
        // no need for a local state, the Text component takes care of it
        const value = submissionData.value.text?.input ?? '';
        const onChange = useCallback$1((newValue) => {
            const newSubmissionData = fn(submissionData, draftState => {
                draftState.value.text.input = newValue;
            });
            updateSubmissionData(newSubmissionData);
        }, [updateSubmissionData, submissionData]);
        let inputType = 'text';
        const filterType = elementData.config.text?.validation?.filters.type;
        if (filterType === ValidationFilterTypeEnum.EMAIL) {
            inputType = 'email';
        }
        else if (filterType === ValidationFilterTypeEnum.INTEGER ||
            filterType === ValidationFilterTypeEnum.NUMBER) {
            inputType = 'number';
        }
        else if (filterType === ValidationFilterTypeEnum.PHONE) {
            inputType = 'tel';
        }
        return (jsx(Text$2, { id: id, controlType: controlType, controlAlignment: controlAlignment, value: value, onChange: onChange, masks: elementData.config.text?.validation?.masks, onBlur: () => {
                setElementTouched(true);
            }, hasError: hasError, placeholder: controlLayout !== SettingsAppearanceControlLayoutEnum.INLINE
                ? elementData.config.text?.interface?.placeholder || ''
                : elementTitle, prefix: elementData.config.text?.interface?.icon ? (jsx(Icon, { iconClass: elementData.config.text.interface.icon }, void 0)) : undefined, type: inputType, readOnly: elementData.config.text?.attributes.readonly }, void 0));
    },
    isQuestion: true,
    isRequired(elementData) {
        if (elementData.config.text?.validation?.required) {
            return true;
        }
        return false;
    },
    getErrors(elementData, submissionDataValue) {
        const errors = [];
        // required check
        const isRequired = !!elementData.config.text?.validation?.required;
        const isEmpty = submissionDataValue.text?.input === '' ||
            submissionDataValue.text?.input === null;
        // check for filters if it is required, or it is not required, yet not empty
        const shouldCheckForFilters = isRequired || (!isRequired && !isEmpty);
        if (isRequired && isEmpty) {
            errors.push(validationMessages.requiredInput);
        }
        // if mask is active, then don't do any check
        // otherwise check for other stuffs
        if (elementData.config.text?.validation?.masks.maskType ===
            MaskTypeEnum.NONE &&
            shouldCheckForFilters) {
            const input = submissionDataValue.text?.input || '';
            const filters = elementData.config.text.validation.filters;
            // min string and max string
            if ([
                ValidationFilterTypeEnum.ALL,
                ValidationFilterTypeEnum.NOLETTER,
                ValidationFilterTypeEnum.NONUMBER,
            ].includes(filters.type)) {
                // RegEx check noletter or nonumber
                if (filters.type === ValidationFilterTypeEnum.NOLETTER) {
                    errors.push(...checkIf(input)
                        .not()
                        .matches(/[A-Za-z]/, validationMessages.inputNoLetter)
                        .hasErrors());
                }
                else if (filters.type === ValidationFilterTypeEnum.NONUMBER) {
                    errors.push(...checkIf(input)
                        .not()
                        .matches(/[0-9]/, validationMessages.inputNoNumber)
                        .hasErrors());
                }
                // if minString is there
                if (filters.minString && (isRequired || (!isRequired && !isEmpty))) {
                    errors.push(...checkIf(input)
                        .hasMinLength(filters.minString, sprintf(validationMessages.minStringInput, filters.minString, input.length))
                        .hasErrors());
                }
                // if maxString is there
                if (filters.maxString && (isRequired || (!isRequired && !isEmpty))) {
                    errors.push(...checkIf(input)
                        .hasMaxLength(filters.maxString, sprintf(validationMessages.maxStringInput, filters.maxString, input.length))
                        .hasErrors());
                }
            }
            else if (filters.type === ValidationFilterTypeEnum.EMAIL) {
                errors.push(...checkIf(input).isEmail(validationMessages.inputEmail).hasErrors());
            }
            else if (filters.type === ValidationFilterTypeEnum.INTEGER ||
                filters.type === ValidationFilterTypeEnum.NUMBER) {
                errors.push(...checkIf(input)
                    .matches(filters.type === ValidationFilterTypeEnum.INTEGER
                    ? /^[-+]?\d+$/
                    : /^[-+]?((([0-9]{1,3})([,][0-9]{3})*)|([0-9]+))?([.]([0-9]+))?$/, filters.type === ValidationFilterTypeEnum.INTEGER
                    ? validationMessages.inputInteger
                    : validationMessages.inputNumber)
                    .hasErrors());
                if (
                // != undefined because we want to take care of null too
                // eslint-disable-next-line eqeqeq
                filters.minNum != undefined &&
                    Number.parseFloat(input) < filters.minNum) {
                    errors.push(sprintf(validationMessages.inputNumMin, filters.minNum, input));
                }
                if (
                // != undefined because we want to take care of null too
                // eslint-disable-next-line eqeqeq
                filters.maxNum != undefined &&
                    Number.parseFloat(input) > filters.maxNum) {
                    errors.push(sprintf(validationMessages.inputNumMax, filters.maxNum, input));
                }
            }
            else if (filters.type === ValidationFilterTypeEnum.PHONE) {
                errors.push(...checkIf(input)
                    .matches(/^([\+][0-9]{1,3}[\ \.\-])?([\(]{1}[0-9]{2,6}[\)])?([0-9\ \.\-\/]{3,20})((x|ext|extension)[\ ]?[0-9]{1,4})?$/, validationMessages.inputPhone)
                    .hasErrors());
            }
            else if (filters.type === ValidationFilterTypeEnum.URL) {
                errors.push(...checkIf(input)
                    .matches(/^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i, validationMessages.inputUrl)
                    .hasErrors());
            }
        }
        return errors;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        if (mutableSubmissionDataValue.text) {
            mutableSubmissionDataValue.text.input = newValue;
        }
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue) {
        let conditionStatus;
        const selectedLength = submissionDataValue.text.input.length;
        if (has === EventHasEnum.LENGTH) {
            const compareLength = getPositiveIntValue(value);
            if (comparison === EventComparisonEnum.GREATER_THAN) {
                conditionStatus = selectedLength > compareLength;
            }
            else if (comparison === EventComparisonEnum.LESS_THAN) {
                conditionStatus = selectedLength < compareLength;
            }
            else {
                conditionStatus = selectedLength === compareLength;
            }
        }
        else {
            // here we have many things to consider
            const inputValue = submissionDataValue.text.input;
            if (comparison === EventComparisonEnum.CONTAINS) {
                const regEx = new RegExp(value, 'gi');
                conditionStatus = regEx.test(inputValue);
            }
            else if (comparison === EventComparisonEnum.ENDS_WITH) {
                const regEx = new RegExp(`${value}$`, 'gi');
                conditionStatus = regEx.test(inputValue);
            }
            else if (comparison === EventComparisonEnum.EQUALS_TO) {
                conditionStatus = value.toLowerCase() === inputValue.toLowerCase();
            }
            else if (comparison === EventComparisonEnum.GREATER_THAN) {
                const valueNum = getNumericValue(value);
                const inputNum = getNumericValue(inputValue);
                conditionStatus = inputNum > valueNum;
            }
            else if (comparison === EventComparisonEnum.LESS_THAN) {
                const valueNum = getNumericValue(value);
                const inputNum = getNumericValue(inputValue);
                conditionStatus = inputNum < valueNum;
            }
            else {
                // starts with
                const regEx = new RegExp(`^${value}`, 'gi');
                conditionStatus = regEx.test(inputValue);
            }
        }
        return operation === EventOperationEnum.IS
            ? conditionStatus
            : !conditionStatus;
    },
    getDisplayValue(elementData, submissionFormDataValue) {
        return submissionFormDataValue.text?.input;
    },
    getNumericValue(elementData, submissionDataValue) {
        return getFloatValue(submissionDataValue.text?.input);
    },
    getAnswerValue(elementData, submissionDataValue) {
        return (jsx(AnswerPreview.UserInput, { children: submissionDataValue.text?.input ?? null }, void 0));
    },
    getPresetValue(elementData, defaultValue) {
        const newDefaultValue = fn(defaultValue, draftValue => {
            // If it has a set default value
            if (!isNullOrEmptyString(elementData.config.text?.attributes.defaultValue)) {
                draftValue.text.input =
                    elementData.config.text.attributes.defaultValue;
            }
            // override if URL query parameter is used
            if (elementData.config.text?.attributes.prefilType === PrefilEnum.URL) {
                const urlParameterValue = getUrlParameterValue(window.location.search, elementData.config.text.attributes.prefilParameter);
                if (urlParameterValue && typeof urlParameterValue === 'string') {
                    draftValue.text.input = urlParameterValue;
                }
            }
            // override if meta based query is used
            if (elementData.config.text?.attributes.prefilType === PrefilEnum.META) {
                const decodedExtra = decodeJSONRecord(elementData.extras);
                if (decodedExtra &&
                    decodedExtra.metaValue &&
                    typeof decodedExtra.metaValue === 'string') {
                    draftValue.text.input = decodedExtra.metaValue;
                }
            }
        });
        return newDefaultValue;
    },
};

function fuzzysearch (needle, haystack) {
  var tlen = haystack.length;
  var qlen = needle.length;
  if (qlen > tlen) {
    return false;
  }
  if (qlen === tlen) {
    return needle === haystack;
  }
  outer: for (var i = 0, j = 0; i < qlen; i++) {
    var nch = needle.charCodeAt(i);
    while (j < tlen) {
      if (haystack.charCodeAt(j++) === nch) {
        continue outer;
      }
    }
    return false;
  }
  return true;
}

var fuzzysearch_1 = fuzzysearch;

const CONTROLCLASS$i = 'wpeform-component-dropdown';
const BUTTONCLASS = getBemElement(CONTROLCLASS$i, 'button');
const DROPDOWNCONTAINERCLASS = getBemElement(CONTROLCLASS$i, 'dd-container');
const FULLSCREENBREAKPOINT = 768;
const OverlayBodyStyle = createGlobalStyle `
body {
	&.${CONTROLCLASS$i}-is-open-mod-body {
		overflow: hidden;
		@media screen and (min-width: ${numToCssSize(FULLSCREENBREAKPOINT)}) {
			overflow: unset;
		}
	}
}
`;
const Prefix$1 = styled.span `
	color: ${props => props.theme.greyLightColor};
	flex: 0 0 1em;
	height: ${props => numToCssSize(props.theme.controlHeightBase)};
	width: 1em;
	display: flex;
	align-items: center;
	justify-content: center;
`;
const ButtonLabel = styled.span `
	padding: 0 ${props => numToCssSize(props.theme.controlHeightBase / 2)} 0
		${props => numToCssSize(props.theme.controlHeightBase / 4)};
	width: calc(100% - 2em);
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
	flex: 1 0 auto;
`;
const DropdownWrapper = styled.div `
	${cssReset};
	position: relative;
	&.${CONTROLCLASS$i}--align-LEFT {
		${ButtonLabel} {
			text-align: left;
		}
	}
	&.${CONTROLCLASS$i}--align-CENTER {
		${ButtonLabel} {
			text-align: center;
		}
	}
	&.${CONTROLCLASS$i}--align-RIGHT {
		${ButtonLabel} {
			text-align: right;
		}
	}
`;
const SuffixIcon = styled.span `
	line-height: 1;
	height: 1em;
	transform: rotate(0deg);
	transform-origin: center center;
	transition: ${props => getMultipleTransitionsWithWillChange(['transform', 'color'], props.theme.transitionControl)};
`;
const Suffix$1 = styled.span `
	color: ${props => props.theme.greyLightColor};
	position: relative;
	flex: 0 0 1em;
	height: ${props => numToCssSize(props.theme.controlHeightBase)};
	width: 1em;
	display: flex;
	align-items: center;
	justify-content: center;
	margin: 0 0 0 auto;
	&::before {
		content: '';
		display: block;
		position: absolute;
		width: 1px;
		top: 18%;
		bottom: 18%;
		background-color: ${props => props.theme.borderColorSplit};
		left: ${props => numToCssSize(props.theme.controlHeightBase / -4)};
	}
`;
const MaterialBorder$1 = styled.div `
	position: absolute;
	height: 2px;
	bottom: 0;
	left: 0;
	right: 0;
	transform-origin: 50% 50%;
	background-color: ${props => props.theme.primaryColor};
	pointer-events: none;
	transform: scaleX(0);
	transition: ${props => getMultipleTransitionsWithWillChange(['transform'], props.theme.transitionBeizer)};
`;
const DropdownButton = styled.button `
	${cssReset};
	cursor: pointer;
	text-align: left;
	background-color: ${props => props.theme.appBackgroundColor};
	appearance: none;
	display: flex;
	align-items: center;
	justify-content: flex-start;
	width: 100%;
	position: relative;
	overflow: hidden;
	height: ${props => numToCssSize(props.theme.controlHeightBase)};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	box-shadow: 0 0 0 0 transparent;
	color: ${props => props.theme.textColor};
	padding: 0 ${props => numToCssSize(props.theme.controlHeightBase / 4)};
	border: 1px solid ${props => props.theme.borderColorBase};
	box-shadow: ${props => props.theme.boxShadowNoneFocus};
	transition: ${props => getMultipleTransitionsWithWillChange(['border-color', 'box-shadow'], props.theme.transitionControl)};

	&:hover {
		color: ${props => props.theme.textColor};
		border-color: ${props => props.theme.primaryColor};
		${Suffix$1} {
			color: ${props => props.theme.textColor};
		}
	}

	&:active,
	&:focus {
		color: ${props => props.theme.textColor};
		border-color: ${props => props.theme.primaryColor};
		box-shadow: ${props => props.theme.boxShadowControlFocus};
	}

	&.${BUTTONCLASS}--is-open {
		border-color: ${props => props.theme.primaryColor};
		box-shadow: ${props => props.theme.boxShadowControlFocus};
		${SuffixIcon} {
			transform: rotate(180deg);
		}
	}

	&.${BUTTONCLASS}--is-empty {
		${ButtonLabel} {
			color: ${props => props.theme.textColorSecondary};
		}
	}

	&.${BUTTONCLASS}--has-error {
		border-color: ${props => props.theme.borderColorError};

		&:hover {
			border-color: ${props => props.theme.borderColorError};
		}

		&:active,
		&:focus {
			border-color: ${props => props.theme.borderColorError};
			box-shadow: ${props => props.theme.boxShadowControlFocusError};
		}

		${Prefix$1} {
			color: ${props => props.theme.errorColor};
		}
	}

	&:disabled {
		background-color: ${props => props.theme.disabledBackgroundColor};
		color: ${props => props.theme.disabledColor};
		border-color: ${props => props.theme.disabledColor};
		cursor: not-allowed;
		box-shadow: none;
	}

	/** MATERIAL STYLE */
	&.${BUTTONCLASS}--type-MATERIAL {
		border: 0 none;
		border-bottom: 2px solid ${props => props.theme.borderColorBase};
		border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)}
			${props => numToCssSize(props.theme.borderRadiusBase)} 0 0;
		box-shadow: none;
		background-color: ${props => props.theme.backgroundControl};
		transition: ${props => getMultipleTransitionsWithWillChange(['background-color'], props.theme.transitionControl)};

		&:hover {
			border-color: ${props => props.theme.borderColorBase};
		}

		&:active,
		&:focus {
			background-color: ${props => curriedTransparentize(0.5, props.theme.backgroundControl)};
			border-color: ${props => props.theme.borderColorBase};
			box-shadow: none;
		}

		&:hover
			+ ${MaterialBorder$1},
			&:active
			+ ${MaterialBorder$1},
			&:focus
			+ ${MaterialBorder$1},
			&.${BUTTONCLASS}--is-open
			+ ${MaterialBorder$1} {
			transform: scaleX(1);
		}

		&.${BUTTONCLASS}--has-error {
			border-bottom-color: ${props => props.theme.borderColorError};

			&:hover {
				border-bottom-color: ${props => props.theme.borderColorError};
			}

			&:active,
			&:focus {
				border-bottom-color: ${props => props.theme.borderColorError};
			}

			+ ${MaterialBorder$1} {
				background-color: ${props => props.theme.borderColorError};
			}
		}

		&:disabled {
			background-color: ${props => props.theme.disabledBackgroundColor};
			color: ${props => props.theme.disabledColor};
			border-color: ${props => props.theme.disabledColor};
			cursor: not-allowed;
			+ ${MaterialBorder$1} {
				transform: scaleX(0);
				background-color: ${props => props.theme.disabledColor};
			}
		}
	}

	/** SIZES */
	&.${BUTTONCLASS}--size-SMALL {
		height: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
		padding: ${props => numToCssSize(props.theme.controlHeightBase / 8)};
		/* font-size: ${props => numToCssSize(props.theme.fz.small1)}; */
		${ButtonLabel} {
			padding: 0 ${props => numToCssSize(props.theme.controlHeightBase / 3)} 0
				${props => numToCssSize(props.theme.controlHeightBase / 8)};
		}
		${Suffix$1} {
			height: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
			&::before {
				left: ${props => numToCssSize(props.theme.controlHeightBase / -6)};
			}
		}
	}
	&.${BUTTONCLASS}--size-LARGE {
		height: ${props => numToCssSize(props.theme.controlHeightBase * 1.2)};
		padding: ${props => numToCssSize(props.theme.controlHeightBase / 4)};
		${Suffix$1} {
			height: ${props => numToCssSize(props.theme.controlHeightBase * 1.2)};
		}
	}
`;
const DropdownMenuContainer = styled.div `
	${cssReset};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	font-family: ${props => props.theme.fontFamilyBody};
	position: fixed;
	z-index: 999997;
	min-width: 300px;

	padding: 0;
	perspective: 200px;

	&.${DROPDOWNCONTAINERCLASS}--size-SMALL {
		min-width: 130px;
	}

	/** Reverse position to bottom for smaller screens */
	@media screen and (max-width: ${numToCssSize(FULLSCREENBREAKPOINT - 1)}) {
		left: ${props => numToCssSize(props.theme.gutter * 2)};
		right: ${props => numToCssSize(props.theme.gutter * 2)};
		bottom: 0;
		width: auto !important;
		top: auto !important;
		min-width: 100px !important;
	}

	/** We position this w.r.t screen width and not container width */
	@media screen and (min-width: ${numToCssSize(FULLSCREENBREAKPOINT)}) {
		width: ${props => numToCssSize(props.width || 300)};
		left: ${props => numToCssSize(props.left || 0)};
		right: auto;
		bottom: auto;
	}
`;
const DropdownMenuContainerAnimated = styled(animated.div) `
	border: 1px solid ${props => props.theme.borderColorSplit};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	background-color: ${props => props.theme.appBackgroundColor};
	box-shadow: ${props => props.theme.boxShadow12dp};
	overflow: hidden;
	will-change: transform, opacity;

	/** Reverse position to bottom for smaller screens */
	@media screen and (max-width: ${numToCssSize(FULLSCREENBREAKPOINT - 1)}) {
		border-bottom: 0 none;
		transform-origin: bottom center !important;
		border-bottom-right-radius: 0;
		border-bottom-left-radius: 0;
	}
`;
const DropdownMenuItemsContainer = styled.div `
	padding: 0;
	border-bottom-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-bottom-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	max-height: calc(
		70vh - ${props => numToCssSize(props.theme.controlHeightBase * 2.5)}
	);
	overflow-y: auto;
	overflow-x: hidden;
	/** We position this w.r.t screen width and not container width */
	@media screen and (min-width: ${numToCssSize(FULLSCREENBREAKPOINT)}) {
		max-height: calc(
			60vh - ${props => numToCssSize(props.theme.controlHeightBase * 2.5)}
		);
	}
`;
const DropdownWidget = styled.div `
	${cssReset};
	padding: ${props => numToCssSize(props.theme.gutter)};
	min-height: 150px;
`;
const DropdownMenuFormControl = styled.div `
	margin: 0;
	margin-bottom: ${props => numToCssSize(props.theme.gutter / 2)};
	&:last-child {
		margin-bottom: 0;
	}
`;
const DropdownMenuLabel = styled.label `
	margin: 0;
	margin-bottom: ${props => numToCssSize(props.theme.gutter / 4)};
	display: block;
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	font-weight: bold;
	text-transform: uppercase;
	color: ${props => props.theme.textColorSecondary};
`;
const DropdownOverlay = styled(animated.div) `
	position: fixed;
	z-index: 999996;
	top: 0;
	left: 0;
	bottom: 0;
	right: 0;
	background-color: rgba(255, 255, 255, 0.75);
	will-change: opacity;

	@media screen and (min-width: ${numToCssSize(FULLSCREENBREAKPOINT)}) {
		display: none;
	}
`;
const DropdownWidgetMenu = styled.div `
	padding: 0;
	margin: 0;
`;
const DropdownWidgetMenuItemSuffix = styled.span `
	height: ${props => numToCssSize(props.theme.controlHeightBase * 0.4)};
	width: ${props => numToCssSize(props.theme.controlHeightBase * 0.4)};
	flex: 0 0 ${props => numToCssSize(props.theme.controlHeightBase * 0.4)};
	border-radius: ${props => numToCssSize(props.theme.controlHeightBase * 0.2)};
	font-size: ${props => numToCssSize(props.theme.controlHeightBase * 0.2)};
	background-color: ${props => props.theme.borderColorSplit};
	color: ${props => props.theme.primaryBgText};
	margin: 0 ${props => numToCssSize(props.theme.gutter / 2)} 0 0;
	display: flex;
	align-items: center;
	justify-content: center;
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'opacity'], props.theme.transitionControl)};
`;
const DropdownWidgetMenuItemContent = styled.span `
	flex: 1 0
		calc(100% - ${props => numToCssSize(props.theme.controlHeightBase * 0.4)});
	width: calc(
		100% - ${props => numToCssSize(props.theme.controlHeightBase * 0.4)}
	);
	text-align: left;
	text-transform: uppercase;
	line-height: 1;
	font-weight: bold;
`;
const DropdownWidgetMenuItem = styled.button `
	position: relative;
	width: 100%;
	min-height: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
	padding: 0 ${props => numToCssSize(props.theme.gutter / 2)};
	border-radius: 0;
	border: 0 none;
	outline: none;
	color: ${props => props.theme.textColorSecondary};
	background-color: ${props => props.theme.appBackgroundColor};
	font-size: ${props => numToCssSize(props.theme.fz.small2)};
	display: flex;
	flex-flow: row nowrap;
	justify-content: flex-start;
	align-items: center;
	text-align: left;
	cursor: pointer;
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'color'], props.theme.transitionControl)};
	${DropdownWidgetMenuItemSuffix} {
		opacity: 0.9;
	}
	&.is-active {
		color: ${props => props.theme.textColor};
		background-color: ${props => props.theme.backgroundControl};
		${DropdownWidgetMenuItemSuffix} {
			background-color: ${props => props.theme.successColor};
			opacity: 0.8;
		}
	}

	&:hover {
		${DropdownWidgetMenuItemSuffix} {
			opacity: 1;
		}
	}

	&:hover,
	&:focus,
	&:active {
		background-color: ${props => props.theme.backgroundHover};
		color: ${props => props.theme.textColor};
	}

	&:focus:active {
		background-color: ${props => props.theme.primaryBackgroundColor};
		transition: ${props => getMultipleTransitionsWithWillChange(['color'], props.theme.transitionControl)};
	}
`;
const DropdownWidgetSplitMenu = styled.div `
	display: flex;
	flex-flow: row wrap;
	padding: 0;
	margin: 0;
`;
const DropdownWidgetSplitMenuColumn = styled.div `
	width: 100%;
	flex: 0 0 100%;
	border-bottom: 1px solid ${props => props.theme.borderColorSplit};
	padding: ${props => numToCssSize(props.theme.gutter / 4)} 0;

	&:last-child {
		border-bottom: 0 none;
	}
	@media screen and (min-width: 768px) {
		width: 50%;
		flex-basis: 50%;
		min-width: 100px;
		border-bottom: 0 none;
		border-right: 1px solid ${props => props.theme.borderColorSplit};
		&:last-child {
			border-right: 0 none;
		}
	}
`;

var props = ["bottom", "height", "left", "right", "top", "width"];

var rectChanged = function rectChanged(a, b) {
  if (a === void 0) {
    a = {};
  }

  if (b === void 0) {
    b = {};
  }

  return props.some(function (prop) {
    return a[prop] !== b[prop];
  });
};

var observedNodes = /*#__PURE__*/new Map();
var rafId;

var run = function run() {
  var changedStates = [];
  observedNodes.forEach(function (state, node) {
    var newRect = node.getBoundingClientRect();

    if (rectChanged(newRect, state.rect)) {
      state.rect = newRect;
      changedStates.push(state);
    }
  });
  changedStates.forEach(function (state) {
    state.callbacks.forEach(function (cb) {
      return cb(state.rect);
    });
  });
  rafId = window.requestAnimationFrame(run);
};

function observeRect(node, cb) {
  return {
    observe: function observe() {
      var wasEmpty = observedNodes.size === 0;

      if (observedNodes.has(node)) {
        observedNodes.get(node).callbacks.push(cb);
      } else {
        observedNodes.set(node, {
          rect: undefined,
          hasRectChanged: false,
          callbacks: [cb]
        });
      }

      if (wasEmpty) run();
    },
    unobserve: function unobserve() {
      var state = observedNodes.get(node);

      if (state) {
        // Remove the callback
        var index = state.callbacks.indexOf(cb);
        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference

        if (!state.callbacks.length) observedNodes["delete"](node); // Stop the loop

        if (!observedNodes.size) cancelAnimationFrame(rafId);
      }
    }
  };
}

function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}

/**
 * React currently throws a warning when using useLayoutEffect on the server. To
 * get around it, we can conditionally useEffect on the server (no-op) and
 * useLayoutEffect in the browser. We occasionally need useLayoutEffect to
 * ensure we don't get a render flash for certain operations, but we may also
 * need affected components to render on the server. One example is when setting
 * a component's descendants to retrieve their index values.
 *
 * Important to note that using this hook as an escape hatch will break the
 * eslint dependency warnings unless you rename the import to `useLayoutEffect`.
 * Use sparingly only when the effect won't effect the rendered HTML to avoid
 * any server/client mismatch.
 *
 * If a useLayoutEffect is needed and the result would create a mismatch, it's
 * likely that the component in question shouldn't be rendered on the server at
 * all, so a better approach would be to lazily render those in a parent
 * component after client-side hydration.
 *
 * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85
 * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js
 *
 * @param effect
 * @param deps
 */

var useIsomorphicLayoutEffect = /*#__PURE__*/canUseDOM() ? useLayoutEffect$1 : useEffect;

/**
 * Checks whether or not a value is a boolean.
 *
 * @param value
 */
function isBoolean(value) {
  return typeof value === "boolean";
}
/**
 * Checks whether or not a value is a function.
 *
 * @param value
 */

function isFunction(value) {
  // eslint-disable-next-line eqeqeq
  return !!(value && {}.toString.call(value) == "[object Function]");
}

/**
 * useRect
 *
 * @param nodeRef
 * @param observe
 * @param onChange
 */
function useRect(nodeRef, observeOrOptions, deprecated_onChange) {
  var observe;
  var onChange;

  if (isBoolean(observeOrOptions)) {
    observe = observeOrOptions;
  } else {
    var _observeOrOptions$obs;

    observe = (_observeOrOptions$obs = observeOrOptions == null ? void 0 : observeOrOptions.observe) != null ? _observeOrOptions$obs : true;
    onChange = observeOrOptions == null ? void 0 : observeOrOptions.onChange;
  }

  if (isFunction(deprecated_onChange)) {
    onChange = deprecated_onChange;
  }

  var _React$useState = useState$1(nodeRef.current),
      element = _React$useState[0],
      setElement = _React$useState[1];

  var initialRectIsSet = useRef(false);
  var initialRefIsSet = useRef(false);

  var _React$useState2 = useState$1(null),
      rect = _React$useState2[0],
      setRect = _React$useState2[1];

  var onChangeRef = useRef(onChange); // eslint-disable-next-line react-hooks/exhaustive-deps

  useIsomorphicLayoutEffect(function () {
    onChangeRef.current = onChange;

    if (nodeRef.current !== element) {
      setElement(nodeRef.current);
    }
  });
  useIsomorphicLayoutEffect(function () {
    if (element && !initialRectIsSet.current) {
      initialRectIsSet.current = true;
      setRect(element.getBoundingClientRect());
    }
  }, [element]);
  useIsomorphicLayoutEffect(function () {
    var observer;
    var elem = element; // State initializes before refs are placed, meaning the element state will
    // be undefined on the first render. We still want the rect on the first
    // render, so initially we'll use the nodeRef that was passed instead of
    // state for our measurements.

    if (!initialRefIsSet.current) {
      initialRefIsSet.current = true;
      elem = nodeRef.current;
    }

    if (!elem) {

      return cleanup;
    }

    observer = observeRect(elem, function (rect) {
      onChangeRef.current == null ? void 0 : onChangeRef.current(rect);
      setRect(rect);
    });
    observe && observer.observe();
    return cleanup;

    function cleanup() {
      observer && observer.unobserve();
    }
  }, [observe, element, nodeRef]);
  return rect;
}

/**
 * A hook to determine if a component is mounted. This is useful when changing
 * state in async callbacks. If we try to set state when the component is no
 * longer mounted, react will handle it, but will show an error and would mean
 * there's a memory leak.
 *
 * Use this hook to prevent such cases.
 */
function useIsMounted() {
    const isMounted = useRef(false);
    useEffect(() => {
        isMounted.current = true;
        return () => {
            isMounted.current = false;
        };
    }, []);
    return isMounted;
}
/**
 * A unique Id generator to be used with Question blocks. This makes sure
 * the Id is unique.
 */
function useQuestionId() {
    const [id] = useState$1(v4);
    return id;
}
/**
 * A hook to hold on to the previous value after changes. Useful for spring
 * utility functions.
 *
 * @param value The value to keep previous of.
 */
function usePrevious(value) {
    const ref = useRef();
    useEffect(() => {
        ref.current = value;
    }, [value]);
    return ref.current;
}
/**
 * A hook for timer countdown stuff.
 *
 * @param time The time in seconds until the timeout reaches.
 * @param onDone Callback after timeout.
 */
function useTimerCountDown(time, onDone) {
    const [secondsLeft, setSecondsLeft] = useState$1(0);
    // an effect to manage countdown time
    useEffect(() => {
        // set the time left to full
        setSecondsLeft(time);
        // capture the interval id to clear it in the updater when the time comes
        let intervalId;
        let intervalCleared = false;
        // Now add a scheduler to decrease it by 1, every second
        const updater = () => {
            setSecondsLeft(sl => {
                const newTime = sl - 1;
                // newTime can never be less than 0
                if (newTime <= 0) {
                    // we also try to clear the interval set in the effect
                    if (intervalId && !intervalCleared) {
                        intervalCleared = true;
                        clearInterval(intervalId);
                    }
                    return 0;
                }
                return newTime;
            });
        };
        intervalId = window.setInterval(updater, 1000);
        return () => {
            if (!intervalCleared) {
                clearInterval(intervalId);
            }
        };
    }, [time]);
    // an effect to do the action
    useEffect(() => {
        if (onDone) {
            const timeoutId = window.setTimeout(onDone, time * 1000);
            return () => {
                clearTimeout(timeoutId);
            };
        }
        return () => { };
    }, [onDone, time]);
    return secondsLeft;
}

const MINIMUM_RIPPLE_SIZE = 100;
const RippleSpan = styled(animated.span) `
	display: block;
	position: absolute;
	border-radius: 50%;
	will-change: opacity, transform;
	pointer-events: none;
`;
function RippleAnimator(props) {
    const { onRest, width, height, left, top, darkBg } = props;
    const theme = useTheme();
    const rippleStyle = useSpring({
        from: {
            opacity: 0.4,
            transform: 'scale(0.4)',
        },
        to: {
            opacity: 0,
            transform: 'scale(12)',
        },
        onRest,
        // a hard preset here
        config: {
            tension: 280,
            friction: 110,
            clamp: true,
        },
    });
    return (jsx(RippleSpan, { style: {
            width: numToCssSize(width),
            height: numToCssSize(height),
            left: numToCssSize(left),
            top: numToCssSize(top),
            backgroundColor: darkBg
                ? curriedTransparentize(0.5, theme.primaryBgText)
                : theme.primaryLightColor,
            ...rippleStyle,
        } }, void 0));
}
/**
 * A hook to create ripple with maximum possible customization for any kinds
 * of elements.
 *
 * This is not a component, rather a hook which lets you attach ripple to any
 * kinds of other component. The only condition is, the parent component should
 * have the following CSS.
 *
 * ```css
 * position: relative;
 * overflow: hidden;
 * ```
 *
 * Use it like
 *
 * ```jsx
 * function Component() {
 * 	const [addRipple, ripples] = useRipple();
 * 	return (
 * 		<button style={{position: 'relative', overflow: 'hidden'}}>
 * 			Ripple Button
 * 		</button>
 *  );
 * }
 * ```
 */
function useRipple({ darkBg } = { darkBg: false }) {
    const [ripples, setRipples] = useState$1([]);
    const mounted = useIsMounted();
    const addRipple = (event) => {
        const { left, top } = event.currentTarget.getBoundingClientRect();
        const x = event.clientX - left;
        const y = event.clientY - top;
        const rippleWidth = Math.min(event.currentTarget.clientWidth / 4, MINIMUM_RIPPLE_SIZE);
        const rippleHeight = Math.min(event.currentTarget.clientHeight / 4, MINIMUM_RIPPLE_SIZE);
        const rippleSize = Math.max(rippleWidth, rippleHeight);
        const key = event.timeStamp;
        setRipples(state => [
            ...state,
            {
                key,
                width: rippleSize,
                height: rippleSize,
                left: x - rippleSize / 2,
                top: y - rippleSize / 2,
                onRest: () => {
                    if (mounted.current) {
                        setRipples(st => st.filter(previousRipple => previousRipple.key !== key));
                    }
                },
                darkBg,
            },
        ]);
    };
    const ripplesArray = ripples.map(currentRipple => {
        return jsx(RippleAnimator, Object.assign({}, currentRipple), void 0);
    });
    return [addRipple, ripplesArray];
}

function useDropdownMenu(isOpen, dropdownButtonRef) {
    const dropdownButtonRect = useRect(dropdownButtonRef, {
        observe: isOpen && window.innerWidth >= FULLSCREENBREAKPOINT,
    });
    const theme = useTheme();
    // Enter and leave animations of dropdown or popup
    const dropdownContainerTransitions = useTransition(isOpen, {
        from: {
            transform: window.innerWidth < FULLSCREENBREAKPOINT
                ? 'translate3d(0, 50px, -50px)'
                : 'translate3d(0, 50px, 0)',
            opacity: 0,
        },
        reverse: isOpen,
        enter: { opacity: 1, transform: 'translate3d(0, 0, 0)' },
        leave: { opacity: 0 },
        config: theme.springConfigStiff,
    });
    return {
        dropdownContainerTransitions,
        dropdownButtonRect,
    };
}
const style = `body.${CONTROLCLASS$i}-is-open-mod-body {
	overflow: hidden;
}
@media screen and (min-width: ${numToCssSize(FULLSCREENBREAKPOINT)}) {
	body.${CONTROLCLASS$i}-is-open-mod-body {
		overflow: unset;
	}
}`;
function useDropdown(onClose, onOpen) {
    const dropdownButtonRef = useRef(null);
    const [isOpen, setIsOpen] = useState$1(false);
    const closePortal = useCallback$1(() => {
        setIsOpen(false);
        if (dropdownButtonRef.current) {
            dropdownButtonRef.current.focus();
        }
    }, []);
    const togglePortal = useCallback$1(() => {
        setIsOpen(o => !o);
    }, []);
    const previouslyOpen = usePrevious(isOpen);
    // an effect to call onClose
    useEffect(() => {
        if (previouslyOpen === true && isOpen === false && onClose) {
            onClose();
        }
        else if (previouslyOpen === false && isOpen === true && onOpen) {
            onOpen();
        }
    }, [isOpen, previouslyOpen, onClose, onOpen]);
    const [addRipple, ripples] = useRipple();
    // an effect to add the style, but only once
    useEffect(() => {
        const id = `${CONTROLCLASS$i}--global-style`;
        const styleElement = document.head.querySelector(`style#${id}`);
        if (styleElement) {
            return () => { };
        }
        const newStyle = document.createElement('style');
        newStyle.setAttribute('id', id);
        newStyle.innerHTML = style;
        document.head.appendChild(newStyle);
        return () => {
            const existingElement = document.head.querySelector(`style#${id}`);
            if (existingElement) {
                existingElement.remove();
            }
        };
    }, []);
    return {
        isOpen,
        closePortal,
        togglePortal,
        dropdownButtonRef,
        addRipple,
        ripples,
    };
}

function DropdownMenuInner(props) {
    const { isOpen, closePortal, dropdownButtonRect, size, dropdownButtonRef, styleProps, children, minMenuWidth, } = props;
    const [positioning, setPositioning] = useState$1({
        top: 0,
        topBleeding: false,
        rightBleeding: false,
    });
    const theme = useTheme();
    const dropdownMenuRef = useRef(null);
    const dropdownMenuRect = useRect(dropdownMenuRef, {
        observe: window.innerWidth >= FULLSCREENBREAKPOINT,
    });
    const container = useResponsiveOuterContainerRef();
    // One layout effect for the focus and body scroll class
    useLayoutEffect$1(() => {
        if (isOpen) {
            setTimeout(() => {
                if (dropdownMenuRef.current) {
                    dropdownMenuRef.current.focus();
                }
            }, 400);
        }
        // add the body overlay class depending on open state of the portal
        if (isOpen) {
            document.body.classList.add(`${CONTROLCLASS$i}-is-open-mod-body`);
        }
        else {
            document.body.classList.remove(`${CONTROLCLASS$i}-is-open-mod-body`);
        }
    }, [dropdownMenuRef, isOpen]);
    // One layout effect to position the dropdown
    // 1. below or above the button
    // 2. left or right the button
    useLayoutEffect$1(() => {
        const resetBleeding = () => {
            setPositioning({
                top: 0,
                rightBleeding: false,
                topBleeding: false,
            });
        };
        if (window.innerWidth < FULLSCREENBREAKPOINT) {
            resetBleeding();
            return;
        }
        if (dropdownButtonRect && dropdownMenuRect) {
            let top = dropdownButtonRect.bottom + theme.gutter / 2;
            const viewPortHeight = window.innerHeight;
            const dropdownHeight = dropdownMenuRect.height;
            let topBleeding = false;
            // If dropdown is going to bleed through the bottom of the window
            if (top + dropdownHeight > viewPortHeight) {
                top = dropdownButtonRect.top - dropdownHeight - theme.gutter / 2;
                // but don't let it bleed from the top
                if (top < theme.gutter / 2) {
                    top = theme.gutter / 2;
                }
                topBleeding = true;
            }
            const viewPortWidth = window.innerWidth;
            const dropdownWidth = dropdownMenuRect.width;
            const ddLeft = dropdownButtonRect.left;
            let rightBleeding = false;
            if (ddLeft + dropdownWidth + theme.gutter > viewPortWidth) {
                rightBleeding = true;
            }
            setPositioning({ top, topBleeding, rightBleeding });
        }
        else {
            // reset if not open
            resetBleeding();
        }
    }, [dropdownButtonRect, dropdownMenuRect, theme.gutter]);
    // an effect to close it on esc or outside click
    useEffect(() => {
        if (isOpen) {
            // since we are dealing with shadow root, we have to be a little clever
            // when clicked anywhere inside the shadow root, the event.target would
            // be the shadow root itself.
            // If that is the case, then from window perspective, we don't do anything
            const isTargetInDropdown = (event) => {
                // if the target is not in document body or shadow body
                // then we assume it is in the dropdown
                const target = event.target;
                if (!document.body.contains(target) &&
                    container.current &&
                    !container.current.contains(target)) {
                    return true;
                }
                return (event.target === dropdownMenuRef.current ||
                    dropdownMenuRef.current?.contains(event.target) ||
                    event.target === dropdownButtonRef.current ||
                    dropdownButtonRef.current?.contains(event.target));
            };
            const handlerWindow = (event) => {
                if (event.target.shadowRoot) {
                    return;
                }
                // not a shadow root, so proceed with normal checking
                if (isTargetInDropdown(event)) {
                    return;
                }
                closePortal();
            };
            // Now from shadowroot, it will have regular stuff
            const handlerShadow = (event) => {
                if (isTargetInDropdown(event)) {
                    return;
                }
                closePortal();
            };
            const containerDom = container.current;
            window.addEventListener('click', handlerWindow);
            if (containerDom) {
                containerDom.addEventListener('click', handlerShadow);
            }
            return () => {
                window.removeEventListener('click', handlerWindow);
                if (containerDom) {
                    containerDom.removeEventListener('click', handlerShadow);
                }
            };
        }
        return () => { };
    }, [closePortal, isOpen, container, dropdownButtonRef]);
    // an effect to close on esc key press
    useEffect(() => {
        if (isOpen) {
            const handler = (event) => {
                if (event.key === 'Escape') {
                    closePortal();
                }
            };
            document.addEventListener('keyup', handler);
            return () => {
                document.removeEventListener('keyup', handler);
            };
        }
        return () => { };
    }, [closePortal, isOpen]);
    const menuContainerClassName = getBemClassName(DROPDOWNCONTAINERCLASS, {
        [`size-${size}`]: true,
    });
    let containerWidth = dropdownButtonRect?.width;
    if (minMenuWidth && containerWidth && containerWidth < minMenuWidth) {
        containerWidth = minMenuWidth;
    }
    let calculatedLeft;
    if (dropdownButtonRect && dropdownMenuRect) {
        calculatedLeft = positioning.rightBleeding
            ? dropdownButtonRect.left -
                (dropdownMenuRect.width - dropdownButtonRect.width)
            : dropdownButtonRect.left;
    }
    return (jsxs(ResponsiveContainer.Portal, { children: [jsx(DropdownOverlay, { style: { opacity: styleProps.opacity } }, void 0), jsx(DropdownMenuContainer, Object.assign({ style: { top: numToCssSize(positioning.top) }, left: calculatedLeft, width: containerWidth, ref: dropdownMenuRef, tabIndex: 0, className: menuContainerClassName }, { children: jsx(DropdownMenuContainerAnimated, Object.assign({ style: styleProps, className: classNames({ 'is-bleeding': positioning.topBleeding }) }, { children: children }), void 0) }), void 0)] }, void 0));
}

function DropdownMenu$1(props) {
    const { closePortal, isOpen, menu, size, dropdownButtonRef, minMenuWidth } = props;
    const { dropdownContainerTransitions, dropdownButtonRect } = useDropdownMenu(isOpen, dropdownButtonRef);
    return dropdownContainerTransitions((styleProps, shown) => shown && (jsx("div", { children: jsx(DropdownMenuInner, Object.assign({ isOpen: isOpen, closePortal: closePortal, size: size, dropdownButtonRect: dropdownButtonRect, dropdownButtonRef: dropdownButtonRef, styleProps: styleProps, minMenuWidth: minMenuWidth }, { children: menu(closePortal) }), void 0) }, void 0)));
}

/**
 * A generic dropdown menu component. Useful to display collapsed items.
 *
 * This is highly responsive and takes a modal view in small devices.
 *
 * @param props component props.
 */
function Dropdown(props) {
    const { prefix, controlType = SettingsAppearanceControlTypeEnum.BOXY, controlAlignment = SettingsAppearanceControlAlignmentEnum.LEFT, size = GenericSizeEnum.DEFAULT, className, disabled, buttonLabel, passiveButton = false, menu, onClose, onOpen, hasError = false, minMenuWidth, loading = false, ...buttonProps } = props;
    const { isOpen, closePortal, togglePortal, dropdownButtonRef, addRipple, ripples, } = useDropdown(onClose, onOpen);
    const containerClasses = getBemClassName(CONTROLCLASS$i, {
        'is-open': isOpen,
        [`type-${controlType}`]: true,
        [`align-${controlAlignment}`]: typeof buttonLabel !== 'string',
    }, className);
    const buttonClasses = getBemClassName(BUTTONCLASS, {
        'is-empty': passiveButton,
        'is-open': isOpen,
        [`type-${controlType}`]: true,
        'has-error': hasError,
        [`size-${size}`]: true,
    });
    return (jsxs(DropdownWrapper, Object.assign({ className: containerClasses }, { children: [jsx(OverlayBodyStyle, {}, void 0), jsxs(DropdownButton, Object.assign({ type: "button", disabled: disabled || loading, className: buttonClasses, ref: dropdownButtonRef, onClick: e => {
                    addRipple(e);
                    togglePortal();
                } }, buttonProps, { children: [ripples, prefix || loading ? (jsx(Prefix$1, { children: loading ? jsx(Icon, { iconClass: "fas fa-spinner fa-pulse" }, void 0) : prefix }, void 0)) : null, jsx(ButtonLabel, { children: buttonLabel }, void 0), jsx(Suffix$1, { children: jsx(SuffixIcon, { children: jsx(Icon, { iconClass: "fas fa-chevron-down" }, void 0) }, void 0) }, void 0)] }), void 0), controlType === SettingsAppearanceControlTypeEnum.MATERIAL ? (jsx(MaterialBorder$1, {}, void 0)) : null, jsx(DropdownMenu$1, { closePortal: closePortal, isOpen: isOpen, menu: menu, size: size, dropdownButtonRef: dropdownButtonRef, minMenuWidth: minMenuWidth }, void 0)] }), void 0));
}
Dropdown.Widget = DropdownWidget;
Dropdown.FormControl = DropdownMenuFormControl;
Dropdown.Label = DropdownMenuLabel;
Dropdown.Menu = DropdownWidgetMenu;
Dropdown.MenuItem = function (props) {
    const { children, active, onClick } = props;
    return (jsxs(DropdownWidgetMenuItem, Object.assign({ className: classNames({ 'is-active': active }), onClick: e => {
            e.preventDefault();
            onClick();
        } }, { children: [jsx(DropdownWidgetMenuItemSuffix, { children: jsx(Icon, { iconClass: "fas fa-check" }, void 0) }, void 0), jsx(DropdownWidgetMenuItemContent, { children: children }, void 0)] }), void 0));
};
Dropdown.SplitMenu = DropdownWidgetSplitMenu;
Dropdown.SplitMenuColumn = DropdownWidgetSplitMenuColumn;
Dropdown.ScrollableItems = DropdownMenuItemsContainer;

const CONTROLCLASS$h = 'wpeform-control-select';
const SEARCHCLASS = getBemElement(CONTROLCLASS$h, 'search');
const DROPDOWNSELECTCONTAINERCLASS = getBemElement(CONTROLCLASS$h, 'menu');
const DropdownResetContainerScroller = styled.div `
	display: flex;
	flex-flow: row nowrap;
	align-items: center;
	justify-content: flex-start;
	overflow-x: auto;
`;
const DropdownResetButton = styled.button `
	${cssReset};
	color: ${props => props.theme.textColor};
	padding: ${props => numToCssSize(props.theme.gutter / 4)};
	background-color: ${props => props.theme.backgroundControl};
	border: 0 none;
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	cursor: pointer;
	flex: 0 0 ${props => numToCssSize((props.theme.controlHeightBase * 3) / 4)};
	width: ${props => numToCssSize((props.theme.controlHeightBase * 3) / 4)};
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'color'], props.theme.transitionControl)};

	&:hover,
	&:active,
	&:focus {
		background-color: ${props => props.theme.errorBackgroundColor};
		color: ${props => props.theme.errorColor};
	}
`;
const DropdownSearchContainer = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter / 2)};
	margin: 0;
	border-bottom: 1px solid ${props => props.theme.borderColorSplit};
	display: flex;
	flex-flow: row nowrap;
	${DropdownResetButton} {
		flex: 0 0 ${props => numToCssSize(props.theme.controlHeightBase)};
		margin-left: auto;
		width: ${props => numToCssSize(props.theme.controlHeightBase)};
		height: ${props => numToCssSize(props.theme.controlHeightBase)};
	}
`;
const DropdownSearchTextContainer = styled.div `
	flex: 0 0
		calc(
			100% -
				${props => numToCssSize(props.theme.controlHeightBase + props.theme.gutter / 2)}
		);
	width: calc(
		100% -
			${props => numToCssSize(props.theme.controlHeightBase + props.theme.gutter / 2)}
	);
`;
const DropdownResetContainer = styled.div `
	margin: 0;
	padding: ${props => numToCssSize(props.theme.gutter / 4)};
	border-top: 1px solid ${props => props.theme.borderColorSplit};
	border-bottom-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-bottom-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
`;
const DropdownResetControl = styled.div `
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	margin: ${props => numToCssSize(props.theme.gutter / 4)};
	padding: 0 0 0 ${props => numToCssSize(props.theme.gutter / 4)};
	flex: 0 0 auto;
	background-color: ${props => props.asPlaceholder ? 'transparent' : props.theme.backgroundControl};
	display: flex;
	align-items: center;
	justify-content: flex-start;
	color: ${props => props.asPlaceholder ? props.theme.disabledColor : props.theme.textColor};
	max-width: 250px;

	span {
		padding: ${props => numToCssSize(props.theme.gutter / 4)};
		max-width: calc(
			100% -
				${props => props.asPlaceholder
    ? '0px'
    : numToCssSize((props.theme.controlHeightBase * 3) / 4)}
		);
		flex: 0 0 auto;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}
`;
const DropdownEmptyItem = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter * 2)}
		${props => numToCssSize(props.theme.gutter / 2)};
	color: ${props => props.theme.greyLightColor};
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	width: 100%;
	text-align: center;
`;
const DropdownEmptyItemIcon = styled.div `
	width: 100%;
	flex: 0 0 100%;
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
	font-size: ${props => numToCssSize(props.theme.fz.large8)};
	color: ${props => props.theme.disabledColor};
	.${CONTROLCLASS$k} {
		display: block;
		margin: 0 auto;
	}
`;
const DropdownEmptyItemText = styled.p `
	width: 100%;
	flex: 0 0 100%;
	margin: 0;
	padding: 0;
`;
const DropdownMenuItemLabel = styled.span `
	flex: 0 0 calc(100% - ${props => numToCssSize(props.theme.controlHeightBase)});
`;
const DropdownMenuItemIcon = styled.span `
	margin-left: auto;
	flex: 0 0 ${props => numToCssSize(props.theme.controlHeightBase / 2)};
	width: ${props => numToCssSize(props.theme.controlHeightBase / 2)};
	height: ${props => numToCssSize(props.theme.controlHeightBase / 2)};
	background-color: ${props => props.theme.borderColorSplit};
	color: ${props => props.theme.primaryBgText};
	display: flex;
	align-items: center;
	justify-content: center;
	opacity: 0;
	font-size: ${props => numToCssSize(props.theme.controlHeightBase * 0.25)};
	border-radius: 50%;
	transition: ${props => getMultipleTransitionsWithWillChange(['opacity', 'background-color'], props.theme.transitionControl)};
`;
const DropdownMenuItem = styled.button `
	${cssReset};
	display: flex;
	width: 100%;
	align-items: center;
	justify-content: flex-start;
	text-align: left;
	background-color: ${props => props.theme.appBackgroundColor};
	color: ${props => props.theme.textColorSecondary};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	padding: ${props => numToCssSize(props.theme.gutter / 2)}
		${props => numToCssSize(props.theme.gutter)};
	outline: none;
	border: 0 none;
	cursor: pointer;
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'color'], props.theme.transitionControl)};

	&.is-active {
		color: ${props => props.theme.textColor};
		${DropdownMenuItemIcon} {
			background-color: ${props => props.theme.successColor};
			opacity: 0.8;
		}
	}

	&:hover {
		${DropdownMenuItemIcon} {
			opacity: 0.5;
		}
	}

	&:hover,
	&:focus,
	&:active {
		background-color: ${props => props.theme.backgroundHover};
		color: ${props => props.theme.textColor};
	}

	&:focus:active {
		background-color: ${props => props.theme.primaryBackgroundColor};
		transition: ${props => getMultipleTransitionsWithWillChange(['color'], props.theme.transitionControl)};
	}
`;
const DropdownSelectContainer = styled.div `
	&.${DROPDOWNSELECTCONTAINERCLASS}--size-SMALL {
		${DropdownSearchTextContainer} {
			flex-basis: calc(
				100% -
					${props => numToCssSize(props.theme.controlHeightBase * 0.8 + props.theme.gutter / 4)}
			);
			width: calc(
				100% -
					${props => numToCssSize(props.theme.controlHeightBase * 0.8 + props.theme.gutter / 4)}
			);
		}
		${DropdownResetButton} {
			height: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
			width: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
			flex-basis: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
			font-size: ${props => numToCssSize(props.theme.fz.small1)};
		}
		${DropdownMenuItem} {
			font-size: ${props => numToCssSize(props.theme.fz.base)};
			padding: ${props => numToCssSize(props.theme.gutter / 4)}
				${props => numToCssSize(props.theme.gutter / 2)};
		}
		${DropdownMenuItemIcon} {
			flex-basis: ${props => numToCssSize(props.theme.controlHeightBase * 0.4)};
			width: ${props => numToCssSize(props.theme.controlHeightBase * 0.4)};
			height: ${props => numToCssSize(props.theme.controlHeightBase * 0.4)};
			font-size: ${props => numToCssSize(props.theme.controlHeightBase * 0.2)};
		}
		${DropdownMenuItemLabel} {
			flex-basis: calc(
				100% - ${props => numToCssSize(props.theme.controlHeightBase * 0.6)}
			);
		}
		${DropdownResetContainer} {
			padding-top: 0;
			padding-bottom: 0;
		}
	}
`;

function DropdownMenu(props) {
    const { showSearch, searchPlaceholder = __('Search items', 'wp-eform'), emptyResultPlaceholder = __('No items found', 'wp-eform'), items, value, onChange, toggleValue, itemsInValue, controlType, closePortal, placeholder, size, canClear = true, mode, } = props;
    const [search, setSearch] = useState$1('');
    const inputRef = useRef(null);
    const searchedFilteredItems = useMemo(() => {
        return search !== ''
            ? items.filter(item => fuzzysearch_1(search.toLowerCase(), item.plain.toLowerCase()))
            : items;
    }, [search, items]);
    return (jsxs(DropdownSelectContainer, Object.assign({ className: getBemClassName(DROPDOWNSELECTCONTAINERCLASS, {
            [`size-${size}`]: true,
        }) }, { children: [showSearch ? (jsxs(DropdownSearchContainer, { children: [jsx(DropdownSearchTextContainer, { children: jsx(Text$2, { size: size, innerRef: inputRef, className: SEARCHCLASS, value: search, onChange: setSearch, prefix: jsx(Icon, { iconClass: "fas fa-search" }, void 0), placeholder: searchPlaceholder, controlType: controlType }, void 0) }, void 0), jsx(DropdownResetButton, Object.assign({ type: "button", onClick: e => {
                            e.preventDefault();
                            closePortal();
                        } }, { children: jsx(Icon, { iconClass: "fas fa-times" }, void 0) }), void 0)] }, void 0)) : null, jsx(Dropdown.ScrollableItems, { children: searchedFilteredItems.length ? (searchedFilteredItems.map(item => (jsxs(DropdownMenuItem, Object.assign({ className: classNames({
                        'is-active': value.includes(item.value),
                    }), onClick: e => {
                        e.preventDefault();
                        toggleValue(item.value);
                        // if single, then auto close it
                        if (mode === SelectTypeEnum.SINGLE) {
                            closePortal();
                        }
                    } }, { children: [jsx(DropdownMenuItemLabel, { children: item.label }, void 0), jsx(DropdownMenuItemIcon, { children: jsx(Icon, { iconClass: "fas fa-check" }, void 0) }, void 0)] }), item.value)))) : (jsxs(DropdownEmptyItem, { children: [jsx(DropdownEmptyItemIcon, { children: jsx(Icon, { iconClass: "fas fa-box-open" }, void 0) }, void 0), jsx(DropdownEmptyItemText, { children: emptyResultPlaceholder }, void 0)] }, void 0)) }, void 0), canClear ? (jsx(DropdownResetContainer, { children: jsx(DropdownResetContainerScroller, { children: itemsInValue.length ? (itemsInValue.map(item => {
                        return (jsxs(DropdownResetControl, { children: [jsx("span", { children: item.label }, void 0), jsx(DropdownResetButton, Object.assign({ type: "button", onClick: e => {
                                        e.preventDefault();
                                        onChange(value.filter(v => v !== item.value));
                                    } }, { children: jsx(Icon, { iconClass: "fas fa-times" }, void 0) }), void 0)] }, item.value));
                    })) : (jsx(DropdownResetControl, Object.assign({ asPlaceholder: true }, { children: jsx("span", { children: placeholder }, void 0) }), void 0)) }, void 0) }, void 0)) : null] }), void 0));
}
/**
 * A dropdown control element used to replace HTML select. It is enhanced with
 * a combobox feature and has proper appearance on mobile and desktop devices.
 * The component is always controlled.
 *
 * Regardless of the mode, it always accepts and passes an array of string for
 * the selected values. If mode is set to single, the component will make sure
 * that the array only has one value in the `onChange` handler.
 *
 * @param props component props.
 */
function Select(props) {
    const { items, placeholder, showSearch = true, searchPlaceholder, emptyResultPlaceholder, value, mode, onChange, controlType = SettingsAppearanceControlTypeEnum.BOXY, controlAlignment = SettingsAppearanceControlAlignmentEnum.LEFT, className, canClear = true, onBlur, size = GenericSizeEnum.DEFAULT, ...dropdownProps } = props;
    const itemsInValue = items.filter(item => value && value.includes(item.value));
    const toggleValue = useCallback$1((itemValue) => {
        if (value.includes(itemValue)) {
            if (mode === SelectTypeEnum.SINGLE) {
                return;
            }
            onChange(value.filter(v => v !== itemValue));
        }
        else {
            // eslint-disable-next-line no-lonely-if
            if (mode === SelectTypeEnum.MULTIPLE) {
                onChange([...value, itemValue]);
            }
            else {
                onChange([itemValue]);
            }
        }
    }, [value, mode, onChange]);
    const isEmpty = value === null || !value.length;
    const containerClasses = getBemClassName(CONTROLCLASS$h, {
        'is-empty': isEmpty,
        [`type-${controlType}`]: true,
        [`mode-${mode}`]: true,
        [`align-${controlAlignment}`]: typeof placeholder !== 'string',
    }, className);
    const buttonLabel = itemsInValue.length
        ? // we filter from items and not map from value
            // because we would like to keep the original order of items.
            itemsInValue.map(item => item.plain).join(', ')
        : placeholder;
    return (jsx(Dropdown, Object.assign({ buttonLabel: buttonLabel, menu: closePortal => (jsx(DropdownMenu, { showSearch: showSearch, emptyResultPlaceholder: emptyResultPlaceholder, items: items, itemsInValue: itemsInValue, onChange: onChange, searchPlaceholder: searchPlaceholder, placeholder: placeholder, toggleValue: toggleValue, value: value, controlType: controlType, closePortal: closePortal, size: size, canClear: canClear, mode: mode }, void 0)), className: containerClasses, controlAlignment: controlAlignment, controlType: controlType, onClose: onBlur, passiveButton: isEmpty, size: size }, dropdownProps), void 0));
}

const CONTROLCLASS$g = 'wpeform-control-addon';
const ControlAddonContainer = styled(animated.div) `
	${cssReset};
	&.${CONTROLCLASS$g}--gutter-top {
		padding-top: ${props => numToCssSize(props.theme.gutter)};
	}
	&.${CONTROLCLASS$g}--gutter-bottom {
		padding-bottom: ${props => numToCssSize(props.theme.gutter)};
	}
	&.${CONTROLCLASS$g}--gutter-horizontal {
		padding-left: ${props => numToCssSize(props.theme.gutter)};
		padding-right: ${props => numToCssSize(props.theme.gutter)};
	}
	will-change: transform, opacity;
`;
/**
 * Use this component to animate in or out some add-on based on some logic.
 * Useful for things like Free Input inside some MCQ etc.
 */
function ControlAddon(props) {
    const { children, visible, gutterTop = true, gutterBottom = false, gutterHorizontal = false, className, } = props;
    const theme = useTheme();
    const controlTransitions = useTransition(visible, {
        from: {
            opacity: 0,
            transform: 'translate3d(-50px, 0, 0)',
        },
        enter: {
            opacity: 1,
            transform: 'translate3d(0px, 0, 0)',
        },
        reverse: visible,
        leave: {
            opacity: 0,
            transform: 'translate3d(50px, 0, 0)',
        },
        config: theme.springConfigStiff,
    });
    return controlTransitions((styleProps, item) => item && (jsx(ControlAddonContainer, Object.assign({ className: getBemClassName(CONTROLCLASS$g, {
            'gutter-top': gutterTop,
            'gutter-bottom': gutterBottom,
            'gutter-horizontal': gutterHorizontal,
        }, className), style: styleProps }, { children: children }), void 0)));
}

function OtherInput$2(props) {
    const { id, elementData, submissionData, updateSubmissionData } = props;
    const otherValue = submissionData.value.dropdown?.other ?? '';
    const updateOtherValue = useCallback$1((newVal) => {
        updateSubmissionData(fn(submissionData, draftState => {
            draftState.value.dropdown.other = newVal;
        }));
    }, [submissionData, updateSubmissionData]);
    const isOtherVisible = !!submissionData.value.dropdown?.selected.includes(elementData.config.dropdown?.interface?.othersId);
    const placeholderNodes = useNodesFromJson(elementData.config.dropdown?.interface?.othersPlaceholder);
    return (jsx(ControlAddon, Object.assign({ visible: isOtherVisible }, { children: jsx(Text$2, { id: `other-${id}`, value: otherValue, onChange: updateOtherValue, prefix: jsx(Icon, { iconClass: "fas fa-pen-nib" }, void 0), hasError: isOtherVisible &&
                elementData.config.dropdown?.validation?.required &&
                otherValue === '', placeholder: placeholderNodes ? (jsx(SlateViewWithData, { nodes: placeholderNodes, currentElementId: elementData.id }, void 0)) : (__('enter your choice here', 'wp-eform')) }, void 0) }), void 0));
}
const dropdown = {
    id: 'dropdown',
    hasSubmission: true,
    FormUi({ id, elementData, submissionData, updateSubmissionData, setElementTouched, controlType, controlLayout, controlAlignment, elementTitle, hasError = false, }) {
        const items = useMemo(() => {
            const allOptions = [
                ...(elementData.config.dropdown?.interface?.options ?? []),
            ];
            if (elementData.config.dropdown?.interface?.shuffle) {
                shuffleArray(allOptions);
            }
            return allOptions.map(op => {
                const nodes = getNodesFromJSON(op.label);
                return {
                    label: (jsx(SlateViewWithData, { nodes: nodes, mode: "singleline", currentElementId: elementData.id }, void 0)),
                    plain: getStringValueFromNodes(nodes),
                    value: op.id,
                };
            });
        }, [
            elementData.config.dropdown?.interface?.options,
            elementData.config.dropdown?.interface?.shuffle,
            elementData.id,
        ]);
        // figure out the extra input before hand
        const isOtherRequired = elementData.config.dropdown?.interface?.others;
        return (jsxs(Fragment, { children: [jsx(Select, { id: id, items: items, disabled: elementData.config.dropdown?.attributes.readonly, emptyResultPlaceholder: elementData.config.dropdown?.interface?.emptySearchResultNotice ||
                        '', mode: elementData.config.dropdown?.validation?.selectType ??
                        SelectTypeEnum.SINGLE, onChange: nextVal => {
                        updateSubmissionData(fn(submissionData, draftState => {
                            draftState.value.dropdown.selected = nextVal;
                        }));
                    }, onBlur: () => {
                        setElementTouched(true);
                    }, placeholder: controlLayout !== SettingsAppearanceControlLayoutEnum.INLINE
                        ? elementData.config.dropdown?.interface?.placeholder || ''
                        : elementTitle, showSearch: elementData.config.dropdown?.interface?.showSearch, searchPlaceholder: elementData.config.dropdown?.interface?.searchPlaceholder || '', value: submissionData.value.dropdown?.selected ?? [], controlType: controlType, controlAlignment: controlAlignment, hasError: hasError, prefix: elementData.config.dropdown?.interface?.icon ? (jsx(Icon, { iconClass: elementData.config.dropdown?.interface?.icon }, void 0)) : undefined }, void 0), isOtherRequired ? (jsx(OtherInput$2, { elementData: elementData, id: id, submissionData: submissionData, updateSubmissionData: updateSubmissionData }, void 0)) : null] }, void 0));
    },
    isQuestion: true,
    isRequired(elementData) {
        if (elementData.config.dropdown?.validation?.required) {
            return true;
        }
        return false;
    },
    getErrors(elementData, submissionDataValue) {
        const errors = [];
        // required check
        const isRequired = !!elementData.config.dropdown?.validation?.required;
        const totalSelectedOptions = submissionDataValue.dropdown?.selected.length;
        const isEmpty = totalSelectedOptions === 0;
        const isOtherEnabled = elementData.config.dropdown?.interface?.others;
        const isOtherVisible = !!submissionDataValue.dropdown?.selected.includes(elementData.config.dropdown?.interface?.othersId);
        if (isRequired && isEmpty) {
            errors.push(validationMessages.requiredOptions);
        }
        // if this is single value type, then ignore maxItems and minItems
        if (elementData.config.dropdown?.validation?.selectType ===
            SelectTypeEnum.SINGLE) {
            return errors;
        }
        const maxItems = elementData.config.dropdown?.validation?.filters.maxItems;
        if (maxItems && totalSelectedOptions && totalSelectedOptions > maxItems) {
            errors.push(sprintf(validationMessages.maxOptions, maxItems, totalSelectedOptions));
        }
        const minItems = isRequired
            ? elementData.config.dropdown?.validation?.filters.minItems ?? 1
            : 0;
        if (minItems && totalSelectedOptions && totalSelectedOptions < minItems) {
            errors.push(sprintf(validationMessages.minOptions, minItems, totalSelectedOptions));
        }
        // if it is required and other is visible, but not entered
        if (isRequired &&
            isOtherEnabled &&
            isOtherVisible &&
            !submissionDataValue.dropdown?.other) {
            errors.push(validationMessages.requiredOther);
        }
        return errors;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        const options = elementData.config.dropdown?.interface?.options;
        if (options) {
            // get to make sure the newValue actually exists in the set of options
            if (options.find(o => o.id === newValue)) {
                mutableSubmissionDataValue.dropdown.selected = [newValue];
            }
        }
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue, elementData) {
        let conditionStatus;
        const selectedLength = submissionDataValue.dropdown.selected.length;
        if (has === EventHasEnum.LENGTH) {
            const compareLength = getPositiveIntValue(value);
            if (comparison === EventComparisonEnum.GREATER_THAN) {
                conditionStatus = selectedLength > compareLength;
            }
            else if (comparison === EventComparisonEnum.LESS_THAN) {
                conditionStatus = selectedLength < compareLength;
            }
            else {
                conditionStatus = selectedLength === compareLength;
            }
        }
        else {
            // here we compare with either equals to, i.e only one option is selected
            // eslint-disable-next-line no-lonely-if
            const compareWithValue = getOptionIdsFromString(value, elementData.config.dropdown?.validation?.selectType ===
                SelectTypeEnum.SINGLE);
            const allSelectedInCompareWith = compareWithValue.every(val => submissionDataValue.dropdown?.selected.includes(val)) ?? false;
            if (comparison === EventComparisonEnum.EQUALS_TO) {
                conditionStatus =
                    selectedLength === compareWithValue.length &&
                        allSelectedInCompareWith;
            }
            else {
                // the selected one may contain the value
                conditionStatus = allSelectedInCompareWith;
            }
        }
        return operation === EventOperationEnum.IS
            ? conditionStatus
            : !conditionStatus;
    },
    getDisplayValue(elementData, submissionDataValue) {
        const selectedOptionIds = submissionDataValue.dropdown?.selected;
        if (selectedOptionIds &&
            selectedOptionIds.length &&
            elementData.config.dropdown?.interface?.options.length) {
            const selectedOptions = getChosenItemsInOrder(selectedOptionIds, elementData.config.dropdown.interface.options);
            return selectedOptions.map((op, index) => (jsxs(React__default.Fragment, { children: [jsx(SlateViewWithoutMentions, { nodes: getNodesFromJSON(op.label), mode: "singleline" }, void 0), index !== selectedOptions.length - 1 ? jsx("span", { children: ", " }, void 0) : null] }, op.id)));
        }
        return null;
    },
    getNumericValue(elementData, submissionDataValue) {
        const selectedOptionIds = submissionDataValue.dropdown?.selected;
        if (selectedOptionIds &&
            selectedOptionIds.length &&
            elementData.config.dropdown?.interface?.options.length) {
            const selectedOptions = getChosenItemsInOrder(selectedOptionIds, elementData.config.dropdown.interface.options);
            return selectedOptions.reduce((acc, cur) => {
                return acc + (cur.num ?? 0);
            }, 0);
        }
        return 0;
    },
    getAnswerValue(elementData, submissionDataValue) {
        const selectedOptionIds = submissionDataValue.dropdown?.selected;
        if (selectedOptionIds &&
            selectedOptionIds.length &&
            elementData.config.dropdown?.interface?.options.length) {
            const selectedOptions = getChosenItemsInOrder(selectedOptionIds, elementData.config.dropdown.interface.options);
            const selectedOptionsList = selectedOptions.map(op => {
                const description = getNodesFromJSON(op.answerDescription);
                return (jsxs("li", { children: [jsx(SlateViewWithData, { nodes: getNodesFromJSON(op.label), mode: "singleline", currentElementId: elementData.id }, void 0), !isNodesEmpty(description) ? (jsxs(Fragment, { children: [jsx(AnswerPreview.Separator, { isLight: true }, void 0), jsx(AnswerPreview.OptionDescription, { children: jsx(SlateViewWithData, { nodes: description, mode: "multiline", currentElementId: elementData.id }, void 0) }, void 0)] }, void 0)) : null] }, op.id));
            });
            return (jsxs(AnswerPreview.Generic, { children: [jsx("ul", { children: selectedOptionsList }, void 0), submissionDataValue.dropdown?.other &&
                        elementData.config.dropdown.interface.others &&
                        selectedOptionIds.includes(elementData.config.dropdown.interface.othersId) ? (jsxs(Fragment, { children: [jsx(AnswerPreview.Separator, {}, void 0), jsx(AnswerPreview.UserInput, { children: submissionDataValue.dropdown.other }, void 0)] }, void 0)) : null] }, void 0));
        }
        return __('No options selected.', 'wp-eform');
    },
    getPresetValue(elementData, defaultValue) {
        const newDefaultValue = fn(defaultValue, draftValue => {
            // If it has a set default value
            if (!isNullOrEmptyString(elementData.config.dropdown?.attributes.defaultValue)) {
                draftValue.dropdown.selected = getOptionIdsFromString(elementData.config.dropdown.attributes.defaultValue, elementData.config.dropdown?.validation?.selectType ===
                    SelectTypeEnum.SINGLE);
            }
            // override if URL query parameter is used
            if (elementData.config.dropdown?.attributes.prefilType === PrefilEnum.URL) {
                const compareWith = getUrlParameterValue(window.location.search, elementData.config.dropdown.attributes.prefilParameter);
                if (compareWith) {
                    const possibleOptionIds = matchValuesAgainstOptionLabel(elementData.config.dropdown.interface?.options, compareWith);
                    if (possibleOptionIds.length) {
                        draftValue.dropdown.selected = possibleOptionIds;
                    }
                }
            }
            // override if meta based query is used
            if (elementData.config.dropdown?.attributes.prefilType === PrefilEnum.META) {
                const decodedExtra = decodeJSONRecord(elementData.extras);
                if (decodedExtra && decodedExtra.metaValue) {
                    // metaValue here will be array of option ids, but make sure it is present
                    const metaValue = decodedExtra.metaValue;
                    if (Array.isArray(metaValue)) {
                        const newSelectedValue = [];
                        elementData.config.dropdown.interface?.options.forEach(op => {
                            if (metaValue.includes(op.id)) {
                                newSelectedValue.push(op.id);
                            }
                        });
                        if (newSelectedValue.length) {
                            draftValue.dropdown.selected = newSelectedValue;
                        }
                    }
                }
            }
        });
        return newDefaultValue;
    },
};

const IconMessageWrap = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter / 2)};
	display: flex;
	flex-flow: column nowrap;
	align-items: center;
	justify-content: center;

	.wp-eform-iconmessage__icon {
		width: 64px;
		margin: 0 auto ${props => numToCssSize(props.theme.gutter / 2)};
		color: ${props => props.theme.disabledColor};
		svg {
			max-width: 64px;
			height: auto;
			display: block;
		}
		.${CONTROLCLASS$k} {
			font-size: 64px;
			text-shadow: 4px 4px 0 ${props => props.theme.backgroundShade};
		}
	}

	.wp-eform-iconmessage__text,
	.wp-eform-iconmessage__text p {
		font-size: ${props => numToCssSize(props.theme.fz.base)};
		color: ${props => props.theme.disabledColor};
		text-align: center;
	}
`;
function IconMessage({ icon, children }) {
    return (jsxs(IconMessageWrap, Object.assign({ className: "wp-eform-iconmessage" }, { children: [jsx("div", Object.assign({ className: "wp-eform-iconmessage__icon" }, { children: icon }), void 0), jsx("div", Object.assign({ className: "wp-eform-iconmessage__text" }, { children: children }), void 0)] }), void 0));
}

var animatedScrollTo = {};

var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(animatedScrollTo, "__esModule", { value: true });
// --------- HELPERS
function getElementOffset(el) {
    var top = 0;
    var left = 0;
    var element = el;
    // Loop through the DOM tree
    // and add it's parent's offset to get page offset
    do {
        top += element.offsetTop || 0;
        left += element.offsetLeft || 0;
        element = element.offsetParent;
    } while (element);
    return {
        top: top,
        left: left,
    };
}
// --------- SCROLL INTERFACES
// ScrollDomElement and ScrollWindow have identical interfaces
var ScrollDomElement = /** @class */ (function () {
    function ScrollDomElement(element) {
        this.element = element;
    }
    ScrollDomElement.prototype.getHorizontalScroll = function () {
        return this.element.scrollLeft;
    };
    ScrollDomElement.prototype.getVerticalScroll = function () {
        return this.element.scrollTop;
    };
    ScrollDomElement.prototype.getMaxHorizontalScroll = function () {
        return this.element.scrollWidth - this.element.clientWidth;
    };
    ScrollDomElement.prototype.getMaxVerticalScroll = function () {
        return this.element.scrollHeight - this.element.clientHeight;
    };
    ScrollDomElement.prototype.getHorizontalElementScrollOffset = function (elementToScrollTo, elementToScroll) {
        return getElementOffset(elementToScrollTo).left - getElementOffset(elementToScroll).left;
    };
    ScrollDomElement.prototype.getVerticalElementScrollOffset = function (elementToScrollTo, elementToScroll) {
        return getElementOffset(elementToScrollTo).top - getElementOffset(elementToScroll).top;
    };
    ScrollDomElement.prototype.scrollTo = function (x, y) {
        this.element.scrollLeft = x;
        this.element.scrollTop = y;
    };
    return ScrollDomElement;
}());
var ScrollWindow = /** @class */ (function () {
    function ScrollWindow() {
    }
    ScrollWindow.prototype.getHorizontalScroll = function () {
        return window.scrollX || document.documentElement.scrollLeft;
    };
    ScrollWindow.prototype.getVerticalScroll = function () {
        return window.scrollY || document.documentElement.scrollTop;
    };
    ScrollWindow.prototype.getMaxHorizontalScroll = function () {
        return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth) - window.innerWidth;
    };
    ScrollWindow.prototype.getMaxVerticalScroll = function () {
        return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - window.innerHeight;
    };
    ScrollWindow.prototype.getHorizontalElementScrollOffset = function (elementToScrollTo) {
        var scrollLeft = window.scrollX || document.documentElement.scrollLeft;
        return scrollLeft + elementToScrollTo.getBoundingClientRect().left;
    };
    ScrollWindow.prototype.getVerticalElementScrollOffset = function (elementToScrollTo) {
        var scrollTop = window.scrollY || document.documentElement.scrollTop;
        return scrollTop + elementToScrollTo.getBoundingClientRect().top;
    };
    ScrollWindow.prototype.scrollTo = function (x, y) {
        window.scrollTo(x, y);
    };
    return ScrollWindow;
}());
// --------- KEEPING TRACK OF ACTIVE ANIMATIONS
var activeAnimations = {
    elements: [],
    cancelMethods: [],
    add: function (element, cancelAnimation) {
        activeAnimations.elements.push(element);
        activeAnimations.cancelMethods.push(cancelAnimation);
    },
    remove: function (element, shouldStop) {
        if (shouldStop === void 0) { shouldStop = true; }
        var index = activeAnimations.elements.indexOf(element);
        if (index > -1) {
            // Stop animation
            if (shouldStop) {
                activeAnimations.cancelMethods[index]();
            }
            // Remove it
            activeAnimations.elements.splice(index, 1);
            activeAnimations.cancelMethods.splice(index, 1);
        }
    }
};
// --------- CHECK IF CODE IS RUNNING IN A BROWSER
var WINDOW_EXISTS = typeof window !== 'undefined';
// --------- ANIMATE SCROLL TO
var defaultOptions = {
    cancelOnUserAction: true,
    easing: function (t) { return (--t) * t * t + 1; },
    elementToScroll: WINDOW_EXISTS ? window : null,
    horizontalOffset: 0,
    maxDuration: 3000,
    minDuration: 250,
    speed: 500,
    verticalOffset: 0,
};
function animateScrollTo(numberOrCoordsOrElement, userOptions) {
    if (userOptions === void 0) { userOptions = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var x, y, scrollToElement, options, isWindow, isElement, scrollBehaviorElement, scrollBehavior, elementToScroll, maxHorizontalScroll, initialHorizontalScroll, horizontalDistanceToScroll, maxVerticalScroll, initialVerticalScroll, verticalDistanceToScroll, horizontalDuration, verticalDuration, duration;
        return __generator(this, function (_a) {
            // Check for server rendering
            if (!WINDOW_EXISTS) {
                // @ts-ignore
                // If it still gets called on server, return Promise for API consistency
                return [2 /*return*/, new Promise(function (resolve) {
                        resolve(false); // Returning false on server
                    })];
            }
            else if (!window.Promise) {
                throw ('Browser doesn\'t support Promises, and animated-scroll-to depends on it, please provide a polyfill.');
            }
            options = __assign(__assign({}, defaultOptions), userOptions);
            isWindow = options.elementToScroll === window;
            isElement = !!options.elementToScroll.nodeName;
            if (!isWindow && !isElement) {
                throw ('Element to scroll needs to be either window or DOM element.');
            }
            scrollBehaviorElement = isWindow ? document.documentElement : options.elementToScroll;
            scrollBehavior = getComputedStyle(scrollBehaviorElement).getPropertyValue('scroll-behavior');
            if (scrollBehavior === 'smooth') {
                console.warn(scrollBehaviorElement.tagName + " has \"scroll-behavior: smooth\" which can mess up with animated-scroll-to's animations");
            }
            elementToScroll = isWindow ?
                new ScrollWindow() :
                new ScrollDomElement(options.elementToScroll);
            if (numberOrCoordsOrElement instanceof Element) {
                scrollToElement = numberOrCoordsOrElement;
                // If "elementToScroll" is not a parent of "scrollToElement"
                if (isElement &&
                    (!options.elementToScroll.contains(scrollToElement) ||
                        options.elementToScroll.isSameNode(scrollToElement))) {
                    throw ('options.elementToScroll has to be a parent of scrollToElement');
                }
                x = elementToScroll.getHorizontalElementScrollOffset(scrollToElement, options.elementToScroll);
                y = elementToScroll.getVerticalElementScrollOffset(scrollToElement, options.elementToScroll);
            }
            else if (typeof numberOrCoordsOrElement === 'number') {
                x = elementToScroll.getHorizontalScroll();
                y = numberOrCoordsOrElement;
            }
            else if (Array.isArray(numberOrCoordsOrElement) && numberOrCoordsOrElement.length === 2) {
                x = numberOrCoordsOrElement[0] === null ? elementToScroll.getHorizontalScroll() : numberOrCoordsOrElement[0];
                y = numberOrCoordsOrElement[1] === null ? elementToScroll.getVerticalScroll() : numberOrCoordsOrElement[1];
            }
            else {
                // ERROR
                throw ('Wrong function signature. Check documentation.\n' +
                    'Available method signatures are:\n' +
                    '  animateScrollTo(y:number, options)\n' +
                    '  animateScrollTo([x:number | null, y:number | null], options)\n' +
                    '  animateScrollTo(scrollToElement:Element, options)');
            }
            // Add offsets
            x += options.horizontalOffset;
            y += options.verticalOffset;
            maxHorizontalScroll = elementToScroll.getMaxHorizontalScroll();
            initialHorizontalScroll = elementToScroll.getHorizontalScroll();
            // If user specified scroll position is greater than maximum available scroll
            if (x > maxHorizontalScroll) {
                x = maxHorizontalScroll;
            }
            horizontalDistanceToScroll = x - initialHorizontalScroll;
            maxVerticalScroll = elementToScroll.getMaxVerticalScroll();
            initialVerticalScroll = elementToScroll.getVerticalScroll();
            // If user specified scroll position is greater than maximum available scroll
            if (y > maxVerticalScroll) {
                y = maxVerticalScroll;
            }
            verticalDistanceToScroll = y - initialVerticalScroll;
            horizontalDuration = Math.abs(Math.round((horizontalDistanceToScroll / 1000) * options.speed));
            verticalDuration = Math.abs(Math.round((verticalDistanceToScroll / 1000) * options.speed));
            duration = horizontalDuration > verticalDuration ? horizontalDuration : verticalDuration;
            // Set minimum and maximum duration
            if (duration < options.minDuration) {
                duration = options.minDuration;
            }
            else if (duration > options.maxDuration) {
                duration = options.maxDuration;
            }
            // @ts-ignore
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    // Scroll is already in place, nothing to do
                    if (horizontalDistanceToScroll === 0 && verticalDistanceToScroll === 0) {
                        // Resolve promise with a boolean hasScrolledToPosition set to true
                        resolve(true);
                    }
                    // Cancel existing animation if it is already running on the same element
                    activeAnimations.remove(options.elementToScroll, true);
                    // To cancel animation we have to store request animation frame ID 
                    var requestID;
                    // Cancel animation handler
                    var cancelAnimation = function () {
                        removeListeners();
                        cancelAnimationFrame(requestID);
                        // Resolve promise with a boolean hasScrolledToPosition set to false
                        resolve(false);
                    };
                    // Registering animation so it can be canceled if function
                    // gets called again on the same element
                    activeAnimations.add(options.elementToScroll, cancelAnimation);
                    // Prevent user actions handler
                    var preventDefaultHandler = function (e) { return e.preventDefault(); };
                    var handler = options.cancelOnUserAction ?
                        cancelAnimation :
                        preventDefaultHandler;
                    // If animation is not cancelable by the user, we can't use passive events
                    var eventOptions = options.cancelOnUserAction ?
                        { passive: true } :
                        { passive: false };
                    var events = [
                        'wheel',
                        'touchstart',
                        'keydown',
                        'mousedown',
                    ];
                    // Function to remove listeners after animation is finished
                    var removeListeners = function () {
                        events.forEach(function (eventName) {
                            options.elementToScroll.removeEventListener(eventName, handler, eventOptions);
                        });
                    };
                    // Add listeners
                    events.forEach(function (eventName) {
                        options.elementToScroll.addEventListener(eventName, handler, eventOptions);
                    });
                    // Animation
                    var startingTime = Date.now();
                    var step = function () {
                        var timeDiff = Date.now() - startingTime;
                        var t = timeDiff / duration;
                        var horizontalScrollPosition = Math.round(initialHorizontalScroll + (horizontalDistanceToScroll * options.easing(t)));
                        var verticalScrollPosition = Math.round(initialVerticalScroll + (verticalDistanceToScroll * options.easing(t)));
                        if (timeDiff < duration && (horizontalScrollPosition !== x || verticalScrollPosition !== y)) {
                            // If scroll didn't reach desired position or time is not elapsed
                            // Scroll to a new position
                            elementToScroll.scrollTo(horizontalScrollPosition, verticalScrollPosition);
                            // And request a new step
                            requestID = requestAnimationFrame(step);
                        }
                        else {
                            // If the time elapsed or we reached the desired offset
                            // Set scroll to the desired offset (when rounding made it to be off a pixel or two)
                            // Clear animation frame to be sure
                            elementToScroll.scrollTo(x, y);
                            cancelAnimationFrame(requestID);
                            // Remove listeners
                            removeListeners();
                            // Remove animation from the active animations coordinator
                            activeAnimations.remove(options.elementToScroll, false);
                            // Resolve promise with a boolean hasScrolledToPosition set to true
                            resolve(true);
                        }
                    };
                    // Start animating scroll
                    requestID = requestAnimationFrame(step);
                })];
        });
    });
}
var _default = animatedScrollTo.default = animateScrollTo;

/**
 * A component to properly show/hide conditional form elements (or anything)
 * with spring animation.
 *
 * It does not animate on initial condition.
 */
function AnimatedConditional(props) {
    const { children, visible, mode } = props;
    if (mode === 'live') {
        if (!visible) {
            return null;
        }
        return jsx(Fragment, { children: children }, void 0);
    }
    return jsx("div", Object.assign({ style: { opacity: visible ? '1' : '0.4' } }, { children: children }), void 0);
}

const CONTROLCLASS$f = 'wpeform-component-animatein';
const Container$4 = styled.div `
	perspective: 600px;
`;
const AnimateInContainer = styled(animated.div) `
	will-change: opacity, transform;
`;
const NoAnimateInContainer = styled.div ``;
function WithoutAnimation(props) {
    return (jsx(Container$4, Object.assign({ className: CONTROLCLASS$f }, { children: jsx(NoAnimateInContainer, { children: props.children }, void 0) }), void 0));
}
function AnimateChild(props) {
    const [skip, setSkip] = useState$1(false);
    const { ref, inView } = useInView({
        threshold: 0,
        rootMargin: '0px 0px -50px 0px',
        triggerOnce: true,
        skip,
    });
    useEffect(() => {
        if (inView === true) {
            setSkip(true);
        }
    }, [inView]);
    const config = useClampedSpringConfig('slow');
    const styleProps = useSpring({
        opacity: inView ? 1 : 0,
        transform: inView ? 'translate3d(0px, 0, 0)' : 'translate3d(60px, 0, 0)',
        config,
    });
    return (jsx(Container$4, Object.assign({ className: CONTROLCLASS$f, ref: ref }, { children: jsx(AnimateInContainer, Object.assign({ style: styleProps }, { children: props.children }), void 0) }), void 0));
}
/**
 * An AnimateIn component to declaratively animate a component in when it
 * comes within the viewport. It uses IntersectionObserver under the hood.
 *
 * It animates the children components only once when offset from the bottom
 * is 50px.
 */
function AnimateIn(props) {
    const { mode = 'live' } = props;
    return mode === 'live' ? (jsx(AnimateChild, Object.assign({}, props), void 0)) : (jsx(WithoutAnimation, Object.assign({}, props), void 0));
}

const CONTROLCLASS$e = 'wpeform-component-question';
const QuestionHeader = styled.div `
	width: 100%;
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
	flex: 0 0 100%;
`;
const QuestionTitle = styled.label `
	display: block;
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	font-weight: ${props => (props.theme.boldHeading ? 'bold' : 'normal')};
	font-family: ${props => props.theme.fontFamilyHeading};
	color: ${props => props.theme.headingColor};
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 8)} 0;
	position: relative;
`;
const QuestionAsterisk = styled.span `
	color: ${props => props.theme.errorColor};
	font-size: ${props => numToCssSize(props.theme.fz.small2 - 4)};
	margin: 0 0 0 0.25em;
	vertical-align: super;
	position: relative;
	top: -0.2em;
`;
const QuestionSubtitle = styled.label `
	display: block;
	font-family: ${props => props.theme.fontFamilyHeading};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	color: ${props => props.theme.textColorSecondary};
	font-style: ${props => (props.theme.italicHeading ? 'italic' : 'normal')};
`;
const QuestionDescription = styled.div `
	margin: ${props => numToCssSize(props.theme.gutter / 2)} 0 0 0;
	color: ${props => props.theme.textColor};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
`;
const QuestionControlContainer = styled.div `
	width: 100%;
	flex: 0 0 100%;
`;
const QuestionControlErrorsContainer = styled.div `
	margin: ${props => numToCssSize(props.theme.gutter / 5)} 0 0 0;
	width: 100%;
	overflow: hidden;
`;
const QuestionControlError = styled(animated.p) `
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	line-height: 1.5;
	color: ${props => props.theme.errorColor};
	font-weight: normal;
	margin: 0;
	padding: 0;
	.${CONTROLCLASS$k} {
		font-size: ${props => numToCssSize(props.theme.fz.small1 - 6)};
		vertical-align: super;
	}
`;
const QuestionControl = styled.div ``;
const QuestionHintContainer = styled.div `
	margin: ${props => numToCssSize(props.theme.gutter / 2)} 0 0 0;
`;
const QuestionHintButton = styled.button `
	border: 0 none;
	outline: none;
	display: inline-block;
	margin: 0;
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	background-color: ${props => props.theme.disabledBackgroundColor};
	cursor: pointer;
	color: ${props => props.theme.textColorSecondary};
	padding: ${props => numToCssSize(props.theme.gutter / 4)}
		${props => numToCssSize(props.theme.gutter / 2)};
	font-size: ${props => numToCssSize(props.theme.fz.small2)};
	text-transform: uppercase;
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'color'], props.theme.transitionControl)};

	&:hover {
		background-color: ${props => props.theme.backgroundShade};
		color: ${props => props.theme.textColor};
	}

	&:active,
	&:focus {
		background-color: ${props => props.theme.backgroundControl};
		color: ${props => props.theme.textColor};
	}

	> span {
		display: block;
	}

	&:active {
		> span {
			transform: scale(0.9);
		}
	}

	&.active {
		border-bottom-left-radius: 0;
		border-bottom-right-radius: 0;
		color: ${props => props.theme.textColor};
	}
`;
const QuestionHint = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter)};
	background-color: ${props => props.theme.disabledBackgroundColor};
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	color: ${props => props.theme.textColor};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-top-left-radius: 0;
`;
const QuestionHintAnimated = styled(animated.div) `
	overflow: hidden;
`;
const QuestionContainer = styled.div `
	${cssReset};
	display: flex;
	flex-flow: row wrap;

	/** For Layouts */
	&.${CONTROLCLASS$e}--layout-HORIZONTAL {
		/** For mobile */
		/** Let it inherit the default styling (vertical) */
		/** For Tablet and upword */
		&.${CONTROLCLASS$e}--size-tablet {
			${QuestionHeader} {
				flex: 0 0 calc(40% - ${props => numToCssSize(props.theme.gutter)});
				width: calc(40% - ${props => numToCssSize(props.theme.gutter)});
				margin-right: ${props => numToCssSize(props.theme.gutter)};
				margin-bottom: 0;
			}
			${QuestionControlContainer} {
				flex: 0 0 60%;
				width: 60%;
			}
		}
	}
	/** Vertical is default and inline will hide header */

	/** For Alignment */
	&.${CONTROLCLASS$e}--alignment-CENTER {
		${QuestionHeader} {
			text-align: center;
		}
	}
	&.${CONTROLCLASS$e}--alignment-RIGHT {
		${QuestionHeader} {
			text-align: right;
		}
	}
`;

function Asterisk() {
    return (jsx(QuestionAsterisk, { children: jsx(Icon, { iconClass: "fas fa-asterisk" }, void 0) }, void 0));
}
/**
 * A general purpose Question component to show individual form control elements.
 * It has all the configuration props take into account the common appearance
 * config of EForm elements.
 */
function Question(props) {
    const { id, layout = SettingsAppearanceControlLayoutEnum.VERTICAL, alignment = SettingsAppearanceControlAlignmentEnum.LEFT, title, subtitle, description, hintMessage, hintIcon = 'fas fa-question', hintLabel, asterisk = false, children, className, errors = [], } = props;
    const containerClassNames = useResponsiveClassNames(useContainerSize(), CONTROLCLASS$e, {
        'has-subtitle': !!subtitle,
        'has-description': !!description,
        'has-hint': !!hintMessage,
        [`layout-${layout}`]: true,
        [`alignment-${alignment}`]: true,
    }, className);
    const theme = useTheme();
    // Transition for errors
    const errorTransitions = useTransition(errors.map((err, index) => ({ err, index })), {
        keys: item => item.err,
        from: { transform: 'translate3d(-50px, 0, 0)', opacity: 0 },
        enter: { transform: 'translate3d(0px, 0, 0)', opacity: 1 },
        leave: { transform: 'translate3d(50px, 0, 0)', opacity: 0 },
        config: theme.springConfigGeneral,
        trail: 200,
    });
    // state for hints
    const [hintShown, setHintShown] = useState$1(false);
    const hintContainerRef = useRef(null);
    const size = componentSize(hintContainerRef);
    const animatedHintStyle = useSpring({
        opacity: hintShown ? 1 : 0,
        height: hintShown ? size.height : 0,
        config: {
            ...theme.springConfigStiff,
            clamp: true,
        },
    });
    return (jsxs(QuestionContainer, Object.assign({ className: containerClassNames }, { children: [layout !== SettingsAppearanceControlLayoutEnum.INLINE && title ? (jsxs(QuestionHeader, { children: [jsxs(QuestionTitle, Object.assign({ htmlFor: id }, { children: [title, asterisk ? jsx(Asterisk, {}, void 0) : null] }), void 0), subtitle ? (jsx(QuestionSubtitle, Object.assign({ htmlFor: id }, { children: subtitle }), void 0)) : null, description ? (jsx(QuestionDescription, { children: description }, void 0)) : null] }, void 0)) : null, jsxs(QuestionControlContainer, { children: [jsx(QuestionControl, { children: children }, void 0), jsx(QuestionControlErrorsContainer, { children: errorTransitions((style, item) => (jsxs(QuestionControlError, Object.assign({ style: style }, { children: [jsx(Icon, { iconClass: "fas fa-asterisk" }, void 0), " ", item.err] }), void 0))) }, void 0), hintMessage ? (jsxs(QuestionHintContainer, { children: [jsx(QuestionHintButton, Object.assign({ onClick: e => {
                                    e.preventDefault();
                                    setHintShown(h => !h);
                                }, className: classNames({ active: hintShown }) }, { children: jsxs("span", { children: [hintIcon ? (jsxs(Fragment, { children: [jsx(Icon, { iconClass: hintIcon }, void 0), ' '] }, void 0)) : null, hintLabel ?? ''] }, void 0) }), void 0), jsx(QuestionHintAnimated, Object.assign({ style: animatedHintStyle }, { children: jsx(QuestionHint, Object.assign({ ref: hintContainerRef }, { children: hintMessage }), void 0) }), void 0)] }, void 0)) : null] }, void 0)] }), void 0));
}
Question.Asterisk = Asterisk;

function getCurrentUrl() {
    return window.location.href;
}
function getCurrentOrigin() {
    return `${window.location.protocol}//${window.location.host}`;
}
/**
 * Get parent element of an element. Accounts for shadow root in path.
 *
 * @param element Current element node.
 * @returns ParentNode or undefined.
 */
function getParentElement(element) {
    let parent = element.parentElement;
    if (parent && parent.host) {
        parent = parent.host;
    }
    return parent;
}
/**
 * Get scroll parents of an element. Accounts for shadow root in path.
 *
 * @param element Current element.
 * @returns Array of scroll parents.
 */
function scrollParents(element) {
    let parent;
    const arr = [];
    const overflowRegex = /(auto|scroll)/;
    for (parent = element; parent !== document.body && parent != null; parent = getParentElement(parent)) {
        const style = getComputedStyle(parent);
        if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) {
            arr.push(parent);
        }
    }
    arr.push(window);
    return arr;
}
const logger = {
    style: {
        wpEForm: 'background-color: #0967D2; color: #ffffff; padding: 4px;',
        success: 'background-color: #0F8613; color: #ffffff; padding: 4px;',
        error: 'background-color: #CF1124; color: #ffffff; padding: 4px;',
        reset: 'background-color: transparent; color: inherit; padding: 0;',
    },
    labels: {
        wpEForm: 'WPEFORM',
        err: 'ERROR',
    },
    log(...args) {
        if (console && console.log) {
            console.log(...args);
        }
    },
    debug(input, type = 'l') {
        if (typeof WPEFormGraphQLApp !== 'undefined' && WPEFormGraphQLApp.debug) {
            if (type === 'l') {
                this.l(input);
            }
            else {
                this.e(input);
            }
        }
    },
    l(input, ...styles) {
        if (console && console.log) {
            console.log(`%c WPEFORM %c / ${input}`, logger.style.wpEForm, logger.style.reset, ...styles);
        }
    },
    e(input) {
        if (console && console.log) {
            console.log(`%c ${logger.labels.wpEForm} %c %c ${logger.labels.err} %c / ${input}`, logger.style.wpEForm, logger.style.reset, logger.style.error, logger.style.reset);
        }
    },
};

const CONTROLCLASS$d = 'wpeform-component-alert';
const AlertBorder = styled.div `
	position: absolute;
	top: 0;
	left: 0;
	bottom: 0;
	width: ${props => numToCssSize(props.theme.borderRadiusBase * 1.5)};
	border-top-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-bottom-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	background-color: ${props => props.theme.borderColorBase};
`;
const AlertIcon = styled.div `
	height: ${props => numToCssSize(props.theme.fz.base * 3)};
	width: ${props => numToCssSize(props.theme.fz.base * 3)};
	border-radius: ${props => numToCssSize(props.theme.fz.base * 1.5)};
	background-color: ${props => curriedLighten(0.2, props.theme.borderColorBase)};
	flex: 0 0 ${props => numToCssSize(props.theme.fz.base * 3)};
	margin: 0 ${props => numToCssSize(props.theme.gutter)} 0 0;
	display: flex;
	align-items: center;
	justify-content: center;
	color: ${props => props.theme.headingColor};
	.${CONTROLCLASS$k} {
		height: ${props => numToCssSize(props.theme.fz.base * 2)};
		width: ${props => numToCssSize(props.theme.fz.base * 2)};
		font-size: ${props => numToCssSize(props.theme.fz.base)};
		background-color: ${props => props.theme.appBackgroundColor};
		border-radius: ${props => numToCssSize(props.theme.fz.base * 1)};
		display: inline-flex;
		align-items: center;
		justify-content: center;
	}
`;
const AlertProse = styled.div `
	flex: 1 0 100%;
`;
const AlertTitle = styled.h4 `
	font-weight: bold;
	color: ${props => props.theme.headingColor};
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	line-height: 1.2;
`;
const AlertMessage = styled.div `
	color: ${props => props.theme.textColor};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	line-height: 1.5;
	p {
		font-size: ${props => numToCssSize(props.theme.fz.base)};
		line-height: 1.5;
	}
	code {
		padding: 0 4px;
		background-color: rgba(0, 0, 0, 0.05);
	}
	> * {
		margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
		&:last-child {
			margin-bottom: 0;
		}
	}
`;
const AlertDismissButton = styled.button `
	${cssReset};
	background-color: transparent;
	padding: 0;
	border: 0 none;
	outline: none;
	color: ${props => curriedDarken(0.2, props.theme.borderColorBase)};
	transition: ${props => getMultipleTransitionsWithWillChange(['color'], props.theme.transitionControl)};
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	position: absolute;
	top: 0;
	right: 0;
	cursor: pointer;
	display: flex;
	height: ${props => numToCssSize(props.theme.fz.small1 * 2)};
	width: ${props => numToCssSize(props.theme.fz.small1 * 2)};
	align-items: center;
	justify-content: center;

	&:hover,
	&:focus {
		color: ${props => props.theme.headingColor};
	}
`;
const AlertContent = styled.div `
	border-top-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-bottom-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border: 1px solid ${props => curriedLighten(0.2, props.theme.borderColorBase)};
	border-left: 0 none;
	padding: ${props => numToCssSize(props.theme.gutter)};
	display: flex;
	flex-flow: row nowrap;
	align-items: center;
	position: relative;
`;
const AlertContainer = styled(animated.div) `
	${cssReset};
	will-change: transform, opacity;
	background-color: ${props => props.theme.appBackgroundColor};
	overflow: hidden;
	position: relative;
	padding: 0 0 0 ${props => numToCssSize(props.theme.borderRadiusBase * 1.5)};

	/** Icon mod */
	&.${CONTROLCLASS$d}--has-icon {
		${AlertProse} {
			flex: 1 0
				calc(
					100% -
						${props => numToCssSize(props.theme.fz.base * 3 + props.theme.gutter)}
				);
			width: calc(
				100% -
					${props => numToCssSize(props.theme.fz.base * 3 + props.theme.gutter)}
			);
		}
	}

	&.${CONTROLCLASS$d}--type-error {
		${AlertBorder} {
			background-color: ${props => props.theme.errorColor};
		}
		${AlertContent} {
			background-color: ${props => props.theme.errorBackgroundColor};
			border-color: ${props => curriedDarken(0.1, props.theme.errorBackgroundColor)};
		}
		${AlertIcon} {
			background-color: ${props => curriedDarken(0.1, props.theme.errorBackgroundColor)};
		}
		${AlertDismissButton} {
			color: ${props => curriedDarken(0.4, props.theme.errorBackgroundColor)};

			&:hover {
				color: ${props => props.theme.errorColor};
			}
		}
	}
	&.${CONTROLCLASS$d}--type-warn {
		${AlertBorder} {
			background-color: ${props => props.theme.warningColor};
		}
		${AlertContent} {
			background-color: ${props => props.theme.warningBackgroundColor};
			border-color: ${props => curriedDarken(0.15, props.theme.warningBackgroundColor)};
		}
		${AlertIcon} {
			background-color: ${props => curriedDarken(0.15, props.theme.warningBackgroundColor)};
		}
		${AlertDismissButton} {
			color: ${props => curriedDarken(0.4, props.theme.warningBackgroundColor)};

			&:hover {
				color: ${props => props.theme.warningColor};
			}
		}
	}
	&.${CONTROLCLASS$d}--type-success {
		${AlertBorder} {
			background-color: ${props => props.theme.successColor};
		}
		${AlertContent} {
			background-color: ${props => props.theme.successBackgroundColor};
			border-color: ${props => curriedDarken(0.1, props.theme.successBackgroundColor)};
		}
		${AlertIcon} {
			background-color: ${props => curriedDarken(0.1, props.theme.successBackgroundColor)};
		}
		${AlertDismissButton} {
			color: ${props => curriedDarken(0.4, props.theme.successBackgroundColor)};

			&:hover {
				color: ${props => props.theme.successColor};
			}
		}
	}
	&.${CONTROLCLASS$d}--type-primary {
		${AlertBorder} {
			background-color: ${props => props.theme.primaryColor};
		}
		${AlertContent} {
			background-color: ${props => props.theme.primaryBackgroundColor};
			border-color: ${props => curriedDarken(0.1, props.theme.primaryBackgroundColor)};
		}
		${AlertIcon} {
			background-color: ${props => curriedDarken(0.1, props.theme.primaryBackgroundColor)};
		}
		${AlertDismissButton} {
			color: ${props => curriedDarken(0.4, props.theme.primaryBackgroundColor)};

			&:hover {
				color: ${props => props.theme.primaryColor};
			}
		}
	}
`;
const AlertParent = styled.div `
	${cssReset};
	perspective: 600px;
`;
function Alert(props) {
    const { children, icon, dismissable, type, title, onDismiss } = props;
    const [shown, setShown] = useState$1(true);
    const theme = useTheme();
    const alertTransition = useTransition(shown, {
        from: {
            opacity: 0,
            transform: 'translate3d(0px, 0px, 0px)',
        },
        enter: {
            opacity: 1,
            transform: 'translate3d(0px, 0px, 0px)',
        },
        leave: {
            opacity: 0,
            transform: 'translate3d(50px, 0px, 0px)',
        },
        reverse: shown,
        config: shown ? theme.springConfigStiff : theme.springConfigGeneral,
    });
    return alertTransition((styles, item) => item && (jsx(AlertParent, { children: jsxs(AlertContainer, Object.assign({ className: getBemClassName(CONTROLCLASS$d, {
                [`type-${type}`]: true,
                dismissable: !!dismissable,
                'has-icon': !!icon,
            }), style: styles }, { children: [jsx(AlertBorder, {}, void 0), jsxs(AlertContent, { children: [dismissable ? (jsx(AlertDismissButton, Object.assign({ title: __('Dismiss', 'wp-eform'), onClick: e => {
                                e.preventDefault();
                                if (onDismiss) {
                                    onDismiss();
                                }
                                setShown(false);
                            } }, { children: jsx(Icon, { iconClass: "fas fa-times" }, void 0) }), void 0)) : null, icon ? (jsx(AlertIcon, { children: jsx(Icon, { iconClass: icon }, void 0) }, void 0)) : null, jsxs(AlertProse, { children: [title ? jsx(AlertTitle, { children: title }, void 0) : null, jsx(AlertMessage, { children: children }, void 0)] }, void 0)] }, void 0)] }), void 0) }, void 0)));
}

class AppErrorBoundary extends Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false, lastError: null };
    }
    static getDerivedStateFromError(error) {
        // Update state so the next render will show the fallback UI.
        return { hasError: true, lastError: error };
    }
    componentDidCatch(error, errorInfo) {
        if (typeof window !== 'undefined' && typeof Sentry !== 'undefined') {
            Sentry.captureException(error);
        }
    }
    resetError = () => {
        this.setState({ hasError: false, lastError: null });
    };
    render() {
        const { fallback, children } = this.props;
        return this.state.hasError
            ? fallback(this.resetError, this.state.lastError)
            : children;
    }
}

/**
 * A hook to immediately invoke or schedule a function for given delay through
 * `useEffect` hook.
 *
 * @param callback Function to call after timeout, must be memoized.
 * @param delay Delay in seconds, could be 0.
 * @param cancel If you pass true, it will cancel the invokation
 */
function useScheduledInvoke(callback, delay, cancel = false) {
    useEffect(() => {
        // if set to cancel, then just don't do anything
        if (cancel) {
            return () => { };
        }
        // if delay is 0, then call it immediately
        if (delay === 0) {
            callback();
            return () => { };
        }
        // schedule it
        const timeoutId = setTimeout(callback, delay * 1000);
        return () => {
            clearTimeout(timeoutId);
        };
    }, [callback, delay, cancel]);
}
// Returning a new object reference guarantees that a before-and-after
//   equivalence check will always be false, resulting in a re-render, even
//   when multiple calls to forceUpdate are batched.
function useForceUpdate() {
    const [, dispatch] = useState$1(Object.create(null));
    // Turn dispatch(required_parameter) into dispatch().
    const memoizedDispatch = useCallback$1(() => {
        dispatch(Object.create(null));
    }, [dispatch]);
    return memoizedDispatch;
}

const submissionFormDataContext = createContext({
    name: undefined,
    elements: {},
    conditionals: [],
    pools: [],
    settings: {},
    structures: [],
    styles: {},
});
function useSubmissionFormData() {
    return useContext(submissionFormDataContext);
}
const submissionFormMetaContext = createContext({
    __typename: 'FormMetaType',
    elements: [],
});
function useSubmissionFormMeta() {
    return useContext(submissionFormMetaContext);
}
const submissionFormRenderModeContext = createContext('newsubmission');
function useSubmissionFormRenderMode() {
    return useContext(submissionFormRenderModeContext);
}
const submissionForceShowErrorsContext = createContext(false);
function useSubmissionForceShowErrors() {
    return useContext(submissionForceShowErrorsContext);
}
const activeErrorElementContext = createContext(null);
function useActiveErrorElement() {
    return useContext(activeErrorElementContext);
}
const formNavActionsContext = createContext({
    canNext: false,
    goNext: () => { },
    canPrevious: false,
    goPrevious: () => { },
    canSubmit: false,
    submit: () => { },
    canReset: false,
    reset: () => { },
    submitting: false,
    submitted: false,
    submittedState: 'success',
});
function useFormNavActions() {
    return useContext(formNavActionsContext);
}
const formElementConditionalMapContext = createContext({});
function useFormElementConditionalMap() {
    return useContext(formElementConditionalMapContext);
}

function create(createState) {
  let state;
  const listeners = new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (nextState !== state) {
      const previousState = state;
      state = replace ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribeWithSelector = (listener, selector = getState, equalityFn = Object.is) => {
    let currentSlice = selector(state);
    function listenerToAdd() {
      const nextSlice = selector(state);
      if (!equalityFn(currentSlice, nextSlice)) {
        const previousSlice = currentSlice;
        listener(currentSlice = nextSlice, previousSlice);
      }
    }
    listeners.add(listenerToAdd);
    return () => listeners.delete(listenerToAdd);
  };
  const subscribe = (listener, selector, equalityFn) => {
    if (selector || equalityFn) {
      return subscribeWithSelector(listener, selector, equalityFn);
    }
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => listeners.clear();
  const api = { setState, getState, subscribe, destroy };
  state = createState(setState, getState, api);
  return api;
}

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const redux = (reducer, initial) => (set, get, api) => {
  api.dispatch = (action) => {
    set((state) => reducer(state, action));
    if (api.devtools) {
      api.devtools.send(api.devtools.prefix + action.type, get());
    }
    return action;
  };
  return __spreadValues({ dispatch: api.dispatch }, initial);
};
const devtools = (fn, prefix) => (set, get, api) => {
  let extension;
  try {
    extension = window.__REDUX_DEVTOOLS_EXTENSION__ || window.top.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!extension) {
    api.devtools = null;
    return fn(set, get, api);
  }
  const namedSet = (state, replace, name) => {
    set(state, replace);
    if (!api.dispatch) {
      api.devtools.send(api.devtools.prefix + (name || "action"), get());
    }
  };
  const initialState = fn(namedSet, get, api);
  if (!api.devtools) {
    const savedSetState = api.setState;
    api.setState = (state, replace) => {
      savedSetState(state, replace);
      api.devtools.send(api.devtools.prefix + "setState", api.getState());
    };
    api.devtools = extension.connect({ name: prefix });
    api.devtools.prefix = prefix ? `${prefix} > ` : "";
    api.devtools.subscribe((message) => {
      var _a, _b, _c, _d;
      if (message.type === "DISPATCH" && message.state) {
        const ignoreState = message.payload.type === "JUMP_TO_ACTION" || message.payload.type === "JUMP_TO_STATE";
        if (!api.dispatch && !ignoreState) {
          api.setState(JSON.parse(message.state));
        } else {
          savedSetState(JSON.parse(message.state));
        }
      } else if (message.type === "DISPATCH" && ((_a = message.payload) == null ? void 0 : _a.type) === "COMMIT") {
        api.devtools.init(api.getState());
      } else if (message.type === "DISPATCH" && ((_b = message.payload) == null ? void 0 : _b.type) === "IMPORT_STATE") {
        const actions = (_c = message.payload.nextLiftedState) == null ? void 0 : _c.actionsById;
        const computedStates = ((_d = message.payload.nextLiftedState) == null ? void 0 : _d.computedStates) || [];
        computedStates.forEach(({ state }, index) => {
          const action = actions[index] || api.devtools.prefix + "setState";
          if (index === 0) {
            api.devtools.init(state);
          } else {
            savedSetState(state);
            api.devtools.send(action, api.getState());
          }
        });
      }
    });
    api.devtools.init(initialState);
  }
  return initialState;
};

function convertListToDictionary(items) {
    const dict = {};
    items.forEach(item => {
        dict[item.id] = item;
    });
    return dict;
}

/**
 * Recursively extract element's children from an element. The concept is that
 * one element can have any number of children, which in turn can have any
 * number of children. We keep on extracting unless we hit a spot where number
 * of elements of a child element is zero.
 *
 * It also takes into consideration that an element could be conditionally
 * hidden. If so, then that element and it's children are not included in the
 * result.
 *
 * Should call this within some action callback, like changing tabs or submitting
 * the form. Because this depends on the storeApi directly, it will break react
 * re-render.
 *
 * @param submissionElements Submission elements data from store api or other sources.
 * @param elements Elements from Form Data.
 * @param elementId Element Id from which we need to extract children.
 */
function recursivelyExtractConditionallyShownElementChildren(submissionElements, elements, elementId) {
    const children = [];
    const element = elements[elementId];
    const submissionData = submissionElements[elementId];
    // Now add this element and it's children, if this element is not
    // conditionally hidden.
    if (element &&
        element.children &&
        submissionData &&
        submissionData.conditionallyHidden === false) {
        children.push(elementId);
        element.children.forEach(childElementId => {
            children.push(...recursivelyExtractConditionallyShownElementChildren(submissionElements, elements, childElementId));
        });
    }
    return children;
}
/**
 * Get all (recursively) active children of a page. This takesn into
 * consideration, that an element might be conditionally hidden. If an element
 * is hidden, then neither that element, not it's children are included in the
 * result.
 *
 * Should call this within some action callback, like changing tabs or submitting
 * the form. Because this depends on the storeApi directly, it will break react
 * re-render.
 *
 * @param currentPage Current page data.
 * @param elements Elements from Form.
 * @param submissionElements Elements of Submissions.
 */
function getAllConditionallyShownChildrenOfCurrentPage(currentPage, elements, submissionElements) {
    const children = [];
    if (currentPage) {
        currentPage.children.forEach(elementId => {
            children.push(...recursivelyExtractConditionallyShownElementChildren(submissionElements, elements, elementId));
        });
    }
    return children;
}
/**
 * Recursively extract all children of an element. This does not consider
 * whether any element is conditionally hidden or not.
 *
 * @param elementId Id of the element whose child is to be extracted.
 * @param formData Form Data.
 */
function recursivelyGetChildrenOfElement(elementId, formData) {
    const children = [];
    const element = formData.elements[elementId];
    if (element && element.children && element.children.length) {
        // first push all the children of the element directly
        children.push(...element.children);
        // Now extract children's children
        element.children.forEach(childId => {
            children.push(...recursivelyGetChildrenOfElement(childId, formData));
        });
    }
    return children;
}
/**
 * Recursively get children of a page. It gets all the children and doesn't
 * consider whether they are conditionally hidden or not.
 *
 * @param pageId Page Id to get from structures.
 * @param formData Form Data as retrieved from GraphQL.
 */
function recursivelyGetChildrenOfPage(pageId, formData) {
    const children = [];
    const page = formData.structures.find(s => s.id === pageId);
    if (!page) {
        return children;
    }
    page.children.forEach(elementId => {
        children.push(elementId, ...recursivelyGetChildrenOfElement(elementId, formData));
    });
    return children;
}
/**
 * Check if elements are error free.
 *
 * @param storeElements Submission Elements from store API or other sources.
 * @param elementIds Ids of elements for which we check if those are error free.
 */
function areElementsErrorFree(storeElements, elementIds) {
    let errorFree = true;
    let firstErrorElement = null;
    for (let i = 0; i < elementIds.length; i++) {
        const currentElm = storeElements[elementIds[i]];
        if (currentElm && currentElm.errors.length !== 0) {
            firstErrorElement = elementIds[i];
            errorFree = false;
            break;
        }
    }
    return [errorFree, firstErrorElement];
}
function convertFormData(data) {
    const converted = {
        name: data.form.name ?? '',
        conditionals: omitDeep(data.form.conditionals ?? {}, '__typename'),
        elements: convertListToDictionary(omitDeep(data.form.elements, '__typename')),
        pools: omitDeep(data.form.pools ?? [], '__typename'),
        settings: omitDeep(data.form.settings ?? {}, '__typename'),
        structures: omitDeep(data.form.structures ?? [], '__typename'),
        styles: omitDeep(data.form.styles ?? {}, '__typename'),
    };
    return converted;
}
/**
 * Get element's default value and errors (based on element config).
 *
 * @param formMeta Form meta as obtained from GraphQL.
 * @param elementData Element data as obtained from Form GraphQL.
 * @param usePresetValue Whether or not to use preset value from config. Defaults false.
 */
function getElementDefaultValueAndErrors(formMeta, elementData, usePresetValue = false) {
    const elmMeta = formMeta.elements.find(el => el.type === elementData.type);
    // if element meta is not found, then it's an error from server
    if (!elmMeta) {
        throw new Error(`Could not find element type ${elementData.type} when creating default submission data value`);
    }
    let elmSubmissionDataValue = deepCopyWithJson(
    // omit the __typename, rest should match 1:1
    omitDeep(elmMeta.defaultDataValue, '__typename'));
    let errors = [];
    // we don't throw an error if hasItem returns false, because in case of
    // pro new elements would be added.
    if (wpEFormElementFrontCollection.hasItem(elementData.type)) {
        const elmFront = wpEFormElementFrontCollection.getItem(elementData.type);
        // if we are using preset value, then override
        if (usePresetValue && elmFront.getPresetValue) {
            elmSubmissionDataValue = elmFront.getPresetValue(elementData, elmSubmissionDataValue);
        }
        errors = elmFront.getErrors(elementData, elmSubmissionDataValue);
    }
    return {
        errors,
        value: elmSubmissionDataValue,
    };
}
/**
 * Get fresh set of structures data for submission after restoring them to the
 * initial values.
 *
 * @param formData Form Data as retrieved from GraphQL.
 * @returns structures to be used with form submission state.
 */
function getActiveStructuresAfterReset(formData) {
    const structures = {};
    formData.structures.forEach(st => {
        structures[st.id] = {
            id: st.id,
            conditionallyHidden: st.config.initiallyHidden ?? false,
            initiallyHidden: st.config.initiallyHidden ?? false,
        };
    });
    return structures;
}
/**
 * Get fresh set of elements for submission after restoring them to the
 * initial values. This only gives the active elements, i.e, elements from the
 * structures. It doesn't not give away the elements from the pools.
 *
 * @param formData Form Data as retrieved from GraphQL.
 * @param formMeta Form Meta as retrieved from GraphQL.
 * @param usePresetValue Whether or not to use preset value from config. Defaults false.
 */
function getActiveElementsAfterReset(formData, formMeta, usePresetValue = false, initialData) {
    const newElements = {};
    const activeElements = [];
    formData.structures.forEach(str => {
        activeElements.push(...recursivelyGetChildrenOfPage(str.id, formData));
    });
    activeElements.forEach(elmId => {
        const elementData = formData.elements[elmId];
        newElements[elmId] =
            initialData && initialData.elements[elmId]
                ? initialData.elements[elmId]
                : {
                    conditionallyHidden: elementData.appearance?.initiallyHidden || false,
                    id: elmId,
                    type: elementData.type,
                    touched: false,
                    ...getElementDefaultValueAndErrors(formMeta, elementData, usePresetValue),
                };
    });
    return newElements;
}
function useFormSubmissionSubmit(callback, formData, canSubmit) {
    const isMounted = useIsMounted();
    const [submitting, setSubmitting] = useState$1(false);
    const [submitted, setSubmitted] = useState$1(false);
    const [submittedState, setSubmittedState] = useState$1('success');
    const reset = useCallback$1(() => {
        setSubmitting(false);
        setSubmitted(false);
        setSubmittedState('success');
    }, []);
    const submit = useCallback$1((api) => {
        if (!canSubmit) {
            // eslint-disable-next-line no-alert
            alert(__('Cannot submit a form in preview mode.', 'wp-eform'));
            return;
        }
        setSubmitting(true);
        const elements = [];
        const currentState = api.getState();
        const { elements: submissionElements, startTime, structures: submissionStructures, } = currentState;
        // first take into account all the pages which are hidden
        const hiddenElementsDueToStructure = [];
        Object.keys(submissionStructures).forEach(sid => {
            const st = submissionStructures[sid];
            if (st && st.conditionallyHidden && formData) {
                // this page is hidden, so put all it's children inside the cache
                hiddenElementsDueToStructure.push(...recursivelyGetChildrenOfPage(sid, formData));
            }
        });
        Object.keys(submissionElements).forEach(eid => {
            // Add it to the list, if it has registry
            const submissionElement = submissionElements[eid];
            const elementType = submissionElement.type;
            if (wpEFormElementFrontCollection.hasItem(elementType)) {
                elements.push({
                    id: eid,
                    value: submissionElements[eid].value,
                    conditionallyHidden: hiddenElementsDueToStructure.includes(eid)
                        ? true
                        : submissionElements[eid].conditionallyHidden,
                });
            }
        });
        let duration = 0;
        {
            // FS:PREMIUM-ONLY-START
            if (fsIsPlanOrHigher('starter')) {
                duration = Math.abs(Math.ceil((Date.now() - startTime) / 1000));
            }
            // FS:PREMIUM-ONLY-END
        }
        callback(elements, duration, currentState.remarks)
            .then(response => {
            if (isMounted.current) {
                setSubmitted(true);
                if (response.errors?.length) {
                    setSubmittedState('error');
                }
                else {
                    setSubmittedState('success');
                }
            }
        })
            .catch((err) => {
            setSubmitted(true);
            setSubmittedState('networkerror');
        });
    }, [canSubmit, callback, isMounted, formData]);
    return {
        isMounted,
        submitting,
        submitted,
        submittedState,
        submit,
        reset,
    };
}
const defaultInitialSubmissionData = {
    currentPage: '',
    structures: {},
    elements: {},
    formId: 0,
    startTime: 0,
    remarks: '',
};

/**
 * Check if events of a logic are checked out.
 *
 * It takes into consideration that events are grouped against OR relation.
 *
 * @param events Logic events to check against.
 * @param elements Elements from current State.
 */
function areLogicEventsCheckedOut(events, elements, elementsData) {
    // First we loop through the events to figure out whether or not to
    // fire up the consequences
    const logicalORGroupedEvents = [];
    let lastRelation;
    events.forEach(event => {
        const eventElement = elements[event.fieldid];
        // bail early  if event element is nowhere to be found
        if (!eventElement) {
            return;
        }
        const elementData = elementsData[eventElement.id];
        if (!elementData) {
            return;
        }
        // get the definition to defer the conditional logic to element collection
        const eventElementType = eventElement.type;
        if (eventElementType &&
            wpEFormElementFrontCollection.hasItem(eventElementType)) {
            const eventElementDef = wpEFormElementFrontCollection.getItem(eventElementType);
            // If element doesn't have a isConditionTrue set, then assume it
            // is always false
            const isConditionTrue = eventElementDef.isConditionTrue
                ? eventElementDef.isConditionTrue(event.has, event.operation, event.operator, event.value || '', eventElement.value, elementData)
                : false;
            // depending on the last relation push or reduce the grouped event
            // results.
            if (lastRelation !== undefined) {
                if (lastRelation === EventRelationEnum.AND) {
                    const andReducedResult = logicalORGroupedEvents.pop() && isConditionTrue;
                    logicalORGroupedEvents.push(!!andReducedResult);
                }
                else {
                    logicalORGroupedEvents.push(isConditionTrue);
                }
            }
            else {
                logicalORGroupedEvents.push(isConditionTrue);
            }
            lastRelation = event.relation;
        }
    });
    // Finally determine if logic is checked out or not
    return logicalORGroupedEvents.some(v => v === true);
}
/**
 * Deeply reset an element's value and error. It also resets all its children.
 *
 * @param formMeta Form Meta as obtained from GraphQL.
 * @param formData Form Data.
 * @param elementId Element Id to reset (and it's children).
 * @param draftState draftState (immer produced) where we perform the operation.
 * @returns Affected elements.
 */
function deepResetElementValueAndError(formMeta, formData, elementId, draftState) {
    const elementData = formData.elements[elementId];
    const elementsToReset = [];
    if (elementData) {
        elementsToReset.push(elementId, ...recursivelyGetChildrenOfElement(elementId, formData));
    }
    if (elementsToReset.length) {
        elementsToReset.forEach(elmId => {
            const elData = formData.elements[elmId];
            const elSubmissionData = draftState.elements[elmId];
            if (elData && elSubmissionData) {
                const { errors, value } = getElementDefaultValueAndErrors(formMeta, elData);
                elSubmissionData.value = value;
                elSubmissionData.errors = errors;
                elSubmissionData.touched = false;
            }
        });
    }
    return elementsToReset;
}
/**
 * Deeply reset all elements inside a structure.
 *
 * @param formMeta Form Meta as obtained from GraphQL.
 * @param formData Form Data.
 * @param structureId Structure Id to reset (and it's children).
 * @param draftState draftState (immer produced) where we perform the operation.
 * @returns Affected elements.
 */
function deepResetStructureValueAndError(formMeta, formData, structureId, draftState) {
    const elementsAffected = [];
    const structureResult = findInArrayById(formData.structures, structureId);
    if (!structureResult) {
        return elementsAffected;
    }
    const structure = structureResult[0];
    structure.children.forEach(elementId => {
        elementsAffected.push(...deepResetElementValueAndError(formMeta, formData, elementId, draftState));
    });
    return elementsAffected;
}
/**
 * Get element title from form data.
 *
 * @param elmId Element Id.
 * @param formData Form Data
 * @returns Element Title.
 */
function getElementTitle(elmId, formData) {
    let elmName = 'unknown element';
    if (formData.elements[elmId]) {
        elmName = getStringValueFromJSON(formData.elements[elmId].appearance?.title ?? `element ${elmId}`);
    }
    return elmName;
}
/**
 * Get structure title.
 *
 * @param strId Structure Id.
 * @param formData Form data.
 * @returns Structure name.
 */
function getStructureTitle(strId, formData) {
    let strName = 'unknown page';
    const str = formData.structures.find(st => st.id === strId);
    if (str) {
        strName = getStringValueFromJSON(str.config.title ?? `page ${strId}`);
    }
    return strName;
}
/**
 * Determine and log invalid conditional operation on current page. An element
 * from current page cannot affect the current page.
 *
 * @param sid Structure Id.
 * @param draftState DraftState.
 * @param formData Form Data.
 * @param elementId Element for which we apply the logic.
 * @returns true if the operation is invalid, false if valid.
 */
function logInvalidConditionalOperationOnCurrentPage(sid, draftState, formData, elementId) {
    // try to get the parent of the element
    let parentPage = draftState.currentPage;
    formData.structures.forEach(st => {
        const children = recursivelyGetChildrenOfPage(st.id, formData);
        if (children.includes(elementId)) {
            parentPage = st.id;
        }
    });
    if (sid === parentPage) {
        logger.l(`%c ${getStructureTitle(sid, formData)} - ${getElementTitle(elementId, formData)} %c cannot operate conditionals on pages for current page.`, logger.style.error, logger.style.reset);
        return true;
    }
    return false;
}
/**
 * Conditionally show pages.
 *
 * @param pages Pages to show.
 * @param draftState Draft state.
 * @param formData Form Data.
 * @param startElementId Element for which we apply the logic.
 * @returns Affected elements.
 */
function conditionallyShowPages(pages, draftState, formData, startElementId) {
    const elementsAffected = [];
    pages?.forEach(sid => {
        if (logInvalidConditionalOperationOnCurrentPage(sid, draftState, formData, startElementId)) {
            return;
        }
        if (draftState.structures[sid]) {
            draftState.structures[sid].conditionallyHidden = false;
            elementsAffected.push(...recursivelyGetChildrenOfPage(sid, formData));
            // no need to reset shown pages elements, because those are affected
            // and will be reset anyway
        }
    });
    return elementsAffected;
}
/**
 * Conditionally hide pages.
 *
 * @param pages Pages to hide.
 * @param draftState Draft State.
 * @param formData Form Data.
 * @param formMeta Form meta.
 * @param startElementId Element for which we apply the logic.
 * @returns Affected elements.
 */
function conditionallyHidePages(pages, draftState, formData, formMeta, startElementId) {
    const elementsAffected = [];
    pages?.forEach(sid => {
        if (logInvalidConditionalOperationOnCurrentPage(sid, draftState, formData, startElementId)) {
            return;
        }
        if (draftState.structures[sid]) {
            draftState.structures[sid].conditionallyHidden = true;
            elementsAffected.push(...deepResetStructureValueAndError(formMeta, formData, sid, draftState));
        }
    });
    return elementsAffected;
}
/**
 * Conditionally reset pages to their initial state.
 *
 * @param pages Pages to reset.
 * @param draftState Draft state.
 * @param formData Form data.
 * @param formMeta Form metadata.
 * @param startElementId Element for which we apply the logic.
 * @returns Affected elements.
 */
function conditionallyResetPages(pages, draftState, formData, formMeta, startElementId) {
    const elementsAffected = [];
    pages?.forEach(sid => {
        if (logInvalidConditionalOperationOnCurrentPage(sid, draftState, formData, startElementId)) {
            return;
        }
        if (draftState.structures[sid]) {
            const initiallyHidden = draftState.structures[sid].initiallyHidden;
            draftState.structures[sid].conditionallyHidden = initiallyHidden;
            if (initiallyHidden) {
                // if we are hiding this page, then also reset values of all the elements inside it
                elementsAffected.push(...deepResetStructureValueAndError(formMeta, formData, sid, draftState));
            }
        }
    });
    return elementsAffected;
}
/**
 * Conditionally hides elements and reset their children's data.
 *
 * @param elements Elements to hide.
 * @param draftState Draft state.
 * @param formData Form data.
 * @param formMeta Form metadata.
 * @returns Affected elements.
 */
function conditionallyHideElements(elements, draftState, formData, formMeta) {
    const elementsAffected = [];
    // we set conditionally hidden only to the applied element
    // but we also reset the values of children
    elements?.forEach(id => {
        if (draftState.elements[id] &&
            draftState.elements[id].conditionallyHidden === false) {
            draftState.elements[id].conditionallyHidden = true;
            // reset its value and all its children.
            elementsAffected.push(...deepResetElementValueAndError(formMeta, formData, id, draftState));
        }
    });
    return elementsAffected;
}
/**
 * Restore element data to the preset value.
 *
 * @param formData Form Data.
 * @param id Id of the element.
 * @param formMeta Form Metadata.
 * @param draftState Draft state from immer.
 */
function restoreElementDataToPresetValue(formData, id, formMeta, draftState) {
    const elementData = formData.elements[id];
    const elementSubmissionData = draftState.elements[id];
    if (elementData && elementSubmissionData) {
        const defaultValueAndError = getElementDefaultValueAndErrors(formMeta, elementData, true);
        elementSubmissionData.value = defaultValueAndError.value;
        elementSubmissionData.errors = defaultValueAndError.errors;
    }
}
/**
 * Conditionally show elements.
 *
 * @param elements Elements to show.
 * @param draftState Draft State.
 * @returns Affected elements.
 */
function conditionallyShowElements(elements, draftState, formData, formMeta) {
    const elementsAffected = [];
    // we just remove the conditionallyHidden flags
    elements?.forEach(id => {
        if (draftState.elements[id]) {
            elementsAffected.push(id);
            const wasHidden = draftState.elements[id].conditionallyHidden;
            draftState.elements[id].conditionallyHidden = false;
            // if recovering from being hidden, then reset to preset value too
            if (wasHidden) {
                restoreElementDataToPresetValue(formData, id, formMeta, draftState);
            }
        }
    });
    return elementsAffected;
}
/**
 * Conditionally reset elements.
 *
 * @param elements Elements to reset.
 * @param draftState Draft State.
 * @param formData Form data.
 * @param formMeta Form meta.
 * @returns Affected elements.
 */
function conditionallyResetElements(elements, draftState, formData, formMeta) {
    const elementsAffected = [];
    elements?.forEach(id => {
        if (draftState.elements[id]) {
            const wasHidden = draftState.elements[id].conditionallyHidden;
            // restore to initial state
            const initialConditionallyHidden = formData.elements[id]?.appearance
                ?.initiallyHidden
                ? true
                : false;
            draftState.elements[id].conditionallyHidden = initialConditionallyHidden;
            if (initialConditionallyHidden === true) {
                // reset its value and all its children.
                deepResetElementValueAndError(formMeta, formData, id, draftState);
            }
            else {
                // if recovering from hidden
                // eslint-disable-next-line no-lonely-if
                if (wasHidden) {
                    restoreElementDataToPresetValue(formData, id, formMeta, draftState);
                }
            }
            elementsAffected.push(id);
        }
    });
    return elementsAffected;
}
/**
 * Apply the consequences of a logic depending on whether or not events are
 * checked out.
 *
 * @param logic The logic of the form.
 * @param areEventsCheckedOut Are events of the logic checked out.
 * @param draftState immer produced draft state where we operate.
 * @param formData Form data.
 * @param formMeta Form meta from GraphQL query.
 * @param startElementId Element for which we apply the logic.
 * @returns Affected elements.
 */
function applyLogicConsequences(logic, areEventsCheckedOut, draftState, formData, formMeta, startElementId) {
    const elementsAffected = [];
    // For the consequences, we always apply fields to show and hide
    // negating the effect if logic hasn't checked out
    logic.consequences.forEach(consequence => {
        if (consequence.action === ConsequenceActionEnum.HIDE_FIELDS) {
            // if we are to hide fields
            if (areEventsCheckedOut) {
                // hide them
                conditionallyHideElements(consequence.fieldsToHide, draftState, formData, formMeta);
            }
            else {
                // reset them
                conditionallyResetElements(consequence.fieldsToHide, draftState, formData, formMeta);
            }
            if (consequence.fieldsToHide) {
                elementsAffected.push(...consequence.fieldsToHide);
            }
        }
        else if (consequence.action === ConsequenceActionEnum.SHOW_FIELDS) {
            // if we are to show fields
            if (areEventsCheckedOut) {
                // show them
                conditionallyShowElements(consequence.fieldsToShow, draftState, formData, formMeta);
            }
            else {
                // reset them
                conditionallyResetElements(consequence.fieldsToShow, draftState, formData, formMeta);
            }
            if (consequence.fieldsToShow) {
                elementsAffected.push(...consequence.fieldsToShow);
            }
        }
        else if (consequence.action === ConsequenceActionEnum.SET_VALUE_OF &&
            areEventsCheckedOut) {
            if (consequence.fieldToSet) {
                const setValueElementSubmissionData = draftState.elements[consequence.fieldToSet];
                const setValueElementData = formData.elements[consequence.fieldToSet];
                if (setValueElementSubmissionData &&
                    wpEFormElementFrontCollection.hasItem(setValueElementSubmissionData.type)) {
                    const setValueElementDef = wpEFormElementFrontCollection.getItem(setValueElementSubmissionData.type);
                    setValueElementDef.setValue(consequence.value || '', setValueElementData, setValueElementSubmissionData.value);
                    elementsAffected.push(consequence.fieldToSet);
                }
            }
        }
        else if (consequence.action === ConsequenceActionEnum.SHOW_PAGES) {
            // if we are to show pages
            if (areEventsCheckedOut) {
                elementsAffected.push(...conditionallyShowPages(consequence.pagesToShow, draftState, formData, startElementId));
            }
            else {
                elementsAffected.push(...conditionallyResetPages(consequence.pagesToShow, draftState, formData, formMeta, startElementId));
            }
        }
        else if (consequence.action === ConsequenceActionEnum.HIDE_PAGES) {
            // if we are to hide pages
            if (areEventsCheckedOut) {
                elementsAffected.push(...conditionallyHidePages(consequence.pagesToHide, draftState, formData, formMeta, startElementId));
            }
            else {
                elementsAffected.push(...conditionallyResetPages(consequence.pagesToHide, draftState, formData, formMeta, startElementId));
            }
        }
    });
    return elementsAffected;
}
/**
 * Apply conditionals related to an element and mutate state accordingly.
 * This does not cascade and is only executed once even if it changes values.
 *
 * @param draftState Immer produced draftState where we operate.
 * @param elementId Id of the element for which we apply the logic.
 * @param conditionalsMap Shortcut map of conditionals.
 * @param formData Form data.
 * @param formMeta Form meta.
 * @param maxDepth Maximum depth upto which it will check.
 */
function applyConditionals(draftState, elementId, conditionalsMap, formData, formMeta, maxDepth = 50, startElement = null) {
    const { conditionals } = formData;
    // if the element is a part of any condition
    if (conditionalsMap[elementId] && conditionalsMap[elementId].length) {
        // loop through it and apply conditionals
        conditionalsMap[elementId].forEach(condId => {
            const logic = conditionals.find(c => c.id === condId);
            // proceed if logic is there
            if (logic) {
                // First figure out if logic is checked out
                const areEventsCheckedOut = areLogicEventsCheckedOut(logic.events, draftState.elements, formData.elements);
                // Now apply the consequences
                const affectedElements = applyLogicConsequences(logic, areEventsCheckedOut, draftState, formData, formMeta, startElement ?? elementId);
                // depending on maxDepth, check for nested logics
                if (affectedElements.length && maxDepth > 0) {
                    affectedElements.forEach(eid => {
                        applyConditionals(draftState, eid, conditionalsMap, formData, formMeta, maxDepth - 1, startElement ?? elementId);
                    });
                }
                else if (maxDepth === 0) {
                    const elmName = getElementTitle(startElement ?? elementId, formData);
                    logger.l(`%c ${elmName} %c has too many deeply nested or dependent logics. Kindly try to fix it.`, logger.style.error, logger.style.reset);
                }
                // That's it
            }
        });
    }
}
/**
 * Refresh conditional state of all elements based on current draftState.
 *
 * @param draftState Immer produced draftState where we operate.
 * @param conditionalsMap Shortcut map of conditionals.
 * @param formData Form data.
 * @param formMeta Form meta.
 */
function refreshAllConditionals(draftState, conditionalsMap, formData, formMeta) {
    const { elements } = formData;
    Object.keys(elements).forEach(elementId => {
        applyConditionals(draftState, elementId, conditionalsMap, formData, formMeta);
    });
}

function syncElements(draftState, newElements, fullReset) {
    // get a copy of old draftState elements
    const existingDraftElements = draftState.elements;
    // now start from scratch with the draft elements
    draftState.elements = {};
    Object.keys(newElements).forEach(elmId => {
        if (fullReset) {
            // while doing full reset, just don't consider the existing one
            draftState.elements[elmId] = deepCopyWithJson(newElements[elmId]);
        }
        else {
            // add new element to the state if not present
            // eslint-disable-next-line no-lonely-if
            if (!existingDraftElements[elmId]) {
                draftState.elements[elmId] = deepCopyWithJson(newElements[elmId]);
            }
            else {
                // use the existing one
                draftState.elements[elmId] = existingDraftElements[elmId];
            }
        }
    });
}
function submissionReducer(state, action) {
    // we don't do auto-freeze in this reducer because of nested updates
    // setAutoFreeze(false);
    const newValue = fn(state, draftState => {
        if (action.type === 'SET_DATA') {
            draftState.currentPage = action.payload.currentPage;
            draftState.elements = action.payload.elements;
            draftState.formId = action.payload.formId;
            draftState.startTime = action.payload.startTime;
        }
        else if (action.type === 'SET_ELEMENTS_AND_STARTTIME') {
            const { conditionalsMap, elements, formData, formMeta, startTime, structures, fullReset, } = action.payload;
            syncElements(draftState, elements, fullReset);
            draftState.startTime = startTime ?? Date.now();
            draftState.structures = structures;
            draftState.lastTouchedElement = undefined;
            // refresh all conditionals
            refreshAllConditionals(draftState, conditionalsMap, formData, formMeta);
        }
        else if (action.type === 'SET_CURRENT_PAGE') {
            draftState.currentPage = action.payload;
            draftState.lastTouchedElement = undefined;
        }
        else if (action.type === 'SET_ELEMENT_DATA') {
            const { formData, conditionalsMap, elementId, elementSubmissionData, formMeta, } = action.payload;
            // In many elements, we are using immer to create the new submission data
            // in the UI. This new submission data will actually be frozen and because
            // of that, during nested conditional calls, when we try to update this
            // again, it will cause errors.
            // easy and fast way to avoid it is, just create a deep copy of it.
            draftState.elements[elementId] = deepCopyWithJson(elementSubmissionData);
            // here also do the conditional logic
            applyConditionals(draftState, elementId, conditionalsMap, formData, formMeta);
        }
        else if (action.type === 'SET_ELEMENT_TOUCHED') {
            if (draftState.elements[action.payload.elmId]) {
                draftState.elements[action.payload.elmId].touched =
                    action.payload.touched;
                draftState.lastTouchedElement = action.payload.elmId;
            }
        }
        else if (action.type === 'SET_REMARKS') {
            draftState.remarks = action.payload.remarks;
        }
        else {
            throw new Error(
            // @ts-ignore
            `ERROR: Form submission reducer does not understand the action.type ${action.type}`);
        }
    });
    return newValue;
}

// In form builder, we have used a singleton store for managing form state.
// This has worked for the form builder because there will always be one single
// form builder anywhere in the page.
// BUT for forms themselves, we need store localized to the root component.
// There could be any number of forms in a page and we wouldn't want to leak
// or override by using one single store.
// https://github.com/pmndrs/zustand/issues/128#issuecomment-673398578
const storeContext = createContext((() => {
    throw new Error('Must be called from a StoreProvider');
}));
/**
 * A localized submission store selector to access the store from closest
 * SubmissionStore and call it with the selector.
 *
 * @param selector Selector function for zustand store.
 */
function useSubmissionStore(selector) {
    const [useStore] = useContext(storeContext);
    return useStore(selector);
}
function useSubmissionDispatch() {
    const [useStore] = useContext(storeContext);
    return useStore(s => s.dispatch);
}
function useSubmissionStoreApi() {
    const [, api] = useContext(storeContext);
    return api;
}
// Selectors
function submissionStoreElementsSelector(s) {
    return s.elements;
}
function submissionStoreStartTimeSelector(s) {
    return s.startTime;
}
function submissionStoreCurrentPageSelector(s) {
    return s.currentPage;
}
function submissionStoreRemarksSelector(s) {
    return s.remarks;
}
function submissionStoreStructuresSelector(s) {
    return s.structures;
}
function submissionStoreLastTouchedElementIdSelector(s) {
    return s.lastTouchedElement;
}
/**
 * Submission Store component to take zustand store into a component life-cycle
 * instead of a singleton.
 *
 * We use class because we want this to be Fast Refresh compatible.
 */
class SubmissionStore extends React__default.Component {
    constructor(...args) {
        // @ts-ignore
        super(...args);
        const { initialData } = this.props;
        const { formId } = initialData;
        const submissionStoreApi = create(devtools(redux(submissionReducer, initialData), `WPEFormSubmission-${formId}`));
        const hook = createHook(submissionStoreApi);
        this.state = {
            storeContextValue: [hook, submissionStoreApi],
        };
    }
    render() {
        const { children } = this.props;
        return (jsx(storeContext.Provider, Object.assign({ value: this.state.storeContextValue }, { children: children }), void 0));
    }
}

function Element$1(props) {
    const { elmId, overrideRender, presentation = 'regular' } = props;
    // have this component react to hot updates of WPEFo
    const forceUpdate = useForceUpdate();
    useEffect(() => {
        const id = wpEFormElementFrontCollection.subscribeToChanges(forceUpdate);
        return () => {
            wpEFormElementFrontCollection.unsubscribeFromChanges(id);
        };
    }, [forceUpdate]);
    let hasGutter = props.hasGutter ?? true;
    const formData = useSubmissionFormData();
    const formMeta = useSubmissionFormMeta();
    const elementData = formData.elements[elmId];
    const elementType = elementData.type;
    const submissionData = useSubmissionStore(useCallback$1((s) => s.elements[elmId], [elmId]));
    const conditionalsMap = useFormElementConditionalMap();
    const uniqId = useQuestionId();
    const forceShowError = useSubmissionForceShowErrors();
    const dispatch = useSubmissionDispatch();
    const updateSubmissionData = useCallback$1(newSubmissionData => {
        // check to make sure the element type is present.
        if (!wpEFormElementFrontCollection.hasItem(elementType)) {
            return;
        }
        const elementFront = wpEFormElementFrontCollection.getItem(elementType);
        dispatch({
            type: 'SET_ELEMENT_DATA',
            payload: {
                elementId: elmId,
                elementSubmissionData: {
                    ...newSubmissionData,
                    errors: elementFront.getErrors(elementData, newSubmissionData.value),
                    // we dont change touched here
                    // it must be set explicitly by the caller for better UX
                },
                conditionalsMap,
                formData,
                formMeta,
            },
        });
    }, [
        elementType,
        dispatch,
        elmId,
        elementData,
        conditionalsMap,
        formData,
        formMeta,
    ]);
    const setElementTouched = useCallback$1((touched = true) => {
        dispatch({
            type: 'SET_ELEMENT_TOUCHED',
            payload: {
                elmId,
                touched,
            },
        });
    }, [elmId, dispatch]);
    const titleNodes = useNodesFromJson(elementData.appearance?.title);
    const subtitleNodes = useNodesFromJson(elementData.appearance?.subtitle);
    const descriptionNodes = useNodesFromJson(elementData.appearance?.description);
    const hintNodes = useNodesFromJson(elementData.appearance?.hint);
    // scroll if this element is actively errored out
    const activeErrorElement = useActiveErrorElement();
    const containerRef = useRef(null);
    useLayoutEffect$1(() => {
        if (activeErrorElement === elmId && containerRef.current) {
            const containerElement = containerRef.current;
            _default(containerElement, {
                verticalOffset: formData.styles?.pagination?.scrollOffset !== undefined
                    ? formData.styles.pagination.scrollOffset * -1
                    : -100,
                cancelOnUserAction: true,
                elementToScroll: scrollParents(containerRef.current)[0],
            }).then(() => {
                containerElement?.focus();
            });
        }
    }, [activeErrorElement, elmId, formData.styles?.pagination?.scrollOffset]);
    const errorsToShow = useMemo(() => {
        return submissionData
            ? submissionData.conditionallyHidden === false &&
                (submissionData.touched || forceShowError)
                ? submissionData.errors
                : []
            : [];
    }, [submissionData, forceShowError]);
    // check render mode
    const mode = useSubmissionFormRenderMode();
    if (!elementData) {
        return (jsx("p", { children: sprintf(__('ERROR: The element with id %s does not exist', 'wp-eform'), elmId) }, void 0));
    }
    if (!submissionData) {
        return null;
    }
    let children = null;
    const elementTitle = titleNodes ? (jsx(SlateViewWithData, { nodes: titleNodes, currentElementId: elementData.id }, void 0)) : null;
    let isQuestionRequired = false;
    if (wpEFormElementFrontCollection.hasItem(elementType)) {
        const elementFront = wpEFormElementFrontCollection.getItem(elementType);
        isQuestionRequired = elementFront.isRequired(elementData);
        hasGutter = elementFront.noGutter === true ? false : hasGutter;
        const finalLayout = elementData.appearance?.overrideControlAppearance
            ? elementData.appearance.controlLayout
            : formData.styles?.appearance?.controlLayout ??
                SettingsAppearanceControlLayoutEnum.VERTICAL;
        const finalType = elementData.appearance?.overrideControlAppearance
            ? elementData.appearance.controlType
            : formData.styles?.appearance?.controlType ??
                SettingsAppearanceControlTypeEnum.BOXY;
        const finalAlignment = elementData.appearance?.overrideControlAppearance
            ? elementData.appearance.controlAlignment
            : formData.styles?.appearance?.controlAlignment ??
                SettingsAppearanceControlAlignmentEnum.LEFT;
        const isAvailableInCurrentPlan = fsIsPlanOrHigher(elementFront.neededPlan);
        const elmNode = isAvailableInCurrentPlan ? (jsx(elementFront.FormUi, { elmId: elmId, id: uniqId, elementData: elementData, elementTitle: elementTitle, controlType: finalType, controlLayout: finalLayout, controlAlignment: finalAlignment, hasError: !!errorsToShow.length, submissionData: submissionData, updateSubmissionData: updateSubmissionData, setElementTouched: setElementTouched, presentation: presentation }, void 0)) : (jsx(Alert, Object.assign({ dismissable: false, title: __('This element is no longer accessible.', 'wp-eform'), type: "error" }, { children: jsx("p", { children: sprintf(__('You do not have an active license for the %1$s plan. Once the license is active, this element will show up again.', 'wp-eform'), planAccessor[elementFront.neededPlan ?? 'starter']) }, void 0) }), void 0));
        if (elementFront.isQuestion) {
            children = (jsx(Question, Object.assign({ title: elementFront.isQuestionTitleHidden || overrideRender
                    ? undefined
                    : elementTitle, subtitle: subtitleNodes && !overrideRender ? (jsx(SlateViewWithData, { nodes: subtitleNodes, currentElementId: elementData.id }, void 0)) : undefined, description: descriptionNodes ? (jsx(SlateViewWithData, { currentElementId: elementData.id, nodes: descriptionNodes, mode: "multiline" }, void 0)) : undefined, hintLabel: elementData.appearance?.hintLabel || 'Show Hint', hintIcon: elementData.appearance?.hintIcon || undefined, hintMessage: hintNodes ? (jsx(SlateViewWithData, { mode: "multiline", nodes: hintNodes, currentElementId: elementData.id }, void 0)) : undefined, alignment: finalAlignment, layout: finalLayout, asterisk: isQuestionRequired, id: uniqId, className: elementData.appearance?.className, errors: errorsToShow }, { children: elmNode }), void 0));
        }
        else {
            children = elmNode;
        }
    }
    else {
        children = (jsxs("div", { children: ["Element with Id ", elmId, " and type ", elementData.type, " does not have an UI."] }, void 0));
    }
    const tabIndex = activeErrorElement === elmId && submissionData.errors.length >= 1
        ? 0
        : undefined;
    if (overrideRender) {
        children = overrideRender(elementTitle, children, isQuestionRequired, {
            ref: containerRef,
            tabIndex,
        });
    }
    const childrenToRender = (jsx(AppErrorBoundary, Object.assign({ fallback: (resetError, lastError) => (jsx(Alert, Object.assign({ title: jsxs(Fragment, { children: [jsx("strong", { children: __('ERROR: ', 'wp-eform') }, void 0), elementTitle] }, void 0), type: "warn", onDismiss: resetError, dismissable: true }, { children: lastError && lastError.message
                ? lastError.message
                : __('You can try and dismiss this to see if it works.', 'wp-eform') }), void 0)) }, { children: jsx(AnimatedConditional, Object.assign({ visible: !submissionData.conditionallyHidden, mode: mode !== 'preview' ? 'live' : 'preview' }, { children: jsx(AnimateIn, Object.assign({ mode: mode !== 'preview' ? 'live' : 'preview' }, { children: hasGutter && !overrideRender ? (jsx(Grid.Gutter, { children: children }, void 0)) : (children) }), void 0) }), void 0) }), void 0));
    return overrideRender ? (childrenToRender) : (jsx(Grid.Item, Object.assign({ columnSize: elementData.appearance?.columnSize ?? WidthPresetsEnum.FULL, basicWidth: elementData.appearance?.basicWidth || '100%', widths: elementData.appearance?.widths || [], ref: containerRef, tabIndex: tabIndex }, { children: childrenToRender }), void 0));
}
const MemoizedElement = React__default.memo(Element$1);
MemoizedElement.displayName = 'withMemo(Element)';

function GridElements(props) {
    const { elements, emptyMessage } = props;
    return (jsx(Grid, { children: elements.length ? (elements.map(elmId => jsx(MemoizedElement, { elmId: elmId }, elmId))) : (jsx(Grid.Item, Object.assign({ columnSize: WidthPresetsEnum.FULL, basicWidth: "100%", widths: [] }, { children: jsx(IconMessage, Object.assign({ icon: jsx(Icon, { iconClass: "fas fa-envelope-open" }, void 0) }, { children: emptyMessage }), void 0) }), void 0)) }, void 0));
}

const CONTROLCLASS$c = 'wpeform-component-group';
const CONTAINERCLASS = getBemElement(CONTROLCLASS$c, 'body');
const dividerCss = css `
	content: '';
	display: block;
	width: 50px;
	height: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	background-color: ${props => props.theme.borderColorSplit};
	position: absolute;
`;
const GroupHeading = styled.h3 `
	padding: 0 ${props => numToCssSize(props.theme.gutter * 0.75 * 2)}
		${props => numToCssSize(props.theme.gutter * 0.25)};
	${props => numToCssSize(props.theme.gutter * 0.75 * 2)};
	margin: 0;
	color: ${props => props.theme.headingColor};
	font-size: ${props => numToCssSize(props.theme.fz.large1)};
	font-weight: ${props => (props.theme.boldHeading ? 'bold' : 'normal')};
	&:empty {
		display: none;
	}
	position: relative;
	&::after {
		${dividerCss};
		bottom: ${props => numToCssSize(props.theme.borderRadiusBase * -1)};
		left: ${props => numToCssSize(props.theme.gutter * 0.75 * 2)};
	}
`;
const GroupContent = styled.div `
	&.${CONTAINERCLASS}--has-title {
		position: relative;
		&::after {
			${dividerCss};
			bottom: ${props => numToCssSize(props.theme.borderRadiusBase * -1)};
			left: ${props => numToCssSize(props.theme.gutter * 0.75 * 2)};
		}
	}
`;
const GroupContainer = styled.div `
	${cssReset};
	&.${CONTROLCLASS$c}--align-RIGHT {
		${GroupContent}::after,
		${GroupHeading}::after {
			left: auto;
			right: ${props => numToCssSize(props.theme.gutter * 0.75 * 2)};
		}
		${GroupHeading} {
			text-align: right;
		}
	}
	&.${CONTROLCLASS$c}--align-CENTER {
		${GroupContent}::after,
		${GroupHeading}::after {
			left: 50%;
			transform: translateX(-50%);
		}
		${GroupHeading} {
			text-align: center;
		}
	}
`;
const group = {
    id: 'group',
    hasSubmission: false,
    FormUi({ elementTitle, elementData, controlAlignment }) {
        return (jsx(Grid.NegateGutter, Object.assign({ vertical: !elementTitle }, { children: jsxs(GroupContainer, Object.assign({ className: getBemClassName(CONTROLCLASS$c, {
                    'has-title': !!elementTitle,
                    [`align-${controlAlignment}`]: true,
                }, elementData.appearance?.className) }, { children: [elementTitle ? jsx(GroupHeading, { children: elementTitle }, void 0) : null, jsx(GroupContent, Object.assign({ className: getBemClassName(CONTAINERCLASS, {
                            'has-title': !!elementTitle,
                        }) }, { children: jsx(GridElements, { emptyMessage: __('This group element is empty', 'wp-eform'), elements: elementData.children }, void 0) }), void 0)] }), void 0) }), void 0));
    },
    getErrors() {
        // a group has no errors
        return [];
    },
    isQuestion: false,
    isRequired() {
        // a group is never required
        return false;
    },
    setValue() { },
};

function _extends$2() {
  _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$2.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var index$1 = typeof document !== 'undefined' ? useLayoutEffect$1 : useEffect;

var useLatest = function useLatest(value) {
  var ref = useRef(value);
  index$1(function () {
    ref.current = value;
  });
  return ref;
};

var updateRef = function updateRef(ref, value) {
  if (typeof ref === 'function') {
    ref(value);
    return;
  }
  ref.current = value;
};

var useComposedRef = function useComposedRef(libRef, userRef) {
  var prevUserRef = useRef();
  return useCallback$1(function (instance) {
    libRef.current = instance;

    if (prevUserRef.current) {
      updateRef(prevUserRef.current, null);
    }

    prevUserRef.current = userRef;

    if (!userRef) {
      return;
    }

    updateRef(userRef, instance);
  }, [userRef]);
};

var HIDDEN_TEXTAREA_STYLE = {
  'min-height': '0',
  'max-height': 'none',
  height: '0',
  visibility: 'hidden',
  overflow: 'hidden',
  position: 'absolute',
  'z-index': '-1000',
  top: '0',
  right: '0'
};

var forceHiddenStyles = function forceHiddenStyles(node) {
  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function (key) {
    node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], 'important');
  });
};

//   export type CalculatedNodeHeights = [height: number, rowHeight: number];
// https://github.com/microsoft/TypeScript/issues/28259

var hiddenTextarea = null;

var getHeight = function getHeight(node, sizingData) {
  var height = node.scrollHeight;

  if (sizingData.sizingStyle.boxSizing === 'border-box') {
    // border-box: add border, since height = content + padding + border
    return height + sizingData.borderSize;
  } // remove padding, since height = content


  return height - sizingData.paddingSize;
};

function calculateNodeHeight(sizingData, value, minRows, maxRows) {
  if (minRows === void 0) {
    minRows = 1;
  }

  if (maxRows === void 0) {
    maxRows = Infinity;
  }

  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    hiddenTextarea.setAttribute('tabindex', '-1');
    hiddenTextarea.setAttribute('aria-hidden', 'true');
    forceHiddenStyles(hiddenTextarea);
  }

  if (hiddenTextarea.parentNode === null) {
    document.body.appendChild(hiddenTextarea);
  }

  var paddingSize = sizingData.paddingSize,
      borderSize = sizingData.borderSize,
      sizingStyle = sizingData.sizingStyle;
  var boxSizing = sizingStyle.boxSizing;
  Object.keys(sizingStyle).forEach(function (_key) {
    var key = _key;
    hiddenTextarea.style[key] = sizingStyle[key];
  });
  forceHiddenStyles(hiddenTextarea);
  hiddenTextarea.value = value;
  var height = getHeight(hiddenTextarea, sizingData); // measure height of a textarea with a single row

  hiddenTextarea.value = 'x';
  var rowHeight = hiddenTextarea.scrollHeight - paddingSize;
  var minHeight = rowHeight * minRows;

  if (boxSizing === 'border-box') {
    minHeight = minHeight + paddingSize + borderSize;
  }

  height = Math.max(minHeight, height);
  var maxHeight = rowHeight * maxRows;

  if (boxSizing === 'border-box') {
    maxHeight = maxHeight + paddingSize + borderSize;
  }

  height = Math.min(maxHeight, height);
  return [height, rowHeight];
}

var noop = function noop() {};
var pick = function pick(props, obj) {
  return props.reduce(function (acc, prop) {
    acc[prop] = obj[prop];
    return acc;
  }, {});
};

var SIZING_STYLE = ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'boxSizing', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'lineHeight', 'paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop', // non-standard
'tabSize', 'textIndent', // non-standard
'textRendering', 'textTransform', 'width', 'wordBreak'];
var isIE = typeof document !== 'undefined' ? !!document.documentElement.currentStyle : false;

var getSizingData = function getSizingData(node) {
  var style = window.getComputedStyle(node);

  if (style === null) {
    return null;
  }

  var sizingStyle = pick(SIZING_STYLE, style);
  var boxSizing = sizingStyle.boxSizing; // probably node is detached from DOM, can't read computed dimensions

  if (boxSizing === '') {
    return null;
  } // IE (Edge has already correct behaviour) returns content width as computed width
  // so we need to add manually padding and border widths


  if (isIE && boxSizing === 'border-box') {
    sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(sizingStyle.borderRightWidth) + parseFloat(sizingStyle.borderLeftWidth) + parseFloat(sizingStyle.paddingRight) + parseFloat(sizingStyle.paddingLeft) + 'px';
  }

  var paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop);
  var borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);
  return {
    sizingStyle: sizingStyle,
    paddingSize: paddingSize,
    borderSize: borderSize
  };
};

var useWindowResizeListener = function useWindowResizeListener(listener) {
  var latestListener = useLatest(listener);
  useLayoutEffect$1(function () {
    var handler = function handler(event) {
      latestListener.current(event);
    };

    window.addEventListener('resize', handler);
    return function () {
      window.removeEventListener('resize', handler);
    };
  }, []);
};

var TextareaAutosize = function TextareaAutosize(_ref, userRef) {
  var cacheMeasurements = _ref.cacheMeasurements,
      maxRows = _ref.maxRows,
      minRows = _ref.minRows,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? noop : _ref$onChange,
      _ref$onHeightChange = _ref.onHeightChange,
      onHeightChange = _ref$onHeightChange === void 0 ? noop : _ref$onHeightChange,
      props = _objectWithoutPropertiesLoose(_ref, ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"]);

  var isControlled = props.value !== undefined;
  var libRef = useRef(null);
  var ref = useComposedRef(libRef, userRef);
  var heightRef = useRef(0);
  var measurementsCacheRef = useRef();

  var resizeTextarea = function resizeTextarea() {
    var node = libRef.current;
    var nodeSizingData = cacheMeasurements && measurementsCacheRef.current ? measurementsCacheRef.current : getSizingData(node);

    if (!nodeSizingData) {
      return;
    }

    measurementsCacheRef.current = nodeSizingData;

    var _calculateNodeHeight = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || 'x', minRows, maxRows),
        height = _calculateNodeHeight[0],
        rowHeight = _calculateNodeHeight[1];

    if (heightRef.current !== height) {
      heightRef.current = height;
      node.style.setProperty('height', height + "px", 'important');
      onHeightChange(height, {
        rowHeight: rowHeight
      });
    }
  };

  var handleChange = function handleChange(event) {
    if (!isControlled) {
      resizeTextarea();
    }

    onChange(event);
  };

  if (typeof document !== 'undefined') {
    useLayoutEffect$1(resizeTextarea);
    useWindowResizeListener(resizeTextarea);
  }

  return /*#__PURE__*/createElement("textarea", _extends$2({}, props, {
    onChange: handleChange,
    ref: ref
  }));
};

var index = /* #__PURE__ */forwardRef(TextareaAutosize);

var TextareaAutosize$1 = index;

const CONTROLCLASS$b = 'wpeform-control-textarea';
const MaterialBorder = styled.div `
	position: absolute;
	height: 2px;
	bottom: 0;
	left: 0;
	right: 0;
	transform-origin: 50% 50%;
	background-color: ${props => props.theme.primaryColor};
	pointer-events: none;
	transform: scaleX(0);
	transition: ${props => getMultipleTransitionsWithWillChange(['transform'], props.theme.transitionBeizer)};
`;
const StyledTextarea = styled(TextareaAutosize$1) `
	${cssReset};
	appearance: none;
	overflow: auto;
	vertical-align: top;
	resize: vertical;
	display: block;
	width: 100%;
	height: ${props => numToCssSize(props.theme.controlHeightBase)};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	box-shadow: 0 0 0 0 transparent;
	color: ${props => props.theme.textColor};
	padding: ${props => numToCssSize(props.theme.controlHeightBase / 4)};
	border: 1px solid ${props => props.theme.borderColorBase};
	background-color: ${props => props.theme.appBackgroundColor};
	box-shadow: ${props => props.theme.boxShadowNoneFocus};
	transition: ${props => getMultipleTransitionsWithWillChange(['border-color', 'box-shadow'], props.theme.transitionControl)};

	&:hover {
		color: ${props => props.theme.textColor};
		border-color: ${props => props.theme.primaryColor};
	}

	&:active,
	&:focus {
		color: ${props => props.theme.textColor};
		border-color: ${props => props.theme.primaryColor};
		box-shadow: ${props => props.theme.boxShadowControlFocus};
	}

	&::placeholder {
		color: ${props => props.theme.textColorSecondary};
	}

	&.${CONTROLCLASS$b}__textarea--has-error {
		border-color: ${props => props.theme.borderColorError};

		&:hover {
			border-color: ${props => props.theme.borderColorError};
		}

		&:active,
		&:focus {
			border-color: ${props => props.theme.borderColorError};
			box-shadow: ${props => props.theme.boxShadowControlFocusError};
		}
	}

	&:disabled {
		background-color: ${props => props.theme.disabledBackgroundColor};
		color: ${props => props.theme.disabledColor};
		border-color: ${props => props.theme.disabledColor};
		cursor: not-allowed;
		box-shadow: none;
	}

	&:read-only {
		background-color: ${props => props.theme.disabledBackgroundColor};
		border-color: ${props => props.theme.disabledColor};
		box-shadow: none;
	}

	&.${CONTROLCLASS$b}__textarea--type-MATERIAL {
		border: 0 none;
		border-bottom: 2px solid ${props => props.theme.borderColorBase};
		border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)}
			${props => numToCssSize(props.theme.borderRadiusBase)} 0 0;
		box-shadow: none;
		background-color: ${props => props.theme.backgroundControl};
		transition: ${props => getMultipleTransitionsWithWillChange(['background-color'], props.theme.transitionControl)};

		&:hover {
			border-color: ${props => props.theme.borderColorBase};
		}

		&:active,
		&:focus {
			background-color: ${props => curriedTransparentize(0.5, props.theme.backgroundControl)};
			border-color: ${props => props.theme.borderColorBase};
			box-shadow: none;
		}

		&:hover
			+ ${MaterialBorder},
			&:active
			+ ${MaterialBorder},
			&:focus
			+ ${MaterialBorder} {
			transform: scaleX(1);
		}

		&.${CONTROLCLASS$b}__textarea--has-error {
			border-bottom-color: ${props => props.theme.borderColorError};

			&:hover {
				border-bottom-color: ${props => props.theme.borderColorError};
			}

			&:active,
			&:focus {
				border-bottom-color: ${props => props.theme.borderColorError};
			}

			+ ${MaterialBorder} {
				background-color: ${props => props.theme.borderColorError};
			}
		}

		&:disabled {
			background-color: ${props => props.theme.disabledBackgroundColor};
			color: ${props => props.theme.disabledColor};
			border-color: ${props => props.theme.disabledColor};
			cursor: not-allowed;
			+ ${MaterialBorder} {
				transform: scaleX(0);
				background-color: ${props => props.theme.disabledColor};
			}
		}

		&:read-only {
			background-color: ${props => props.theme.disabledBackgroundColor};
			border-color: ${props => props.theme.disabledColor};
			+ ${MaterialBorder} {
				transform: scaleX(0);
				background-color: ${props => props.theme.disabledColor};
			}
		}
	}
`;
const Placeholder = styled.div `
	position: absolute;
	display: flex;
	align-items: center;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
	height: ${props => numToCssSize(props.theme.controlHeightBase / 2)};
	/** So that we can click through it to the textarea */
	pointer-events: none;
	font-size: ${props => numToCssSize(props.theme.fz.base)};

	color: ${props => props.theme.textColorSecondary};
	transition: ${props => getMultipleTransitionsWithWillChange(['top', 'left', 'font-size'], props.theme.transitionControl)};

	> * {
		margin: 0;
		padding: 0;
		max-width: 100%;
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
`;
const Prefix = styled.div `
	position: absolute;
	top: ${props => numToCssSize(props.theme.controlHeightBase / 4 + props.theme.fz.base * 0.25)};
	padding: 0;
	left: ${props => numToCssSize(props.theme.controlHeightBase / 4)};
	bottom: 0;
	display: flex;
	align-items: flex-start;
	justify-content: center;
	/** So that we can click through it to the textarea */
	pointer-events: none;
	color: ${props => props.theme.greyLightColor};
`;
const Container$3 = styled.div `
	${cssReset};
	position: relative;
	padding: 0;

	/** Position the default placeholder */
	${Placeholder} {
		top: ${props => numToCssSize(props.theme.controlHeightBase / 4 + props.theme.fz.base * 0.15)};
		left: ${props => numToCssSize(props.theme.controlHeightBase / 4)};
		right: ${props => numToCssSize(props.theme.controlHeightBase / 4)};
	}
	&.${CONTROLCLASS$b}--align-LEFT {
		${Placeholder} {
			text-align: left;
			justify-content: flex-start;
		}
	}
	&.${CONTROLCLASS$b}--align-CENTER {
		${Placeholder} {
			text-align: center;
			justify-content: center;
		}
	}
	&.${CONTROLCLASS$b}--align-RIGHT {
		${Placeholder} {
			text-align: right;
			justify-content: flex-end;
		}
	}

	&.${CONTROLCLASS$b}--has-prefix {
		${StyledTextarea} {
			/** [gutter + prefix + gutter] where gutter is controlHeightBase / 4 & prefix is fz.base */
			padding-left: ${props => numToCssSize(props.theme.fz.base + (props.theme.controlHeightBase / 4) * 2)};
		}
		${Placeholder} {
			left: ${props => numToCssSize(props.theme.fz.base + (props.theme.controlHeightBase / 4) * 2)};
		}
	}

	&.${CONTROLCLASS$b}--has-error {
		${Prefix} {
			color: ${props => props.theme.errorColor};
		}
	}

	/** Changes when focused */
	&.${CONTROLCLASS$b}--is-focused, &.${CONTROLCLASS$b}--is-not-empty {
		${Placeholder} {
			top: ${props => numToCssSize((props.theme.controlHeightBase / 2) * -1)};
			left: 0;
			font-size: ${props => numToCssSize(props.theme.fz.small1)};
		}
	}
`;
/**
 * A controlled Textarea component. Apart from being a normal textarea it can
 * also accept prefix and will adapt to its height based on content.
 */
function Textarea(props) {
    const { id, onChange, onBlur, value, prefix, placeholder, controlType = SettingsAppearanceControlTypeEnum.BOXY, controlAlignment = SettingsAppearanceControlAlignmentEnum.LEFT, disabled = false, readOnly = false, hasError = false, minRows = 4, maxRows = 10, className, ...textareaProps } = props;
    const [focused, setFocused] = useState$1(false);
    // localize the input value for performance, we don't want every keystroke
    // update the whole outer state
    const [localValue, setLocalValue] = useState$1(value);
    const debouncedOnChange = useDebouncedCallback((newValue, updater) => {
        updater(newValue);
    }, 300);
    const localOnChange = useCallback$1((event) => {
        const newValue = event.target.value;
        setLocalValue(newValue);
        debouncedOnChange(newValue, onChange);
    }, [debouncedOnChange, onChange]);
    // sync it back from the props
    useEffect(() => {
        setLocalValue(value);
    }, [value]);
    const containerClasses = getBemClassName(CONTROLCLASS$b, {
        'has-prefix': !!prefix,
        'is-not-empty': value !== '',
        'is-focused': focused,
        'has-error': hasError,
        [`type-${controlType}`]: true,
        [`align-${controlAlignment}`]: true,
    }, className);
    return (jsxs(Container$3, Object.assign({ className: containerClasses }, { children: [prefix ? jsx(Prefix, { children: prefix }, void 0) : null, typeof placeholder !== 'string' ? (jsx(Placeholder, { children: placeholder }, void 0)) : null, jsx(StyledTextarea, Object.assign({ minRows: minRows, maxRows: maxRows, id: id, className: getBemClassName(getBemElement(CONTROLCLASS$b, 'textarea'), {
                    [`type-${controlType}`]: true,
                    'has-error': hasError,
                }), value: localValue, onChange: localOnChange, onFocus: () => {
                    setFocused(true);
                }, onBlur: e => {
                    setFocused(false);
                    debouncedOnChange.cancel();
                    onChange(localValue);
                    onBlur?.(e);
                }, placeholder: typeof placeholder === 'string' ? placeholder : undefined, disabled: disabled, readOnly: readOnly }, textareaProps), void 0), controlType === SettingsAppearanceControlTypeEnum.MATERIAL ? (jsx(MaterialBorder, {}, void 0)) : null] }), void 0));
}

const textarea = {
    id: 'textarea',
    hasSubmission: true,
    FormUi({ id, elementData, submissionData, updateSubmissionData, setElementTouched, controlType, controlLayout, controlAlignment, elementTitle, hasError = false, }) {
        const value = submissionData.value.textarea?.input ?? '';
        const onChange = useCallback$1((newValue) => {
            const newSubmissionData = fn(submissionData, draftState => {
                draftState.value.textarea.input = newValue;
            });
            updateSubmissionData(newSubmissionData);
        }, [updateSubmissionData, submissionData]);
        return (jsx(Textarea, { id: id, controlType: controlType, controlAlignment: controlAlignment, onChange: onChange, value: value, onBlur: () => {
                setElementTouched(true);
            }, hasError: hasError, placeholder: controlLayout !== SettingsAppearanceControlLayoutEnum.INLINE
                ? elementData.config.textarea?.interface?.placeholder || ''
                : elementTitle, prefix: elementData.config.textarea?.interface?.icon ? (jsx(Icon, { iconClass: elementData.config.textarea.interface.icon }, void 0)) : undefined, readOnly: elementData.config.textarea?.attributes.readonly }, void 0));
    },
    isQuestion: true,
    isRequired(elementData) {
        if (elementData.config.textarea?.validation?.required) {
            return true;
        }
        return false;
    },
    getErrors(elementData, submissionDataValue) {
        const errors = [];
        // required check
        const isRequired = !!elementData.config.textarea?.validation?.required;
        const isEmpty = submissionDataValue.textarea?.input === '' ||
            submissionDataValue.textarea?.input === null;
        // if it is required and if is empty, then push the message
        if (isRequired && isEmpty) {
            errors.push(validationMessages.requiredInput);
        }
        // in textarea we check for EVERYTHING, NOLETTER and NONUMBER
        const input = submissionDataValue.textarea?.input || '';
        const filters = elementData.config.textarea?.validation?.filters;
        // min string and max string
        if (filters &&
            [
                ValidationFilterTypeEnum.ALL,
                ValidationFilterTypeEnum.NOLETTER,
                ValidationFilterTypeEnum.NONUMBER,
            ].includes(filters.type)) {
            // RegEx check noletter or nonumber
            if (filters.type === ValidationFilterTypeEnum.NOLETTER) {
                errors.push(...checkIf(input)
                    .not()
                    .matches(/[A-Za-z]/m, validationMessages.inputNoLetter)
                    .hasErrors());
            }
            else if (filters.type === ValidationFilterTypeEnum.NONUMBER) {
                errors.push(...checkIf(input)
                    .not()
                    .matches(/[0-9]/m, validationMessages.inputNoNumber)
                    .hasErrors());
            }
            // if minString is there
            if (filters.minString && (isRequired || (!isRequired && !isEmpty))) {
                errors.push(...checkIf(input)
                    .hasMinLength(filters.minString, sprintf(validationMessages.minStringInput, filters.minString, input.length))
                    .hasErrors());
            }
            // if maxString is there
            if (filters.maxString && (isRequired || (!isRequired && !isEmpty))) {
                errors.push(...checkIf(input)
                    .hasMaxLength(filters.maxString, sprintf(validationMessages.maxStringInput, filters.maxString, input.length))
                    .hasErrors());
            }
        }
        return errors;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        mutableSubmissionDataValue.textarea.input = newValue;
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue) {
        let conditionStatus;
        const selectedLength = submissionDataValue.textarea.input.length;
        if (has === EventHasEnum.LENGTH) {
            const compareLength = getPositiveIntValue(value);
            if (comparison === EventComparisonEnum.GREATER_THAN) {
                conditionStatus = selectedLength > compareLength;
            }
            else if (comparison === EventComparisonEnum.LESS_THAN) {
                conditionStatus = selectedLength < compareLength;
            }
            else {
                conditionStatus = selectedLength === compareLength;
            }
        }
        else {
            // here we have many things to consider
            const inputValue = submissionDataValue.textarea.input;
            if (comparison === EventComparisonEnum.CONTAINS) {
                const regEx = new RegExp(value, 'gi');
                conditionStatus = regEx.test(inputValue);
            }
            else if (comparison === EventComparisonEnum.ENDS_WITH) {
                const regEx = new RegExp(`${value}$`, 'gi');
                conditionStatus = regEx.test(inputValue);
            }
            else if (comparison === EventComparisonEnum.EQUALS_TO) {
                conditionStatus = value.toLowerCase() === inputValue.toLowerCase();
            }
            else if (comparison === EventComparisonEnum.GREATER_THAN) {
                const valueNum = getNumericValue(value);
                const inputNum = getNumericValue(inputValue);
                conditionStatus = inputNum > valueNum;
            }
            else if (comparison === EventComparisonEnum.LESS_THAN) {
                const valueNum = getNumericValue(value);
                const inputNum = getNumericValue(inputValue);
                conditionStatus = inputNum < valueNum;
            }
            else {
                // starts with
                const regEx = new RegExp(`^${value}`, 'gi');
                conditionStatus = regEx.test(inputValue);
            }
        }
        return operation === EventOperationEnum.IS
            ? conditionStatus
            : !conditionStatus;
    },
    getDisplayValue(elementData, submissionDataValue) {
        return submissionDataValue.textarea?.input;
    },
    getNumericValue(elementData, submissionDataValue) {
        return getFloatValue(submissionDataValue.textarea?.input);
    },
    getAnswerValue(elementData, submissionDataValue) {
        return (jsx(AnswerPreview.UserInput, { children: submissionDataValue.textarea?.input ?? null }, void 0));
    },
    getPresetValue(elementData, defaultValue) {
        const newDefaultValue = fn(defaultValue, draftValue => {
            // If it has a set default value
            if (!isNullOrEmptyString(elementData.config.textarea?.attributes.defaultValue)) {
                draftValue.textarea.input =
                    elementData.config.textarea.attributes.defaultValue;
            }
            // override if URL query parameter is used
            if (elementData.config.textarea?.attributes.prefilType === PrefilEnum.URL) {
                const urlParameterValue = getUrlParameterValue(window.location.search, elementData.config.textarea.attributes.prefilParameter);
                if (urlParameterValue && typeof urlParameterValue === 'string') {
                    draftValue.textarea.input = urlParameterValue;
                }
            }
            // override if meta based query is used
            if (elementData.config.textarea?.attributes.prefilType === PrefilEnum.META) {
                const decodedExtra = decodeJSONRecord(elementData.extras);
                if (decodedExtra &&
                    decodedExtra.metaValue &&
                    typeof decodedExtra.metaValue === 'string') {
                    draftValue.textarea.input = decodedExtra.metaValue;
                }
            }
        });
        return newDefaultValue;
    },
};

const row = {
    id: 'row',
    hasSubmission: false,
    FormUi({ elementData }) {
        return (jsx(Grid.NegateGutter, Object.assign({ vertical: true, className: elementData.appearance?.className }, { children: jsx(GridElements, { emptyMessage: __('This row element is empty', 'wp-eform'), elements: elementData.children }, void 0) }), void 0));
    },
    getErrors() {
        // a row has no errors
        return [];
    },
    isQuestion: false,
    isRequired() {
        // a row is never required
        return false;
    },
    setValue() { },
};

const column = {
    id: 'column',
    hasSubmission: false,
    FormUi({ elementData }) {
        return (jsx(Grid.NegateGutter, Object.assign({ vertical: true, className: elementData.appearance?.className }, { children: jsx(GridElements, { emptyMessage: __('This column element is empty', 'wp-eform'), elements: elementData.children }, void 0) }), void 0));
    },
    getErrors() {
        // a column has no errors
        return [];
    },
    isQuestion: false,
    isRequired() {
        // a column is never required
        return false;
    },
    setValue() { },
};

const CONTROLCLASS$a = 'wpeform-component-heading';
const HeadingTag = styled.p `
	${cssReset};
	color: ${props => props.theme.headingColor};
	line-height: 1.2;
	font-weight: ${props => (props.theme.boldHeading ? 'bold' : 'normal')};
`;
const Subheading = styled.p `
	${cssReset};
	font-size: 0.6em;
	color: ${props => props.theme.textColorSecondary};
	font-style: ${props => (props.theme.italicHeading ? 'italic' : 'normal')};
	line-height: 1.2;
	margin: 0.5em 0 0 0;
`;
const HeadingTextContainer = styled.div `
	position: relative;
`;
const HeadingIcon = styled.span `
	display: inline-block;
	margin: 0 0 0.25em 0;
	font-size: 2em;
`;
const HeadingDivider = styled.div `
	${cssReset};
	display: inline-block;
	margin: 0.5em 0 0 0;
	height: ${props => numToCssSize(props.theme.borderRadiusBase)};
	background-color: ${props => props.theme.headingColor};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	width: 30%;
	min-width: 100px;
	max-width: 200px;
`;
const ScrollToTopButton = styled.button `
	${cssReset};
	display: flex;
	position: absolute;
	align-items: center;
	justify-content: center;
	top: 0;
	right: ${props => numToCssSize(props.theme.gutter * -1)};
	border: 0 none;
	outline: none;
	cursor: pointer;
	font-size: ${props => numToCssSize(props.theme.gutter)};
	background-color: transparent;
	color: ${props => props.theme.textColorSecondary};
	transition: ${props => getMultipleTransitionsWithWillChange(['color'], props.theme.transitionControl)};
	&:hover,
	&:focus,
	&:active {
		color: ${props => props.theme.primaryColor};
	}
`;
const HeadingContainer = styled.div `
	${cssReset};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	line-height: 1.2;
	position: relative;

	/** Size */
	&.${CONTROLCLASS$a}--size-SIZE1 {
		font-size: ${props => numToCssSize(props.theme.fz.large7)};
		${ScrollToTopButton} {
			height: ${props => numToCssSize(props.theme.fz.large7 * 1.2)};
		}
	}
	&.${CONTROLCLASS$a}--size-SIZE2 {
		font-size: ${props => numToCssSize(props.theme.fz.large5)};
		${ScrollToTopButton} {
			height: ${props => numToCssSize(props.theme.fz.large5 * 1.2)};
		}
	}
	&.${CONTROLCLASS$a}--size-SIZE3 {
		font-size: ${props => numToCssSize(props.theme.fz.large3)};
		${ScrollToTopButton} {
			height: ${props => numToCssSize(props.theme.fz.large3 * 1.2)};
		}
	}
	&.${CONTROLCLASS$a}--size-SIZE4 {
		font-size: ${props => numToCssSize(props.theme.fz.large1)};
		${ScrollToTopButton} {
			height: ${props => numToCssSize(props.theme.fz.large1 * 1.2)};
		}
	}
	&.${CONTROLCLASS$a}--size-SIZE5 {
		font-size: ${props => numToCssSize(props.theme.fz.small1)};
		${ScrollToTopButton} {
			height: ${props => numToCssSize(props.theme.fz.small1 * 1.2)};
		}
	}
	&.${CONTROLCLASS$a}--size-SIZE6 {
		font-size: ${props => numToCssSize(props.theme.fz.small2)};
		${ScrollToTopButton} {
			height: ${props => numToCssSize(props.theme.fz.small2 * 1.2)};
		}
	}

	/** Align */
	&.${CONTROLCLASS$a}--alignment-LEFT {
		text-align: left;
	}
	&.${CONTROLCLASS$a}--alignment-RIGHT {
		text-align: right;
		${ScrollToTopButton} {
			right: auto;
			left: ${props => numToCssSize(props.theme.gutter * -1)};
		}
	}
	&.${CONTROLCLASS$a}--alignment-CENTER {
		text-align: center;
	}
	&.${CONTROLCLASS$a}--alignment-JUSTIFY {
		text-align: justify;
	}
`;
const Article = styled.article `
	margin: ${props => numToCssSize(props.theme.gutter)} 0 0 0;
	${HeadingDivider} {
		margin: ${props => numToCssSize(props.theme.gutter)} 0 0 0;
	}
`;

function interpolateTagFromEnum(tag) {
    if (tag === HeadingTagEnum.H1) {
        return 'h1';
    }
    if (tag === HeadingTagEnum.H2) {
        return 'h2';
    }
    if (tag === HeadingTagEnum.H3) {
        return 'h3';
    }
    if (tag === HeadingTagEnum.H4) {
        return 'h4';
    }
    if (tag === HeadingTagEnum.H5) {
        return 'h5';
    }
    if (tag === HeadingTagEnum.H6) {
        return 'h6';
    }
    return 'p';
}
function Heading(props) {
    const { icon, size, tag, showTop = false, divider = false, alignment, scrollToElement, scrollOffset = -100, scrollLabel, title, subtitle, className, children, } = props;
    return (jsxs(Fragment, { children: [jsxs(HeadingContainer, Object.assign({ className: getBemClassName(CONTROLCLASS$a, {
                    [`size-${size}`]: true,
                    showTop,
                    divider,
                    [`alignment-${alignment}`]: true,
                    hasIcon: !!icon,
                    hasShowTop: showTop,
                }, className) }, { children: [icon ? (jsx(HeadingIcon, { children: jsx(Icon, { iconClass: icon }, void 0) }, void 0)) : null, jsxs(HeadingTextContainer, { children: [jsx(HeadingTag, Object.assign({ as: interpolateTagFromEnum(tag) }, { children: title }), void 0), subtitle ? jsx(Subheading, { children: subtitle }, void 0) : null, showTop ? (jsx(ScrollToTopButton, Object.assign({ onClick: e => {
                                    e.preventDefault();
                                    _default(scrollToElement, {
                                        verticalOffset: scrollOffset,
                                        elementToScroll: scrollParents(scrollToElement)[0],
                                    });
                                } }, { children: jsx(Icon, { iconClass: "fas fa-angle-up", "aria-label": scrollLabel }, void 0) }), void 0)) : null] }, void 0), divider ? jsx(HeadingDivider, {}, void 0) : null] }), void 0), children ? (jsxs(Article, { children: [children, jsx(HeadingDivider, {}, void 0)] }, void 0)) : null] }, void 0));
}

const heading = {
    id: 'heading',
    hasSubmission: false,
    FormUi({ elementData, controlAlignment }) {
        const titleNodes = useNodesFromJson(elementData.appearance?.title);
        const subtitleNodes = useNodesFromJson(elementData.appearance?.subtitle);
        const formData = useSubmissionFormData();
        const containerRef = useResponsiveContainerRef();
        const descriptionNodes = useNodesFromJson(elementData.appearance?.description);
        return (jsx(Fragment, { children: jsx(Heading, Object.assign({ title: !titleNodes ? ('') : (jsx(SlateViewWithData, { mode: "singleline", nodes: titleNodes, currentElementId: elementData.id }, void 0)), subtitle: !subtitleNodes ? undefined : (jsx(SlateViewWithData, { mode: "singleline", nodes: subtitleNodes, currentElementId: elementData.id }, void 0)), alignment: controlAlignment, divider: elementData.config.heading?.interface?.divider, scrollLabel: __('Scroll to top', 'wp-eform'), scrollToElement: containerRef.current ?? document.body, showTop: elementData.config.heading?.interface?.showTop, size: elementData.config.heading?.interface?.size ?? HeadingSizeEnum.SIZE3, className: elementData.appearance?.className, tag: elementData.config.heading?.interface?.tag ?? HeadingTagEnum.P, icon: elementData.config.heading?.interface?.icon, scrollOffset: formData.styles?.pagination?.scrollOffset !== undefined
                    ? formData.styles.pagination.scrollOffset * -1
                    : -100 }, { children: descriptionNodes ? (jsx(SlateViewWithData, { mode: "multiline", currentElementId: elementData.id, nodes: descriptionNodes }, void 0)) : null }), void 0) }, void 0));
    },
    getErrors() {
        // a heading has no errors
        return [];
    },
    isQuestion: false,
    isRequired() {
        // a heading is never required
        return false;
    },
    setValue() { },
};

const CONTROLCLASS$9 = 'wpeform-control-checkbox';
const Control$1 = styled.div `
	${cssReset};
	height: ${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7))};
	width: ${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7))};
	flex: 0 0
		${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7))};
	border: 1px solid ${props => props.theme.borderColorBase};
	box-shadow: ${props => props.theme.boxShadowNoneFocus};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	margin: 0;
	background-color: ${props => props.theme.appBackgroundColor};
	display: flex;
	align-items: center;
	justify-content: center;
	transition: ${props => getMultipleTransitionsWithWillChange(['box-shadow', 'border-color', 'background-color'], props.theme.transitionControl)};
	position: relative;

	&::before {
		content: '';
		display: block;
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		opacity: 1;
		transform: scale(0.75);
		transform-origin: center;
		border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
		background-color: 'transparent';
	}
`;
const ControlState$1 = styled.div `
	width: 100%;
	height: 100%;
	color: ${props => props.theme.primaryBgText};
	font-size: ${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.35))};
	display: flex;
	align-items: center;
	justify-content: center;
	opacity: 0;
	transition: ${props => getMultipleTransitionsWithWillChange(['opacity'], props.theme.transitionControl)};
`;
const Text$1 = styled.div `
	user-select: none;
	color: ${props => props.theme.textColorSecondary};
	flex: 0 0
		calc(
			100% -
				${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7) +
    props.theme.controlHeightBase * 0.25)}
		);
	width: calc(
		100% -
			${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7) +
    props.theme.controlHeightBase * 0.25)}
	);
	line-height: ${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7))};
	transition: ${props => getMultipleTransitionsWithWillChange(['color'], props.theme.transitionControl)};
`;
const Label$2 = styled.label `
	${cssReset};
	display: inline-flex;
	flex-flow: row nowrap;
	align-items: flex-start;
	justify-content: flex-start;
	max-width: 100%;
	width: auto;
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	cursor: pointer;
	position: relative;

	&.${CONTROLCLASS$9}--is-disabled {
		cursor: not-allowed;
	}

	&.${CONTROLCLASS$9}--has-text {
		display: flex;
		width: 100%;
		${Control$1} {
			margin: 0 ${props => numToCssSize(props.theme.controlHeightBase * 0.25)} 0
				0;
		}
	}

	input[type='checkbox'] {
		position: absolute;
		left: 0;
		top: 0;
		height: 0;
		width: 0;
		opacity: 0;

		&:hover {
			+ ${Control$1} {
				border-color: ${props => props.theme.primaryColor};
			}
			~ ${Text$1} {
				color: ${props => props.theme.textColor};
			}
		}

		&:focus,
		&:active {
			+ ${Control$1} {
				border-color: ${props => props.theme.primaryColor};
				box-shadow: ${props => props.theme.boxShadowControlFocus};
			}
		}

		&:checked {
			~ ${Text$1} {
				color: ${props => props.theme.textColor};
			}
			+ ${Control$1} {
				background-color: ${props => props.theme.primaryColor};
				border-color: ${props => props.theme.primaryColor};
				> ${ControlState$1} {
					opacity: 1;
				}
				&::before {
					transform: scale(1.7);
					opacity: 0;
					background-color: ${props => props.theme.primaryColor};
					transition: ${props => getMultipleTransitionsWithWillChange(['transform', 'opacity', 'background-color'], props.theme.transitionControl)};
				}
			}
		}

		&:disabled {
			~ ${Text$1} {
				color: ${props => props.theme.disabledColor};
			}

			+ ${Control$1} {
				border-color: ${props => props.theme.disabledColor};
				box-shadow: none;
			}

			&:checked {
				+ ${Control$1} {
					background-color: ${props => props.theme.disabledColor};
					border-color: ${props => props.theme.disabledColor};
				}
			}
		}
	}
`;
/**
 * A controlled checkbox component with an associated label.
 */
function Checkbox(props) {
    const { text, checked, onChange, onBlur, icon = 'fas fa-check', id, className, disabled, ariaLabel, ariaLabelledby, ...cbProps } = props;
    const containerClasses = getBemClassName(CONTROLCLASS$9, {
        'is-checked': !!checked,
        'has-text': !!text,
        'is-disabled': !!disabled,
    }, className);
    return (jsxs(Label$2, Object.assign({ htmlFor: id, className: containerClasses }, { children: [jsx("input", Object.assign({ type: "checkbox", checked: checked, onChange: e => {
                    onChange(e.target.checked);
                }, id: id, "aria-labelledby": ariaLabelledby, "aria-label": ariaLabel, disabled: disabled }, cbProps, { onBlur: e => {
                    if (onBlur) {
                        onBlur(e);
                    }
                } }), void 0), jsx(Control$1, { children: jsx(ControlState$1, { children: jsx(Icon, { iconClass: icon }, void 0) }, void 0) }, void 0), text ? jsx(Text$1, { children: text }, void 0) : null] }), void 0));
}

function getLengthComparisonStatus(compareWith, selectedLength, comparison) {
    let conditionStatus;
    const compareLength = getPositiveIntValue(compareWith);
    if (comparison === EventComparisonEnum.GREATER_THAN) {
        conditionStatus = selectedLength > compareLength;
    }
    else if (comparison === EventComparisonEnum.LESS_THAN) {
        conditionStatus = selectedLength < compareLength;
    }
    else {
        conditionStatus = selectedLength === compareLength;
    }
    return conditionStatus;
}
function getConditionStatusBasedOnOperation(operation, conditionStatus) {
    return operation === EventOperationEnum.IS
        ? conditionStatus
        : !conditionStatus;
}

function OtherInput$1(props) {
    const { id, elementData, submissionData, updateSubmissionData } = props;
    const otherValue = submissionData.value.checkbox?.other ?? '';
    const updateOtherValue = useCallback$1((newVal) => {
        updateSubmissionData(fn(submissionData, draftState => {
            draftState.value.checkbox.other = newVal;
        }));
    }, [submissionData, updateSubmissionData]);
    const isOtherVisible = !!submissionData.value.checkbox?.selected.includes(elementData.config.checkbox?.interface?.othersId);
    const placeholderNodes = useNodesFromJson(elementData.config.checkbox?.interface?.othersPlaceholder);
    return (jsx(ControlAddon, Object.assign({ visible: isOtherVisible }, { children: jsx(Text$2, { id: `other-${id}`, value: otherValue, onChange: updateOtherValue, prefix: jsx(Icon, { iconClass: "fas fa-pen-nib" }, void 0), hasError: isOtherVisible &&
                elementData.config.checkbox?.validation?.required &&
                otherValue === '', placeholder: placeholderNodes ? (jsx(SlateViewWithData, { nodes: placeholderNodes, currentElementId: elementData.id }, void 0)) : (__('enter your choice here', 'wp-eform')) }, void 0) }), void 0));
}
const checkbox = {
    id: 'checkbox',
    hasSubmission: true,
    FormUi({ elementData, id, setElementTouched, submissionData, updateSubmissionData, controlAlignment, }) {
        // figure out the extra input before hand
        const isOtherRequired = elementData.config.checkbox?.interface?.others;
        // shuffle if needed
        const options = useMemo(() => {
            const optionsList = [
                ...(elementData.config.checkbox?.interface?.options ?? []),
            ];
            if (elementData.config.checkbox?.interface?.shuffle) {
                shuffleArray(optionsList);
            }
            return optionsList;
        }, [
            elementData.config.checkbox?.interface?.options,
            elementData.config.checkbox?.interface?.shuffle,
        ]);
        return (jsxs(Fragment, { children: [jsx(OptionGroup, Object.assign({ columns: elementData.config.checkbox?.interface?.columns ||
                        OptionColumnEnum.AUTO, controlAlignment: controlAlignment }, { children: options.map(op => (jsx(OptionGroup.Item, { children: jsx(Checkbox, { id: `${id}-${op.id}`, checked: submissionData.value.checkbox?.selected.includes(op.id) ||
                                false, disabled: elementData.config.checkbox?.attributes.readonly, onChange: checked => {
                                if (checked) {
                                    updateSubmissionData(fn(submissionData, draftState => {
                                        draftState.value.checkbox.selected.push(op.id);
                                    }));
                                }
                                else {
                                    updateSubmissionData(fn(submissionData, draftState => {
                                        draftState.value.checkbox.selected =
                                            draftState.value.checkbox.selected.filter(oid => oid !== op.id);
                                    }));
                                }
                            }, name: `${id}[]`, text: jsx(SlateViewWithData, { nodes: getNodesFromJSON(op.label), mode: "singleline", currentElementId: elementData.id }, void 0), icon: elementData.config.checkbox?.interface?.icon, onBlur: () => {
                                setElementTouched(true);
                            } }, void 0) }, op.id))) }), void 0), isOtherRequired ? (jsx(OtherInput$1, { elementData: elementData, id: id, submissionData: submissionData, updateSubmissionData: updateSubmissionData }, void 0)) : null] }, void 0));
    },
    getErrors(elementData, submissionDataValue) {
        const errors = [];
        const isRequired = !!elementData.config.checkbox?.validation?.required;
        const totalSelectedOptions = submissionDataValue.checkbox?.selected.length ?? 0;
        const isOtherEnabled = elementData.config.checkbox?.interface?.others;
        const isOtherVisible = !!submissionDataValue.checkbox?.selected.includes(elementData.config.checkbox?.interface?.othersId);
        // if this is required
        if (isRequired && totalSelectedOptions === 0) {
            errors.push(validationMessages.requiredOptions);
        }
        // if this is required and does not have the minimum number of options
        const maxItems = elementData.config.checkbox?.validation?.filters.maxItems;
        if (maxItems && totalSelectedOptions && totalSelectedOptions > maxItems) {
            errors.push(sprintf(validationMessages.maxOptions, maxItems, totalSelectedOptions));
        }
        const minItems = isRequired
            ? elementData.config.checkbox?.validation?.filters.minItems ?? 1
            : 0;
        if (minItems && totalSelectedOptions && totalSelectedOptions < minItems) {
            errors.push(sprintf(validationMessages.minOptions, minItems, totalSelectedOptions));
        }
        // if it is required and other is visible, but not entered
        if (isRequired &&
            isOtherEnabled &&
            isOtherVisible &&
            !submissionDataValue.checkbox?.other) {
            errors.push(validationMessages.requiredOther);
        }
        return errors;
    },
    isQuestion: true,
    isRequired(elementData) {
        return !!elementData.config.checkbox?.validation?.required;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        const options = elementData.config.checkbox?.interface?.options;
        if (options) {
            // get to make sure the newValue actually exists in the set of options
            if (options.find(o => o.id === newValue)) {
                mutableSubmissionDataValue.checkbox.selected = [newValue];
            }
        }
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue) {
        let conditionStatus;
        const selectedLength = submissionDataValue.checkbox.selected.length;
        if (has === EventHasEnum.LENGTH) {
            conditionStatus = getLengthComparisonStatus(value, selectedLength, comparison);
        }
        else {
            // here we compare with either equals to, i.e only one option is selected
            // eslint-disable-next-line no-lonely-if
            const compareWithValue = getOptionIdsFromString(value);
            const allSelectedInCompareWith = compareWithValue.every(val => submissionDataValue.checkbox?.selected.includes(val)) ?? false;
            if (comparison === EventComparisonEnum.EQUALS_TO) {
                conditionStatus =
                    selectedLength === compareWithValue.length &&
                        allSelectedInCompareWith;
            }
            else {
                // the selected one may contain the value
                conditionStatus = allSelectedInCompareWith;
            }
        }
        return getConditionStatusBasedOnOperation(operation, conditionStatus);
    },
    getDisplayValue(elementData, submissionDataValue) {
        const selectedOptionIds = submissionDataValue.checkbox?.selected;
        if (selectedOptionIds &&
            selectedOptionIds.length &&
            elementData.config.checkbox?.interface?.options.length) {
            const selectedOptions = getChosenItemsInOrder(selectedOptionIds, elementData.config.checkbox.interface.options);
            return selectedOptions.map((op, index) => (jsxs(React__default.Fragment, { children: [jsx(SlateViewWithoutMentions, { nodes: getNodesFromJSON(op.label), mode: "singleline" }, void 0), index !== selectedOptions.length - 1 ? jsx("span", { children: ", " }, void 0) : null] }, op.id)));
        }
        return null;
    },
    getNumericValue(elementData, submissionDataValue) {
        const selectedOptionIds = submissionDataValue.checkbox?.selected;
        if (selectedOptionIds &&
            selectedOptionIds.length &&
            elementData.config.checkbox?.interface?.options.length) {
            const selectedOptions = getChosenItemsInOrder(selectedOptionIds, elementData.config.checkbox.interface.options);
            return selectedOptions.reduce((acc, cur) => {
                return acc + (cur.num ?? 0);
            }, 0);
        }
        return 0;
    },
    getAnswerValue(elementData, submissionDataValue) {
        const selectedOptionIds = submissionDataValue.checkbox?.selected;
        if (selectedOptionIds &&
            selectedOptionIds.length &&
            elementData.config.checkbox?.interface?.options.length) {
            const selectedOptions = getChosenItemsInOrder(selectedOptionIds, elementData.config.checkbox.interface.options);
            const selectedOptionsList = selectedOptions.map(op => {
                const description = getNodesFromJSON(op.answerDescription);
                return (jsxs("li", { children: [jsx(SlateViewWithData, { nodes: getNodesFromJSON(op.label), mode: "singleline", currentElementId: elementData.id }, void 0), !isNodesEmpty(description) ? (jsxs(Fragment, { children: [jsx(AnswerPreview.Separator, { isLight: true }, void 0), jsx(AnswerPreview.OptionDescription, { children: jsx(SlateViewWithData, { nodes: description, mode: "multiline", currentElementId: elementData.id }, void 0) }, void 0)] }, void 0)) : null] }, op.id));
            });
            return (jsxs(AnswerPreview.Generic, { children: [jsx("ul", { children: selectedOptionsList }, void 0), submissionDataValue.checkbox?.other &&
                        elementData.config.checkbox.interface.others &&
                        selectedOptionIds.includes(elementData.config.checkbox.interface.othersId) ? (jsxs(Fragment, { children: [jsx(AnswerPreview.Separator, {}, void 0), jsx(AnswerPreview.UserInput, { children: submissionDataValue.checkbox.other }, void 0)] }, void 0)) : null] }, void 0));
        }
        return __('No options selected.', 'wp-eform');
    },
    getPresetValue(elementData, defaultValue) {
        const newDefaultValue = fn(defaultValue, draftValue => {
            // If it has a set default value
            if (!isNullOrEmptyString(elementData.config.checkbox?.attributes.defaultValue)) {
                draftValue.checkbox.selected = getOptionIdsFromString(elementData.config.checkbox.attributes.defaultValue);
            }
            // override if URL query parameter is used
            if (elementData.config.checkbox?.attributes.prefilType === PrefilEnum.URL) {
                const compareWith = getUrlParameterValue(window.location.search, elementData.config.checkbox.attributes.prefilParameter);
                if (compareWith) {
                    const possibleOptionIds = matchValuesAgainstOptionLabel(elementData.config.checkbox.interface?.options, compareWith);
                    if (possibleOptionIds.length) {
                        draftValue.checkbox.selected = possibleOptionIds;
                    }
                }
            }
            // override if meta based query is used
            if (elementData.config.checkbox?.attributes.prefilType === PrefilEnum.META) {
                const decodedExtra = decodeJSONRecord(elementData.extras);
                if (decodedExtra && decodedExtra.metaValue) {
                    // metaValue here will be array of option ids, but make sure it is present
                    const metaValue = decodedExtra.metaValue;
                    if (Array.isArray(metaValue)) {
                        const newSelectedValue = [];
                        elementData.config.checkbox.interface?.options.forEach(op => {
                            if (metaValue.includes(op.id)) {
                                newSelectedValue.push(op.id);
                            }
                        });
                        if (newSelectedValue.length) {
                            draftValue.checkbox.selected = newSelectedValue;
                        }
                    }
                }
            }
        });
        return newDefaultValue;
    },
};

const CONTROLCLASS$8 = 'wpeform-control-radio';
const Control = styled.div `
	${cssReset};
	height: ${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7))};
	width: ${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7))};
	flex: 0 0
		${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7))};
	border: 1px solid ${props => props.theme.borderColorBase};
	box-shadow: ${props => props.theme.boxShadowNoneFocus};
	border-radius: 100%;
	margin: 0;
	background-color: ${props => props.theme.appBackgroundColor};
	display: flex;
	align-items: center;
	justify-content: center;
	transition: ${props => getMultipleTransitionsWithWillChange(['box-shadow', 'border-color', 'background-color'], props.theme.transitionControl)};
	position: relative;

	&::before {
		content: '';
		display: block;
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		opacity: 1;
		transform: scale(0.75);
		transform-origin: center;
		border-radius: 100%;
		background-color: 'transparent';
	}
`;
const ControlState = styled.div `
	width: 100%;
	height: 100%;
	color: ${props => props.theme.primaryBgText};
	font-size: ${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.35))};
	display: flex;
	align-items: center;
	justify-content: center;
	line-height: 1;
	opacity: 0;
	transition: ${props => getMultipleTransitionsWithWillChange(['opacity'], props.theme.transitionControl)};
`;
const Text = styled.div `
	user-select: none;
	color: ${props => props.theme.textColorSecondary};
	flex: 0 0
		calc(
			100% -
				${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7) +
    props.theme.controlHeightBase * 0.25)}
		);
	width: calc(
		100% -
			${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7) +
    props.theme.controlHeightBase * 0.25)}
	);
	line-height: ${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7))};
	transition: ${props => getMultipleTransitionsWithWillChange(['color'], props.theme.transitionControl)};
`;
const Label$1 = styled.label `
	${cssReset};
	display: inline-flex;
	flex-flow: row nowrap;
	align-items: flex-start;
	justify-content: flex-start;
	max-width: 100%;
	width: auto;
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	cursor: pointer;
	position: relative;

	&.${CONTROLCLASS$8}--is-disabled {
		cursor: not-allowed;
	}

	&.${CONTROLCLASS$8}--has-text {
		display: flex;
		width: 100%;
		${Control} {
			margin: 0 ${props => numToCssSize(props.theme.controlHeightBase * 0.25)} 0
				0;
		}
	}

	input[type='radio'] {
		position: absolute;
		left: 0;
		top: 0;
		height: 0 !important;
		width: 0 !important;
		opacity: 0;

		&:hover {
			+ ${Control} {
				border-color: ${props => props.theme.primaryColor};
			}
			~ ${Text} {
				color: ${props => props.theme.textColor};
			}
		}

		&:focus,
		&:active {
			+ ${Control} {
				border-color: ${props => props.theme.primaryColor};
				box-shadow: ${props => props.theme.boxShadowControlFocus};
			}
		}

		&:checked {
			~ ${Text} {
				color: ${props => props.theme.textColor};
			}
			+ ${Control} {
				background-color: ${props => props.theme.primaryColor};
				border-color: ${props => props.theme.primaryColor};
				> ${ControlState} {
					opacity: 1;
				}
				&::before {
					transform: scale(1.7);
					opacity: 0;
					background-color: ${props => props.theme.primaryColor};
					transition: ${props => getMultipleTransitionsWithWillChange(['transform', 'opacity', 'background-color'], props.theme.transitionControl)};
				}
			}
		}

		&:disabled {
			~ ${Text} {
				color: ${props => props.theme.disabledColor};
			}

			+ ${Control} {
				border-color: ${props => props.theme.disabledColor};
				box-shadow: none;
			}

			&:checked {
				+ ${Control} {
					background-color: ${props => props.theme.disabledColor};
					border-color: ${props => props.theme.disabledColor};
				}
			}
		}
	}
`;
/**
 * A controlled radio component with an associated label.
 */
function Radio(props) {
    const { text, checked, onChange, onBlur, icon = 'fas fa-circle', id, className, disabled, ariaLabel, ariaLabelledby, ...cbProps } = props;
    const containerClasses = getBemClassName(CONTROLCLASS$8, {
        'is-checked': !!checked,
        'has-text': !!text,
        'is-disabled': !!disabled,
    }, className);
    return (jsxs(Label$1, Object.assign({ htmlFor: id, className: containerClasses }, { children: [jsx("input", Object.assign({ type: "radio", checked: checked, onChange: e => {
                    onChange(e.target.checked);
                }, id: id, disabled: disabled, onBlur: e => {
                    if (onBlur) {
                        onBlur(e);
                    }
                }, "aria-labelledby": ariaLabelledby, "aria-label": ariaLabel }, cbProps), void 0), jsx(Control, { children: jsx(ControlState, { children: jsx(Icon, { iconClass: icon }, void 0) }, void 0) }, void 0), text ? jsx(Text, { children: text }, void 0) : null] }), void 0));
}

function OtherInput(props) {
    const { id, elementData, submissionData, updateSubmissionData } = props;
    const otherValue = submissionData.value.radio?.other ?? '';
    const updateOtherValue = useCallback$1((newVal) => {
        updateSubmissionData(fn(submissionData, draftState => {
            draftState.value.radio.other = newVal;
        }));
    }, [submissionData, updateSubmissionData]);
    const isOtherVisible = elementData.config.radio?.interface?.othersId ===
        submissionData.value.radio?.selected;
    const placeholderNodes = useNodesFromJson(elementData.config.radio?.interface?.othersPlaceholder);
    return (jsx(ControlAddon, Object.assign({ visible: isOtherVisible }, { children: jsx(Text$2, { id: `other-${id}`, value: otherValue, onChange: updateOtherValue, prefix: jsx(Icon, { iconClass: "fas fa-pen-nib" }, void 0), hasError: isOtherVisible &&
                elementData.config.radio?.validation?.required &&
                otherValue === '', placeholder: placeholderNodes ? (jsx(SlateViewWithData, { nodes: placeholderNodes, currentElementId: elementData.id }, void 0)) : (__('enter your choice here', 'wp-eform')) }, void 0) }), void 0));
}
const radio = {
    id: 'radio',
    hasSubmission: true,
    FormUi({ elementData, id, setElementTouched, submissionData, updateSubmissionData, controlAlignment, }) {
        // figure out the extra input before hand
        const isOtherRequired = elementData.config.radio?.interface?.others;
        // shuffle if needed
        const options = useMemo(() => {
            const optionsList = [
                ...(elementData.config.radio?.interface?.options ?? []),
            ];
            if (elementData.config.radio?.interface?.shuffle) {
                shuffleArray(optionsList);
            }
            return optionsList;
        }, [
            elementData.config.radio?.interface?.options,
            elementData.config.radio?.interface?.shuffle,
        ]);
        return (jsxs(Fragment, { children: [jsx(OptionGroup, Object.assign({ columns: elementData.config.radio?.interface?.columns ||
                        OptionColumnEnum.AUTO, controlAlignment: controlAlignment }, { children: options.map(op => (jsx(OptionGroup.Item, { children: jsx(Radio, { id: `${id}-${op.id}`, checked: submissionData.value.radio?.selected === op.id, onChange: checked => {
                                if (checked) {
                                    updateSubmissionData(fn(submissionData, draftState => {
                                        draftState.value.radio.selected = op.id;
                                    }));
                                    setElementTouched(true);
                                }
                            }, name: id, text: jsx(SlateViewWithData, { nodes: getNodesFromJSON(op.label), mode: "singleline", currentElementId: elementData.id }, void 0), icon: elementData.config.radio?.interface?.icon, onBlur: () => {
                                setElementTouched(true);
                            }, disabled: elementData.config.radio?.attributes.readonly }, void 0) }, op.id))) }), void 0), isOtherRequired ? (jsx(OtherInput, { elementData: elementData, id: id, submissionData: submissionData, updateSubmissionData: updateSubmissionData }, void 0)) : null] }, void 0));
    },
    getErrors(elementData, submissionDataValue) {
        const errors = [];
        const isRequired = !!elementData.config.radio?.validation?.required;
        const selectedOption = submissionDataValue.radio?.selected;
        const isOtherEnabled = elementData.config.radio?.interface?.others;
        const isOtherVisible = submissionDataValue.radio?.selected ===
            elementData.config.radio?.interface?.othersId;
        // if this is required
        if (isRequired && !selectedOption) {
            errors.push(validationMessages.requiredOptions);
        }
        // if it is required and other is visible, but not entered
        if (isRequired &&
            isOtherEnabled &&
            isOtherVisible &&
            !submissionDataValue.radio?.other) {
            errors.push(validationMessages.requiredOther);
        }
        return errors;
    },
    isQuestion: true,
    isRequired(elementData) {
        return !!elementData.config.radio?.validation?.required;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        const options = elementData.config.radio?.interface?.options;
        if (options) {
            // get to make sure the newValue actually exists in the set of options
            if (options.find(o => o.id === newValue)) {
                mutableSubmissionDataValue.radio.selected = newValue;
            }
        }
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue) {
        let conditionStatus;
        const selectedLength = submissionDataValue.radio.selected ? 1 : 0;
        if (has === EventHasEnum.LENGTH) {
            const compareLength = getPositiveIntValue(value);
            if (comparison === EventComparisonEnum.GREATER_THAN) {
                conditionStatus = selectedLength > compareLength;
            }
            else if (comparison === EventComparisonEnum.LESS_THAN) {
                conditionStatus = selectedLength < compareLength;
            }
            else {
                conditionStatus = selectedLength === compareLength;
            }
        }
        else {
            // here we compare with either equals to, i.e only one option is selected
            // eslint-disable-next-line no-lonely-if
            if (comparison === EventComparisonEnum.EQUALS_TO) {
                conditionStatus = submissionDataValue.radio.selected === value;
            }
            else {
                // for everything else, we just say the condition isn't true
                return false;
            }
        }
        return operation === EventOperationEnum.IS
            ? conditionStatus
            : !conditionStatus;
    },
    getDisplayValue(elementData, submissionDataValue) {
        const selectedOptionId = submissionDataValue.radio?.selected;
        if (selectedOptionId) {
            const selectedOption = elementData.config.radio?.interface?.options.find(op => op.id === selectedOptionId);
            if (selectedOption) {
                return (jsx(SlateViewWithoutMentions, { nodes: getNodesFromJSON(selectedOption.label), mode: "singleline" }, void 0));
            }
            return jsx("span", { children: __('Unknown', 'wp-eform') }, void 0);
        }
        return null;
    },
    getAnswerValue(elementData, submissionDataValue) {
        const selectedOptionId = submissionDataValue.radio?.selected;
        if (selectedOptionId) {
            const selectedOption = elementData.config.radio?.interface?.options.find(op => op.id === selectedOptionId);
            if (selectedOption) {
                const description = getNodesFromJSON(selectedOption.answerDescription);
                return (jsxs(AnswerPreview.Generic, { children: [jsx("ul", { children: jsxs("li", { children: [jsx(SlateViewWithData, { currentElementId: elementData.id, nodes: getNodesFromJSON(selectedOption.label), mode: "singleline" }, void 0), !isNodesEmpty(description) ? (jsxs(Fragment, { children: [jsx(AnswerPreview.Separator, { isLight: true }, void 0), jsx(AnswerPreview.OptionDescription, { children: jsx(SlateViewWithData, { nodes: description, mode: "multiline", currentElementId: elementData.id }, void 0) }, void 0)] }, void 0)) : null] }, void 0) }, void 0), submissionDataValue.radio?.other &&
                            elementData.config.radio?.interface?.others &&
                            elementData.config.radio.interface.othersId ===
                                selectedOption.id ? (jsxs(Fragment, { children: [jsx(AnswerPreview.Separator, {}, void 0), jsx(AnswerPreview.UserInput, { children: submissionDataValue.radio.other }, void 0)] }, void 0)) : null] }, void 0));
            }
            return jsx("span", { children: __('Unknown', 'wp-eform') }, void 0);
        }
        return __('No options selected.', 'wp-eform');
    },
    getNumericValue(elementData, submissionDataValue) {
        const selectedOptionId = submissionDataValue.radio?.selected;
        if (selectedOptionId) {
            const selectedOption = elementData.config.radio?.interface?.options.find(op => op.id === selectedOptionId);
            return getFloatValue(selectedOption?.num);
        }
        return 0;
    },
    getPresetValue(elementData, defaultValue) {
        const newDefaultValue = fn(defaultValue, draftValue => {
            if (!isNullOrEmptyString(elementData.config.radio?.attributes.defaultValue)) {
                draftValue.radio.selected =
                    elementData.config.radio?.attributes.defaultValue;
            }
            // override if URL query parameter is used
            if (elementData.config.radio?.attributes.prefilType === PrefilEnum.URL) {
                const compareWith = getUrlParameterValue(window.location.search, elementData.config.radio.attributes.prefilParameter);
                if (compareWith) {
                    const possibleOptionIds = matchValuesAgainstOptionLabel(elementData.config.radio.interface?.options, compareWith);
                    if (possibleOptionIds.length) {
                        draftValue.radio.selected = possibleOptionIds.pop();
                    }
                }
            }
            // override if meta based query is used
            if (elementData.config.radio?.attributes.prefilType === PrefilEnum.META) {
                const decodedExtra = decodeJSONRecord(elementData.extras);
                if (decodedExtra && decodedExtra.metaValue) {
                    // meteValue would point to the option id, but make sure it is present
                    elementData.config.radio.interface?.options.forEach(op => {
                        if (op.id === decodedExtra.metaValue) {
                            draftValue.radio.selected = op.id;
                        }
                    });
                }
            }
        });
        return newDefaultValue;
    },
};

const CONTROLCLASS$7 = 'wpeform-component-button';
const BUTTONINNERCLASS = getBemElement(CONTROLCLASS$7, 'inner');
const BUTTONICONCLASS = getBemElement(CONTROLCLASS$7, 'icon');
const BUTTONTEXTCLASS = getBemElement(CONTROLCLASS$7, 'text');
const BUTTONLOADINGSPINNERBOUNCECLASS = getBemElement(CONTROLCLASS$7, 'bounce');
const StyledLoadingContainer = styled.div `
	position: absolute;
	left: 0;
	top: 0;
	bottom: 0;
	right: 0;
	display: flex;
	align-items: center;
	justify-content: center;
`;
const progressActiveKf = keyframes `
	0% {
			width: 0;
			opacity: .1
	}

	20% {
			width: 0;
			opacity: .5
	}

	to {
			width: 100%;
			opacity: 0
	}
`;
const bounceKf = keyframes `
	0%, 80%, 100% {
			transform: scale(0);
	}
	40% {
			transform: scale(1.0);
	}
`;
const LoadingProgressBackground = styled.div `
	position: absolute;
	height: 0.5em;
	left: 0;
	bottom: 0;
	width: 100%;
	background-color: rgba(0, 0, 0, 0.05);
`;
const AnimatedLoadingContainer = styled(animated.div) `
	will-change: width;
	position: absolute;
	height: 0.5em;
	left: 0;
	bottom: 0;
	background-color: rgba(0, 0, 0, 0.15);

	&.active {
		&::before {
			position: absolute;
			top: 0;
			right: 0;
			bottom: 0;
			left: 0;
			background: rgb(255, 255, 255);
			opacity: 0;
			animation: ${progressActiveKf} 1.6s cubic-bezier(0.23, 1, 0.32, 1)
				infinite;
			content: '';
		}
	}
`;
const LoadedIconContainer = styled(animated.div) `
	width: 3em;
	display: flex;
	align-items: center;
	justify-content: center;
	will-change: opacity, transform;
	position: relative;
	.${CONTROLCLASS$k} {
		font-size: 1.5em;
	}
`;
const LoadingSpinner = styled.div `
	width: 3em;
	display: flex;
	align-items: center;
	justify-content: space-between;
	transform: translateY(-0.25em);
	position: relative;
	top: 2px; /** Visual adjustment */
	.${BUTTONLOADINGSPINNERBOUNCECLASS} {
		width: 0.75em;
		height: 0.75em;
		border-radius: 100%;
		display: inline-block;
		background-color: rgba(255, 255, 255, 0.7);
		animation: ${bounceKf} 1.4s infinite ease-in-out both;

		&.one {
			animation-delay: -0.32s;
		}
		&.two {
			animation-delay: -0.16s;
		}
	}
`;
const StyledButton = styled.button `
	${cssReset};
	overflow: hidden;
	position: relative;
	display: inline-flex;
	justify-content: center;
	align-items: center;
	max-width: 100%;
	line-height: 1.2;
	cursor: pointer;
	text-decoration: none;

	&:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}

	.${BUTTONICONCLASS} {
		margin-right: 0.25em;
		width: 1.2em;
		text-align: center;
		line-height: 1;
		display: inline-flex;
		justify-content: center;
		align-items: center;

		&.${BUTTONICONCLASS}--after {
			margin-left: 0.25em;
			margin-right: 0;
		}
	}

	&.${CONTROLCLASS$7}--no-label {
		.${BUTTONICONCLASS} {
			margin-left: 0;
			margin-right: 0;
		}
	}

	.${BUTTONINNERCLASS} {
		display: flex;
		align-items: center;
		justify-content: center;
		flex-flow: row nowrap;
		overflow: hidden;
	}

	.${BUTTONTEXTCLASS} {
		max-width: 100%;
		white-space: pre;
		text-overflow: ellipsis;
	}

	&.${CONTROLCLASS$7}--has-icon {
		.${BUTTONTEXTCLASS} {
			max-width: calc(100% - 1.25em);
		}
	}

	&.${CONTROLCLASS$7}--is-loading {
		opacity: 1;
		.${BUTTONINNERCLASS} {
			opacity: 0;
		}
	}

	&:active:not(:disabled) {
		outline: none;
		.${BUTTONINNERCLASS} {
			transform: scale(0.97);
			transform-origin: center center;
		}
	}

	/** Rounded */
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	&.${CONTROLCLASS$7}--rounded {
		border-radius: ${props => numToCssSize((props.theme.controlHeightBase * 1.2) / 2)};
	}

	/** Sizes */
	padding: 0 1.75em;
	height: ${props => numToCssSize(props.theme.controlHeightBase * 1.2)};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	&.${CONTROLCLASS$7}--size-LARGE {
		height: ${props => numToCssSize(props.theme.controlHeightBase * 1.4)};
		font-size: ${props => numToCssSize(props.theme.fz.large1)};
		padding: 0 1.75em;

		&.${CONTROLCLASS$7}--rounded {
			border-radius: ${props => numToCssSize((props.theme.controlHeightBase * 1.4) / 2)};
		}
	}
	&.${CONTROLCLASS$7}--size-SMALL {
		height: ${props => numToCssSize(props.theme.controlHeightBase)};
		font-size: ${props => numToCssSize(props.theme.fz.small1)};
		padding: 0 1em;
		&.${CONTROLCLASS$7}--rounded {
			border-radius: ${props => numToCssSize(props.theme.controlHeightBase / 2)};
		}
	}
	&.${CONTROLCLASS$7}--size-TINY {
		height: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
		font-size: ${props => numToCssSize(props.theme.fz.small1)};
		padding: 0 0.8em;
		&.${CONTROLCLASS$7}--rounded {
			border-radius: ${props => numToCssSize(props.theme.controlHeightBase * 0.4)};
		}
	}

	/** Generic Animations */
	${LoadingProgressBackground} {
		background-color: ${props => curriedTransparentize(0.8, props.theme.borderColorBase)};
	}
	${AnimatedLoadingContainer} {
		background-color: ${props => curriedTransparentize(0.5, props.theme.borderColorBase)};
	}
	.${BUTTONLOADINGSPINNERBOUNCECLASS} {
		background-color: ${props => curriedTransparentize(0.5, props.theme.borderColorBase)};
	}
	${LoadedIconContainer} {
		color: ${props => curriedTransparentize(0.5, props.theme.borderColorBase)};
	}
	&.${CONTROLCLASS$7}--colorful {
		${LoadingProgressBackground} {
			background-color: ${props => curriedDarken(0.05, props.theme.primaryLightColor)};
		}
		${AnimatedLoadingContainer} {
			background-color: ${props => props.theme.primaryDarkColor};
		}
		.${BUTTONLOADINGSPINNERBOUNCECLASS} {
			background-color: ${props => props.theme.primaryDarkColor};
		}
		${LoadedIconContainer} {
			color: ${props => props.theme.primaryDarkColor};
		}
	}

	/** Styles, we have hard-dependency on the register for performance */
	/** Otherwise if we pass css prop, then a new class is created for every buttons */
	&.${CONTROLCLASS$7}--style-flat {
		background-color: ${props => props.theme.backgroundShade};
		color: ${props => props.theme.textColor};
		box-shadow: ${props => props.theme.boxShadowNoneFocus};
		border: 1px solid ${props => props.theme.backgroundShade};
		transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'color', 'box-shadow', 'border-color'], props.theme.transitionControl)};

		&:not(:disabled):hover,
		&:not(:disabled):focus,
		&:not(:disabled):active {
			background-color: ${props => props.theme.backgroundHover};
			border-color: ${props => props.theme.backgroundHover};
			color: ${props => props.theme.headingColor};
		}

		&:not(:disabled):focus,
		&:not(:disabled):active {
			border-color: ${props => props.theme.primaryColor};
		}
		&:not(:disabled):not(:active):focus {
			box-shadow: ${props => props.theme.boxShadowControlFocus};
		}

		&.${CONTROLCLASS$7}--colorful {
			background-color: ${props => props.theme.primaryColor};
			border-color: ${props => props.theme.primaryColor};
			color: ${props => props.theme.primaryBgText};

			&:not(:disabled):hover,
			&:not(:disabled):focus,
			&:not(:disabled):active {
				background-color: ${props => props.theme.primaryLightColor};
				border-color: ${props => props.theme.primaryLightColor};
				color: ${props => props.theme.primaryBgText};
			}

			&:not(:disabled):focus,
			&:not(:disabled):active {
				border-color: ${props => props.theme.primaryColor};
			}
		}
	}
	&.${CONTROLCLASS$7}--style-3d {
		background-color: ${props => props.theme.backgroundShade};
		color: ${props => props.theme.textColor};
		box-shadow: ${props => props.theme.boxShadowNoneFocus};
		border: 1px solid ${props => props.theme.backgroundShade};
		border-bottom: 0.1875em solid ${props => props.theme.borderColorBase};
		transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'color', 'box-shadow', 'border-color'], props.theme.transitionControl)};

		&:not(:disabled):hover,
		&:not(:disabled):focus,
		&:not(:disabled):active {
			background-color: ${props => props.theme.backgroundHover};
			border-color: ${props => props.theme.backgroundHover};
			border-bottom-color: ${props => props.theme.borderColorSplit};
			color: ${props => props.theme.headingColor};
		}

		&:not(:disabled):focus,
		&:not(:disabled):active {
			border-color: ${props => props.theme.primaryColor};
		}
		&:not(:disabled):not(:active):focus {
			box-shadow: ${props => props.theme.boxShadowControlFocus};
		}

		&:not(:disabled):active {
			border-bottom-width: 1px;
		}

		&.${CONTROLCLASS$7}--colorful {
			background-color: ${props => props.theme.primaryColor};
			border-color: ${props => props.theme.primaryColor};
			border-bottom-color: ${props => props.theme.primaryDarkColor};
			color: ${props => props.theme.primaryBgText};

			&:not(:disabled):hover,
			&:not(:disabled):focus,
			&:not(:disabled):active {
				background-color: ${props => props.theme.primaryLightColor};
				border-color: ${props => props.theme.primaryLightColor};
				border-bottom-color: ${props => props.theme.primaryColor};
				color: ${props => props.theme.primaryBgText};
			}

			&:not(:disabled):focus,
			&:not(:disabled):active {
				border-color: ${props => props.theme.primaryDarkColor};
			}
		}
	}
	&.${CONTROLCLASS$7}--style-gradient {
		background-color: ${props => curriedDarken(0.1, props.theme.backgroundShade)};
		background-image: linear-gradient(
			to bottom,
			${props => props.theme.backgroundHover},
			${props => curriedDarken(0.1, props.theme.backgroundShade)}
		);
		background-size: 100% 150%;
		background-position: bottom 0 left 0;
		color: ${props => props.theme.textColor};
		box-shadow: ${props => props.theme.boxShadowNoneFocus};
		border: 1px solid ${props => props.theme.borderColorBase};
		transition: ${props => getMultipleTransitionsWithWillChange(['background-position', 'color', 'box-shadow', 'border-color'], props.theme.transitionControl)};

		&:not(:disabled):hover,
		&:not(:disabled):focus,
		&:not(:disabled):active {
			background-position: top 0 left 0;
			color: ${props => props.theme.headingColor};
		}

		&:not(:disabled):focus,
		&:not(:disabled):active {
			border-color: ${props => props.theme.primaryColor};
		}
		&:not(:disabled):not(:active):focus {
			box-shadow: ${props => props.theme.boxShadowControlFocus};
		}

		&.${CONTROLCLASS$7}--colorful {
			background-color: ${props => props.theme.primaryColor};
			background-image: linear-gradient(
				to bottom,
				${props => props.theme.primaryLightColor},
				${props => curriedDarken(0.1, props.theme.primaryColor)}
			);
			border-color: ${props => props.theme.primaryDarkColor};
			color: ${props => props.theme.primaryBgText};

			&:not(:disabled):hover,
			&:not(:disabled):focus,
			&:not(:disabled):active {
				background-color: ${props => props.theme.primaryColor};
				border-color: ${props => props.theme.primaryDarkColor};
				color: ${props => props.theme.primaryBgText};
			}

			&:not(:disabled):focus,
			&:not(:disabled):active {
				border-color: ${props => props.theme.primaryDarkColor};
			}
		}
	}
	&.${CONTROLCLASS$7}--style-outline {
		background-color: ${props => props.theme.appBackgroundColor};
		color: ${props => props.theme.textColor};
		box-shadow: ${props => props.theme.boxShadowNoneFocus};
		border: 2px solid ${props => props.theme.borderColorBase};
		transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'color', 'box-shadow', 'border-color'], props.theme.transitionControl)};

		&:not(:disabled):hover,
		&:not(:disabled):focus,
		&:not(:disabled):active {
			border-color: ${props => props.theme.borderColorSplit};
			color: ${props => props.theme.headingColor};
		}

		&:not(:disabled):focus,
		&:not(:disabled):active {
			border-color: ${props => props.theme.primaryColor};
		}
		&:not(:disabled):not(:active):focus {
			box-shadow: ${props => props.theme.boxShadowControlFocus};
		}

		&.${CONTROLCLASS$7}--colorful {
			border-color: ${props => props.theme.primaryColor};
			color: ${props => props.theme.primaryDarkColor};
			background-color: ${props => props.theme.primaryBackgroundColor};

			&:not(:disabled):hover,
			&:not(:disabled):focus,
			&:not(:disabled):active {
				border-color: ${props => props.theme.primaryLightColor};
			}

			&:not(:disabled):focus,
			&:not(:disabled):active {
				border-color: ${props => props.theme.primaryDarkColor};
				color: ${props => props.theme.primaryDarkColor};
			}
		}
	}
	&.${CONTROLCLASS$7}--style-transparent {
		background-color: ${props => curriedTransparentize(1, props.theme.backgroundHover)};
		color: ${props => props.theme.textColor};
		box-shadow: none;
		border: 0 none;
		transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'color'], props.theme.transitionControl)};

		&:not(:disabled):hover,
		&:not(:disabled):focus,
		&:not(:disabled):active {
			background-color: ${props => props.theme.backgroundHover};
			color: ${props => props.theme.headingColor};
		}

		&:not(:disabled):focus,
		&:not(:disabled):active {
			background-color: ${props => props.theme.backgroundHover};
		}
		&:not(:disabled):not(:active):focus {
			background-color: ${props => props.theme.backgroundHover};
		}

		&.${CONTROLCLASS$7}--colorful {
			background-color: ${props => curriedTransparentize(1, props.theme.primaryBackgroundColor)};

			&:not(:disabled):hover,
			&:not(:disabled):focus,
			&:not(:disabled):active {
				background-color: ${props => props.theme.primaryBackgroundColor};
			}

			&:not(:disabled):focus,
			&:not(:disabled):active {
				background-color: ${props => props.theme.primaryBackgroundColor};
				color: ${props => props.theme.primaryDarkColor};
			}
		}
	}
`;
styled.div `
	display: flex;
	flex-flow: row wrap;
	align-items: center;
	justify-content: center;
	> .${CONTROLCLASS$7} {
		flex: 0 0 auto;
		margin: ${props => numToCssSize(props.theme.gutter / 4)};
	}
`;

function LoadingDone(props) {
    const { loadedState } = props;
    const theme = useTheme();
    const loadedIconStyle = useSpring({
        from: { opacity: 0, transform: 'scale(0, 0) translate(0, -0.25em)' },
        config: theme.springConfigGeneral,
        to: {
            opacity: 1,
            transform: 'scale(1, 1) translate(0, -0.25em)',
        },
    });
    return (jsx(LoadedIconContainer, Object.assign({ style: loadedIconStyle }, { children: jsx(Icon, { iconClass: loadedState === 'error' ? 'fas fa-exclamation' : 'fas fa-check' }, void 0) }), void 0));
}
function ButtonLoading(props) {
    const { loadingDone, loadedState } = props;
    const theme = useTheme();
    const [loadingWidth, setLoadingWidth] = useState$1(0);
    const loadingProgressStyle = useSpring({
        width: `${loadingWidth}%`,
        config: theme.springConfigSlow,
    });
    useEffect(() => {
        let isMounted = true;
        if (loadingDone) {
            setLoadingWidth(100);
            return () => {
                isMounted = false;
            };
        }
        setLoadingWidth(24);
        const intervalId = window.setInterval(() => {
            if (isMounted) {
                // 24, 50, 86, 96
                setLoadingWidth(w => {
                    if (w < 24) {
                        return 24;
                    }
                    if (w < 50) {
                        return 50;
                    }
                    if (w < 86) {
                        return 86;
                    }
                    return 96;
                });
            }
        }, 3000);
        return () => {
            isMounted = false;
            window.clearInterval(intervalId);
        };
    }, [loadingDone]);
    return (jsxs(StyledLoadingContainer, { children: [jsx(LoadingProgressBackground, {}, void 0), jsx(AnimatedLoadingContainer, { style: loadingProgressStyle, className: loadingDone ? '' : 'active' }, void 0), loadingDone ? (jsx(LoadingDone, { loadedState: loadedState }, void 0)) : (jsxs(LoadingSpinner, { children: [jsx("div", { className: classNames(BUTTONLOADINGSPINNERBOUNCECLASS, 'one') }, void 0), jsx("div", { className: classNames(BUTTONLOADINGSPINNERBOUNCECLASS, 'two') }, void 0), jsx("div", { className: classNames(BUTTONLOADINGSPINNERBOUNCECLASS, 'three') }, void 0)] }, void 0))] }, void 0));
}
/**
 * A Button Component specific for WP-EForm. This by default doesn't have much
 * styles. The style comes from `buttonStyles` collection from core.
 */
function Button$1(props) {
    const { size = GenericSizeEnum.DEFAULT, style, rounded = false, colorful = true, children, icon, disabled = false, iconPosition = 'before', onClick, className, loading, loadingDone = false, loadedState = 'success', asLink = false, href, linkTarget = '_self', title, } = props;
    const [addRipple, ripples] = useRipple({
        darkBg: colorful ? (style === 'outline' ? false : true) : false,
    });
    const buttonClass = getBemClassName(CONTROLCLASS$7, {
        rounded,
        colorful,
        [`size-${size}`]: true,
        [`style-${style}`]: true,
        'has-icon': !!icon,
        'is-loading': !!loading,
        'no-label': !children,
    }, className);
    const btnChildren = (jsxs(Fragment, { children: [ripples, jsxs("span", Object.assign({ className: BUTTONINNERCLASS }, { children: [icon && iconPosition === 'before' ? (jsx("span", Object.assign({ className: getBemClassName(BUTTONICONCLASS, { before: true }) }, { children: jsx(Icon, { iconClass: icon }, void 0) }), void 0)) : null, children ? jsx("span", Object.assign({ className: BUTTONTEXTCLASS }, { children: children }), void 0) : null, icon && iconPosition === 'after' ? (jsx("span", Object.assign({ className: getBemClassName(BUTTONICONCLASS, { after: true }) }, { children: jsx(Icon, { iconClass: icon }, void 0) }), void 0)) : null] }), void 0), loading ? (jsx(ButtonLoading, { loadingDone: loadingDone, loadedState: loadedState, colorful: colorful }, void 0)) : null] }, void 0));
    if (asLink && href) {
        return (jsx(StyledButton, Object.assign({ as: "a", href: href, className: buttonClass, onClick: (e) => {
                addRipple(e);
            }, target: linkTarget, title: title }, { children: btnChildren }), void 0));
    }
    return (jsx(StyledButton, Object.assign({ type: "button", className: buttonClass, onClick: e => {
            e.preventDefault();
            addRipple(e);
            if (onClick) {
                onClick(e);
            }
        }, disabled: disabled || loading === true, title: title }, { children: btnChildren }), void 0));
}

const CONTROLCLASS$6 = 'wpeform-component-buttongroup';
const ButtonsGroupContainer = styled.div `
	${cssReset};
	display: flex;
	flex-flow: row wrap;
	align-items: center;
	justify-content: center;
	margin-left: ${props => numToCssSize(props.theme.gutter / -4)};
	margin-right: ${props => numToCssSize(props.theme.gutter / -4)};
	> .${CONTROLCLASS$7} {
		flex: 0 0 auto;
		margin: ${props => numToCssSize(props.theme.gutter / 4)};
	}

	/** Align */
	&.${CONTROLCLASS$6}--align-LEFT {
		justify-content: flex-start;
	}
	&.${CONTROLCLASS$6}--align-CENTER {
		justify-content: center;
	}
	&.${CONTROLCLASS$6}--align-RIGHT {
		justify-content: flex-end;
	}
	&.${CONTROLCLASS$6}--align-JUSTIFY {
		justify-content: center;
		> .${CONTROLCLASS$7} {
			flex-grow: 1;
		}
	}

	/** Type */
	&.${CONTROLCLASS$6}--type-navbar {
		background-color: ${props => props.theme.backgroundShade};
		margin: 0;
		&.${CONTROLCLASS$6}--colorful {
			background-color: ${props => props.theme.primaryColor};
		}
		/** This type would style only flat buttons */
		padding: 0;
		> .${CONTROLCLASS$7}.${CONTROLCLASS$7}.${CONTROLCLASS$7}.${CONTROLCLASS$7}.${CONTROLCLASS$7} {
			margin: 0;
			border-radius: 0;
			position: relative;

			&:active,
			&:focus {
				z-index: 1;
			}
		}
	}
	&.${CONTROLCLASS$6}--type-regular {
		&.${CONTROLCLASS$6}--has-gutter-on-regular {
			padding: ${props => numToCssSize(props.theme.gutter)}
				${props => numToCssSize(props.theme.gutter * 1.5)};
		}
	}
`;
/**
 * A ButtonsGroup component to group and align multiple buttons.
 */
function ButtonsGroup(props) {
    const { type, align, children, colorful = false, className, hasGutterOnregular = false, } = props;
    return (jsx(ButtonsGroupContainer, Object.assign({ className: getBemClassName(CONTROLCLASS$6, {
            [`type-${type}`]: true,
            [`align-${align}`]: true,
            colorful,
            'has-gutter-on-regular': hasGutterOnregular,
        }, className) }, { children: children }), void 0));
}

const buttons = {
    id: 'buttons',
    hasSubmission: false,
    FormUi({ elementData }) {
        const formNavActions = useFormNavActions();
        return (jsx(ButtonsGroup, Object.assign({ className: elementData.appearance?.className, align: elementData.config.buttons?.interface?.alignment ??
                GenericAlignmentEnum.CENTER, type: "regular" }, { children: elementData.config.buttons?.buttons.map(bt => {
                const buttonType = bt.link === '#wpeform-prev'
                    ? 'prev'
                    : bt.link === '#wpeform-next'
                        ? 'next'
                        : bt.link === '#wpeform-submit'
                            ? 'submit'
                            : bt.link === '#wpeform-reset'
                                ? 'reset'
                                : 'custom';
                return (jsx(Button$1, Object.assign({ style: elementData.config.buttons?.interface?.style ?? 'flat', colorful: elementData.config.buttons?.interface?.colored, icon: bt.icon, iconPosition: bt.iconPosition === ButtonIconPositionEnum.AFTER
                        ? 'after'
                        : 'before', rounded: elementData.config.buttons?.interface?.rounded, size: elementData.config.buttons?.interface?.size, onClick: () => {
                        if (buttonType === 'prev') {
                            // if the link is to go previous
                            if (formNavActions.canPrevious) {
                                formNavActions.goPrevious();
                            }
                        }
                        else if (buttonType === 'next') {
                            // if to go next
                            if (formNavActions.canNext) {
                                formNavActions.goNext();
                            }
                        }
                        else if (buttonType === 'submit') {
                            // if to submit
                            if (formNavActions.canSubmit) {
                                formNavActions.submit();
                            }
                        }
                        else if (buttonType === 'reset') {
                            // if to reset
                            if (formNavActions.canReset) {
                                formNavActions.reset();
                            }
                        }
                        else {
                            // handle general links
                            const openType = elementData.config.buttons?.attributes?.open;
                            if (openType === ButtonOpenTypeEnum.SELF) {
                                // a simple redirect
                                window.location.href = bt.link;
                            }
                            else if (openType === ButtonOpenTypeEnum.BLANK) {
                                // open a new tab
                                window.open(bt.link, '_blank');
                            }
                            else {
                                // open a popup
                                const h = elementData.config.buttons?.attributes?.popupHeight ??
                                    600;
                                const w = elementData.config.buttons?.attributes?.popupWidth ?? 600;
                                const dualScreenLeft = window.screenLeft;
                                const dualScreenTop = window.screenTop;
                                const width = window.innerWidth;
                                const height = window.innerHeight;
                                const left = width / 2 - w / 2 + dualScreenLeft;
                                const top = height / 2 - h / 2 + dualScreenTop;
                                const newWindow = window.open(bt.link, 'wpeform-buttons-popup', `scrollbars=yes, width=${w}, height=${h}, top=${top}, left=${left}`);
                                if (newWindow && newWindow.focus) {
                                    newWindow.focus();
                                }
                            }
                        }
                    }, disabled: (buttonType === 'prev' && !formNavActions.canPrevious) ||
                        (buttonType === 'next' && !formNavActions.canNext) ||
                        (buttonType === 'submit' && !formNavActions.canSubmit) ||
                        (buttonType === 'reset' && !formNavActions.canReset), loading: buttonType === 'submit' && formNavActions.submitting, loadingDone: buttonType === 'submit' && formNavActions.submitted, loadedState: buttonType === 'submit'
                        ? formNavActions.submittedState === 'success'
                            ? 'success'
                            : 'error'
                        : undefined }, { children: jsx(SlateViewWithData, { mode: "singleline", nodes: getNodesFromJSON(bt.label), currentElementId: elementData.id }, void 0) }), bt.id));
            }) }), void 0));
    },
    getErrors() {
        // a buttons has no errors
        return [];
    },
    isQuestion: false,
    isRequired() {
        // a buttons is never required
        return false;
    },
    setValue() { },
    isConditionTrue() {
        return true;
    },
};

const defaultExtras = {
    numOne: 7,
    numTwo: 4,
    operation: 'add',
    result: 11,
    encrypted: '',
};
const captcha = {
    id: 'captcha',
    hasSubmission: true,
    FormUi({ id, elementData, submissionData, updateSubmissionData, setElementTouched, controlType, controlAlignment, hasError = false, }) {
        let extrasData;
        if (elementData.extras) {
            try {
                extrasData = JSON.parse(elementData.extras);
            }
            catch (e) {
                extrasData = defaultExtras;
            }
        }
        else {
            extrasData = defaultExtras;
        }
        const value = submissionData.value.captcha?.solved ?? '';
        const onChange = useCallback$1((newValue) => {
            const newSubmissionData = fn(submissionData, draftState => {
                draftState.value.captcha.solved = newValue;
                draftState.value.captcha.encrypted = extrasData.encrypted;
            });
            updateSubmissionData(newSubmissionData);
        }, [updateSubmissionData, submissionData, extrasData.encrypted]);
        return (jsx(Text$2, { id: id, controlType: controlType, controlAlignment: controlAlignment, value: value, onChange: onChange, onBlur: () => {
                setElementTouched(true);
            }, hasError: hasError, placeholder: jsx("strong", { children: sprintf(__('%d %s %d = ?', 'wp-eform'), extrasData.numOne, extrasData.operation === 'add' ? '+' : '-', extrasData.numTwo) }, void 0), prefix: jsx(Icon, { iconClass: `fas fa-${extrasData.operation === 'add' ? 'plus' : 'minus'}-square` }, void 0), type: "tel" }, void 0));
    },
    getErrors(elementData, submissionDataValue) {
        const errors = [];
        let extrasData;
        if (elementData.extras) {
            try {
                extrasData = JSON.parse(elementData.extras);
            }
            catch (e) {
                extrasData = defaultExtras;
            }
        }
        else {
            extrasData = defaultExtras;
        }
        // if input is empty
        if (!submissionDataValue.captcha?.solved) {
            errors.push(validationMessages.requiredCaptcha);
        }
        // if result does not match
        if (submissionDataValue.captcha?.solved &&
            submissionDataValue.captcha?.solved !== extrasData.result.toString()) {
            errors.push(sprintf(validationMessages.incorrectCaptcha, extrasData.result));
        }
        return errors;
    },
    isQuestion: true,
    isRequired() {
        // a captcha is always required
        return true;
    },
    // no need for captcha element to have set value
    setValue() { },
};

var lib = {};

var Range$1 = {};

var utils = {};

var types = {};

(function (exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.Direction = void 0;
(function (Direction) {
    Direction["Right"] = "to right";
    Direction["Left"] = "to left";
    Direction["Down"] = "to bottom";
    Direction["Up"] = "to top";
})(exports.Direction || (exports.Direction = {}));
}(types));

(function (exports) {
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useThumbOverlap = exports.assertUnreachable = exports.voidFn = exports.getTrackBackground = exports.replaceAt = exports.schd = exports.translate = exports.getClosestThumbIndex = exports.translateThumbs = exports.getPaddingAndBorder = exports.getMargin = exports.checkInitialOverlap = exports.checkValuesAgainstBoundaries = exports.checkBoundaries = exports.isVertical = exports.relativeValue = exports.normalizeValue = exports.isStepDivisible = exports.isTouchEvent = exports.getStepDecimals = void 0;
var react_1 = React__default;
var types_1 = types;
var getStepDecimals = function (step) {
    var decimals = step.toString().split('.')[1];
    return decimals ? decimals.length : 0;
};
exports.getStepDecimals = getStepDecimals;
function isTouchEvent(event) {
    return ((event.touches && event.touches.length) ||
        (event.changedTouches && event.changedTouches.length));
}
exports.isTouchEvent = isTouchEvent;
function isStepDivisible(min, max, step) {
    var res = (max - min) / step;
    return parseInt(res.toString(), 10) === res;
}
exports.isStepDivisible = isStepDivisible;
function normalizeValue(value, index, min, max, step, allowOverlap, values) {
    var BIG_NUM = 10e10;
    value = Math.round(value * BIG_NUM) / BIG_NUM;
    if (!allowOverlap) {
        var prev = values[index - 1];
        var next = values[index + 1];
        if (prev && prev > value)
            return prev;
        if (next && next < value)
            return next;
    }
    if (value > max)
        return max;
    if (value < min)
        return min;
    // `remainder` is a difference between the given value and a full step value
    // that is closest lower to the given value and is in the range between the min value
    // and the given value
    var remainder = Math.floor(value * BIG_NUM - min * BIG_NUM) %
        Math.floor(step * BIG_NUM);
    var closestLowerNum = Math.floor(value * BIG_NUM - Math.abs(remainder));
    var rounded = remainder === 0 ? value : closestLowerNum / BIG_NUM;
    // Values with a remainder `< step/2` are rounded to the closest lower value
    // while values with a remainder `= > step/2` are rounded to the closest bigger value
    var res = Math.abs(remainder / BIG_NUM) < step / 2
        ? rounded
        : rounded + step;
    var decimalPlaces = exports.getStepDecimals(step);
    return parseFloat(res.toFixed(decimalPlaces));
}
exports.normalizeValue = normalizeValue;
function relativeValue(value, min, max) {
    return (value - min) / (max - min);
}
exports.relativeValue = relativeValue;
function isVertical(direction) {
    return direction === types_1.Direction.Up || direction === types_1.Direction.Down;
}
exports.isVertical = isVertical;
function checkBoundaries(value, min, max) {
    if (min >= max) {
        throw new RangeError("min (" + min + ") is equal/bigger than max (" + max + ")");
    }
    if (value < min) {
        throw new RangeError("value (" + value + ") is smaller than min (" + min + ")");
    }
    if (value > max) {
        throw new RangeError("value (" + value + ") is bigger than max (" + max + ")");
    }
}
exports.checkBoundaries = checkBoundaries;
function checkValuesAgainstBoundaries(value, min, max) {
    if (value < min) {
        // set selectedValue to min
        return min;
    }
    if (value > max) {
        // set selectedValue to max
        return max;
    }
    else {
        return value;
    }
}
exports.checkValuesAgainstBoundaries = checkValuesAgainstBoundaries;
function checkInitialOverlap(values) {
    if (values.length < 2)
        return;
    if (!values.slice(1).every(function (item, i) { return values[i] <= item; })) {
        throw new RangeError("values={[" + values + "]} needs to be sorted when allowOverlap={false}");
    }
}
exports.checkInitialOverlap = checkInitialOverlap;
function getMargin(element) {
    var style = window.getComputedStyle(element);
    return {
        top: parseInt(style['margin-top'], 10),
        bottom: parseInt(style['margin-bottom'], 10),
        left: parseInt(style['margin-left'], 10),
        right: parseInt(style['margin-right'], 10)
    };
}
exports.getMargin = getMargin;
function getPaddingAndBorder(element) {
    var style = window.getComputedStyle(element);
    return {
        top: parseInt(style['padding-top'], 10) + parseInt(style['border-top-width'], 10),
        bottom: parseInt(style['padding-bottom'], 10) + parseInt(style['border-bottom-width'], 10),
        left: parseInt(style['padding-left'], 10) + parseInt(style['border-left-width'], 10),
        right: parseInt(style['padding-right'], 10) + parseInt(style['border-right-width'], 10),
    };
}
exports.getPaddingAndBorder = getPaddingAndBorder;
function translateThumbs(elements, offsets, rtl) {
    var inverter = rtl ? -1 : 1;
    elements.forEach(function (element, index) {
        return translate(element, inverter * offsets[index].x, offsets[index].y);
    });
}
exports.translateThumbs = translateThumbs;
/**
 * Util function for calculating the index of the thumb that is closes to a given position
 * @param thumbs - array of Thumb element to calculate the distance from
 * @param clientX - target x position (mouse/touch)
 * @param clientY - target y position (mouse/touch)
 * @param direction - the direction of the track
 */
function getClosestThumbIndex(thumbs, clientX, clientY, direction) {
    var thumbIndex = 0;
    var minThumbDistance = getThumbDistance(thumbs[0], clientX, clientY, direction);
    for (var i = 1; i < thumbs.length; i++) {
        var thumbDistance = getThumbDistance(thumbs[i], clientX, clientY, direction);
        if (thumbDistance < minThumbDistance) {
            minThumbDistance = thumbDistance;
            thumbIndex = i;
        }
    }
    return thumbIndex;
}
exports.getClosestThumbIndex = getClosestThumbIndex;
function translate(element, x, y) {
    element.style.transform = "translate(" + x + "px, " + y + "px)";
}
exports.translate = translate;
// adapted from https://github.com/alexreardon/raf-schd
var schd = function (fn) {
    var lastArgs = [];
    var frameId = null;
    var wrapperFn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        lastArgs = args;
        if (frameId) {
            return;
        }
        frameId = requestAnimationFrame(function () {
            frameId = null;
            fn.apply(void 0, lastArgs);
        });
    };
    return wrapperFn;
};
exports.schd = schd;
function replaceAt(values, index, value) {
    var ret = values.slice(0);
    ret[index] = value;
    return ret;
}
exports.replaceAt = replaceAt;
function getTrackBackground(_a) {
    var values = _a.values, colors = _a.colors, min = _a.min, max = _a.max, _b = _a.direction, direction = _b === void 0 ? types_1.Direction.Right : _b, _c = _a.rtl, rtl = _c === void 0 ? false : _c;
    if (rtl && direction === types_1.Direction.Right) {
        direction = types_1.Direction.Left;
    }
    else if (rtl && types_1.Direction.Left) {
        direction = types_1.Direction.Right;
    }
    // sort values ascending
    var progress = values.slice(0).sort(function (a, b) { return a - b; }).map(function (value) { return ((value - min) / (max - min)) * 100; });
    var middle = progress.reduce(function (acc, point, index) {
        return acc + ", " + colors[index] + " " + point + "%, " + colors[index + 1] + " " + point + "%";
    }, '');
    return "linear-gradient(" + direction + ", " + colors[0] + " 0%" + middle + ", " + colors[colors.length - 1] + " 100%)";
}
exports.getTrackBackground = getTrackBackground;
function voidFn() { }
exports.voidFn = voidFn;
function assertUnreachable(x) {
    throw new Error("Didn't expect to get here");
}
exports.assertUnreachable = assertUnreachable;
/**
 * Util function for grabbing the true largest width of a thumb
 * including the label
 * @param thumbEl - Thumb element to grab the largest width from
 * @param value - Thumb value, not label value
 * @param separator - Label separator value
 */
var getThumbWidth = function (thumbEl, value, separator, decimalPlaces, valueToLabel) {
    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }
    var width = Math.ceil(__spreadArrays([thumbEl], Array.from(thumbEl.children)).reduce(function (width, el) {
        var elWidth = Math.ceil(el.getBoundingClientRect().width);
        /**
         * If a label contains a merged label value, it won't return the true
         * label width for that Thumb. Clone the label and change the value
         * to that individual Thumb value in order to grab the true width.
         */
        if (el.innerText &&
            el.innerText.includes(separator) &&
            el.childElementCount === 0) {
            var elClone = el.cloneNode(true);
            elClone.innerHTML = valueToLabel(value.toFixed(decimalPlaces));
            elClone.style.visibility = 'hidden';
            document.body.appendChild(elClone);
            elWidth = Math.ceil(elClone.getBoundingClientRect().width);
            document.body.removeChild(elClone);
        }
        return elWidth > width ? elWidth : width;
    }, thumbEl.getBoundingClientRect().width));
    return width;
};
/**
 * Bulk of logic for thumb overlaps
 * Consider a scenario with 5 thumbs;
 * Thumb 1 overlaps with thumb 0 and thumb 2
 * Thumb 2 overlaps with thumb 3
 * We need an array that contains [0, 1, 2, 3]
 * The function needs to return the directly overlapping thumbs
 * and all thumbs overlapping linked to those and so on
 * @param index - Thumb index calculating overlaps for
 * @param offsets - Current Array of Thumb offsets for Range
 * @param thumbs - Array of Thumb elements
 * @param values - Array of Thumb values
 * @param separator - String separator for merged label values
 * @returns overlaps - Array of all overlapping thumbs from the index
 */
var getOverlaps = function (index, offsets, thumbs, values, separator, decimalPlaces, valueToLabel) {
    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }
    var overlaps = [];
    /**
     * Recursive function for building the overlaps Array
     * If an overlap is found, find the overlaps for that overlap
     * @param thumbIndex current Thumb index to find overlaps from
     */
    var buildOverlaps = function (thumbIndex) {
        var thumbXWidth = getThumbWidth(thumbs[thumbIndex], values[thumbIndex], separator, decimalPlaces, valueToLabel);
        var thumbX = offsets[thumbIndex].x;
        /**
         * Iterate through the Thumb offsets, if there is a match
         * add the thumbIndex and siblingIndex to the overlaps Array
         *
         * Then build overlaps from the overlapping siblingIndex
         */
        offsets.forEach(function (_a, siblingIndex) {
            var siblingX = _a.x;
            var siblingWidth = getThumbWidth(thumbs[siblingIndex], values[siblingIndex], separator, decimalPlaces, valueToLabel);
            if (thumbIndex !== siblingIndex &&
                ((thumbX >= siblingX && thumbX <= siblingX + siblingWidth) ||
                    (thumbX + thumbXWidth >= siblingX &&
                        thumbX + thumbXWidth <= siblingX + siblingWidth))) {
                if (!overlaps.includes(siblingIndex)) {
                    overlaps.push(thumbIndex);
                    overlaps.push(siblingIndex);
                    overlaps = __spreadArrays(overlaps, [thumbIndex, siblingIndex]);
                    buildOverlaps(siblingIndex);
                }
            }
        });
    };
    buildOverlaps(index);
    // Sort and remove duplicates from the built overlaps
    return Array.from(new Set(overlaps.sort()));
};
/**
 * A custom React Hook for calculating whether a thumb overlaps
 * another and whether labels could/should merge.
 * @param rangeRef - React ref value of Range component
 * @param values - current Range values Array
 * @param index - thumb index
 * @param step - step value, used to calculate the number of decimal places
 * @param separator - string to separate thumb values
 * @returns label value + styling for thumb label
 */
var useThumbOverlap = function (rangeRef, values, index, step, separator, valueToLabel) {
    if (step === void 0) { step = 0.1; }
    if (separator === void 0) { separator = ' - '; }
    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }
    var decimalPlaces = exports.getStepDecimals(step);
    // Create initial label style and value. Label value defaults to thumb value
    var _a = react_1.useState({}), labelStyle = _a[0], setLabelStyle = _a[1];
    var _b = react_1.useState(valueToLabel(values[index].toFixed(decimalPlaces))), labelValue = _b[0], setLabelValue = _b[1];
    // When the rangeRef or values change, update the Thumb label values and styling
    react_1.useEffect(function () {
        if (rangeRef) {
            var thumbs = rangeRef.getThumbs();
            if (thumbs.length < 1)
                return;
            var newStyle = {};
            var offsets_1 = rangeRef.getOffsets();
            /**
             * Get any overlaps for the given Thumb index. This must return all linked
             * Thumbs. So if there are 4 Thumbs and Thumbs 2, 3 and 4 overlap. If we are
             * getting the overlaps for Thumb 1 and it overlaps only Thumb 2, we must get
             * 2, 3 and 4 also.
             */
            var overlaps = getOverlaps(index, offsets_1, thumbs, values, separator, decimalPlaces, valueToLabel);
            // Set a default label value of the Thumb value
            var labelValue_1 = valueToLabel(values[index].toFixed(decimalPlaces));
            /**
             * If there are overlaps for the Thumb, we need to calculate the correct
             * Label value along with the relevant styling. We only want to show a Label
             * for the left most Thumb in an overlapping set.
             * All other Thumbs will be set to display: none.
             */
            if (overlaps.length) {
                /**
                 * Get an Array of the offsets for the overlapping Thumbs
                 * This is so we can determine if the Thumb we are looking at
                 * is the left most thumb in an overlapping set
                 */
                var offsetsX = overlaps.reduce(function (a, c, i, s) {
                    return a.length ? __spreadArrays(a, [offsets_1[s[i]].x]) : [offsets_1[s[i]].x];
                }, []);
                /**
                 * If our Thumb is the left most Thumb, we can build a Label value
                 * and set the style for that Label
                 */
                if (Math.min.apply(Math, offsetsX) === offsets_1[index].x) {
                    /**
                     * First calculate the Label value. To do this,
                     * grab all the values for the Thumbs in our overlaps.
                     * Then convert that to a Set and sort it whilst removing duplicates.
                     */
                    var labelValues_1 = [];
                    overlaps.forEach(function (thumb) {
                        labelValues_1.push(values[thumb].toFixed(decimalPlaces));
                    });
                    /**
                     *  Update the labelValue with the resulting Array
                     *  joined by our defined separator
                     */
                    labelValue_1 = Array.from(new Set(labelValues_1.sort(function (a, b) { return parseFloat(a) - parseFloat(b); })))
                        .map(valueToLabel)
                        .join(separator);
                    /**
                     * Lastly, build the label styling. The label styling will
                     * position the label and apply a transform so that it's centered.
                     * We want the center point between the left edge of the left most Thumb
                     * and the right edge of the right most Thumb.
                     */
                    var first = Math.min.apply(Math, offsetsX);
                    var last = Math.max.apply(Math, offsetsX);
                    var lastWidth = thumbs[overlaps[offsetsX.indexOf(last)]].getBoundingClientRect().width;
                    newStyle.left = Math.abs(first - (last + lastWidth)) / 2 + "px";
                    newStyle.transform = 'translate(-50%, 0)';
                }
                else {
                    // If the Thumb isn't the left most Thumb, hide the Label!
                    newStyle.visibility = 'hidden';
                }
            }
            // Update the label value and style
            setLabelValue(labelValue_1);
            setLabelStyle(newStyle);
        }
    }, [rangeRef, values]);
    return [labelValue, labelStyle];
};
exports.useThumbOverlap = useThumbOverlap;
/**
 * Util function for calculating the distance of the center of a thumb
 * form a given mouse/touch target's position
 * @param thumbEl - Thumb element to calculate the distance from
 * @param clientX - target x position (mouse/touch)
 * @param clientY - target y position (mouse/touch)
 * @param direction - the direction of the track
 */
function getThumbDistance(thumbEl, clientX, clientY, direction) {
    var _a = thumbEl.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height;
    return isVertical(direction) ? Math.abs(clientY - (top + height / 2)) : Math.abs(clientX - (left + width / 2));
}
}(utils));

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (undefined && undefined.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (undefined && undefined.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (undefined && undefined.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(Range$1, "__esModule", { value: true });
var React = __importStar(React__default);
var utils_1 = utils;
var types_1 = types;
var INCREASE_KEYS = ['ArrowRight', 'ArrowUp', 'k', 'PageUp'];
var DECREASE_KEYS = ['ArrowLeft', 'ArrowDown', 'j', 'PageDown'];
var Range = /** @class */ (function (_super) {
    __extends(Range, _super);
    function Range(props) {
        var _this = _super.call(this, props) || this;
        _this.trackRef = React.createRef();
        _this.thumbRefs = [];
        _this.markRefs = [];
        _this.state = {
            draggedTrackPos: [-1, -1],
            draggedThumbIndex: -1,
            thumbZIndexes: new Array(_this.props.values.length).fill(0).map(function (t, i) { return i; }),
            isChanged: false,
            markOffsets: []
        };
        _this.getOffsets = function () {
            var _a = _this.props, direction = _a.direction, values = _a.values, min = _a.min, max = _a.max;
            var trackElement = _this.trackRef.current;
            var trackRect = trackElement.getBoundingClientRect();
            var trackPadding = utils_1.getPaddingAndBorder(trackElement);
            return _this.getThumbs().map(function (thumb, index) {
                var thumbOffsets = { x: 0, y: 0 };
                var thumbRect = thumb.getBoundingClientRect();
                var thumbMargins = utils_1.getMargin(thumb);
                switch (direction) {
                    case types_1.Direction.Right:
                        thumbOffsets.x = (thumbMargins.left + trackPadding.left) * -1;
                        thumbOffsets.y =
                            ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;
                        thumbOffsets.x +=
                            trackRect.width * utils_1.relativeValue(values[index], min, max) -
                                thumbRect.width / 2;
                        return thumbOffsets;
                    case types_1.Direction.Left:
                        thumbOffsets.x = (thumbMargins.right + trackPadding.right) * -1;
                        thumbOffsets.y =
                            ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;
                        thumbOffsets.x +=
                            trackRect.width -
                                trackRect.width * utils_1.relativeValue(values[index], min, max) -
                                thumbRect.width / 2;
                        return thumbOffsets;
                    case types_1.Direction.Up:
                        thumbOffsets.x =
                            ((thumbRect.width - trackRect.width) / 2 +
                                thumbMargins.left +
                                trackPadding.left) *
                                -1;
                        thumbOffsets.y = -trackPadding.left;
                        thumbOffsets.y +=
                            trackRect.height -
                                trackRect.height * utils_1.relativeValue(values[index], min, max) -
                                thumbRect.height / 2;
                        return thumbOffsets;
                    case types_1.Direction.Down:
                        thumbOffsets.x =
                            ((thumbRect.width - trackRect.width) / 2 +
                                thumbMargins.left +
                                trackPadding.left) *
                                -1;
                        thumbOffsets.y = -trackPadding.left;
                        thumbOffsets.y +=
                            trackRect.height * utils_1.relativeValue(values[index], min, max) -
                                thumbRect.height / 2;
                        return thumbOffsets;
                    default:
                        return utils_1.assertUnreachable(direction);
                }
            });
        };
        _this.getThumbs = function () {
            if (_this.trackRef && _this.trackRef.current) {
                return Array.from(_this.trackRef.current.children).filter(function (el) {
                    return el.hasAttribute('aria-valuenow');
                });
            }
            console.warn('No thumbs found in the track container. Did you forget to pass & spread the `props` param in renderTrack?');
            return [];
        };
        _this.getTargetIndex = function (e) {
            return _this.getThumbs().findIndex(function (child) { return child === e.target || child.contains(e.target); });
        };
        _this.addTouchEvents = function (e) {
            document.addEventListener('touchmove', _this.schdOnTouchMove, {
                passive: false
            });
            document.addEventListener('touchend', _this.schdOnEnd, {
                passive: false
            });
            document.addEventListener('touchcancel', _this.schdOnEnd, {
                passive: false
            });
        };
        _this.addMouseEvents = function (e) {
            document.addEventListener('mousemove', _this.schdOnMouseMove);
            document.addEventListener('mouseup', _this.schdOnEnd);
        };
        _this.onMouseDownTrack = function (e) {
            var _a;
            if (e.button !== 0)
                return;
            e.persist();
            e.preventDefault();
            _this.addMouseEvents(e.nativeEvent);
            if (_this.props.values.length > 1 && _this.props.draggableTrack) {
                if (_this.thumbRefs.some(function (thumbRef) { var _a; return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target); }))
                    return;
                // handle dragging the whole track
                _this.setState({
                    draggedTrackPos: [e.clientX, e.clientY]
                }, function () { return _this.onMove(e.clientX, e.clientY); });
            }
            else {
                // get the index of the thumb that is closest to the place where the track is clicked
                var draggedThumbIndex = utils_1.getClosestThumbIndex(_this.thumbRefs.map(function (t) { return t.current; }), e.clientX, e.clientY, _this.props.direction);
                // move the thumb which is closest to the place where the track is clicked
                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();
                _this.setState({
                    draggedThumbIndex: draggedThumbIndex
                }, function () { return _this.onMove(e.clientX, e.clientY); });
            }
        };
        _this.onResize = function () {
            utils_1.translateThumbs(_this.getThumbs(), _this.getOffsets(), _this.props.rtl);
            _this.calculateMarkOffsets();
        };
        _this.onTouchStartTrack = function (e) {
            var _a;
            e.persist();
            _this.addTouchEvents(e.nativeEvent);
            if (_this.props.values.length > 1 && _this.props.draggableTrack) {
                if (_this.thumbRefs.some(function (thumbRef) { var _a; return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target); }))
                    return;
                // handle dragging the whole track
                _this.setState({
                    draggedTrackPos: [e.touches[0].clientX, e.touches[0].clientY]
                }, function () { return _this.onMove(e.touches[0].clientX, e.touches[0].clientY); });
            }
            else {
                // get the index of the thumb that is closest to the place where the track is clicked
                var draggedThumbIndex = utils_1.getClosestThumbIndex(_this.thumbRefs.map(function (t) { return t.current; }), e.touches[0].clientX, e.touches[0].clientY, _this.props.direction);
                // move the thumb which is closest to the place where the track is clicked
                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();
                _this.setState({
                    draggedThumbIndex: draggedThumbIndex
                }, function () { return _this.onMove(e.touches[0].clientX, e.touches[0].clientY); });
            }
        };
        _this.onMouseOrTouchStart = function (e) {
            if (_this.props.disabled)
                return;
            var isTouch = utils_1.isTouchEvent(e);
            if (!isTouch && e.button !== 0)
                return;
            var index = _this.getTargetIndex(e);
            if (index === -1)
                return;
            if (isTouch) {
                _this.addTouchEvents(e);
            }
            else {
                _this.addMouseEvents(e);
            }
            _this.setState({
                draggedThumbIndex: index,
                thumbZIndexes: _this.state.thumbZIndexes.map(function (t, i) {
                    if (i === index) {
                        return Math.max.apply(Math, _this.state.thumbZIndexes);
                    }
                    return t <= _this.state.thumbZIndexes[index] ? t : t - 1;
                })
            });
        };
        _this.onMouseMove = function (e) {
            e.preventDefault();
            _this.onMove(e.clientX, e.clientY);
        };
        _this.onTouchMove = function (e) {
            e.preventDefault();
            _this.onMove(e.touches[0].clientX, e.touches[0].clientY);
        };
        _this.onKeyDown = function (e) {
            var _a = _this.props, values = _a.values, onChange = _a.onChange, step = _a.step, rtl = _a.rtl;
            var isChanged = _this.state.isChanged;
            var index = _this.getTargetIndex(e.nativeEvent);
            var inverter = rtl ? -1 : 1;
            if (index === -1)
                return;
            if (INCREASE_KEYS.includes(e.key)) {
                e.preventDefault();
                _this.setState({
                    draggedThumbIndex: index,
                    isChanged: true
                });
                onChange(utils_1.replaceAt(values, index, _this.normalizeValue(values[index] + inverter * (e.key === 'PageUp' ? step * 10 : step), index)));
            }
            else if (DECREASE_KEYS.includes(e.key)) {
                e.preventDefault();
                _this.setState({
                    draggedThumbIndex: index,
                    isChanged: true
                });
                onChange(utils_1.replaceAt(values, index, _this.normalizeValue(values[index] -
                    inverter * (e.key === 'PageDown' ? step * 10 : step), index)));
            }
            else if (e.key === 'Tab') {
                _this.setState({ draggedThumbIndex: -1 }, function () {
                    // If key pressed when thumb was moving, fire onFinalChange
                    if (isChanged) {
                        _this.fireOnFinalChange();
                    }
                });
            }
            else {
                if (isChanged) {
                    _this.fireOnFinalChange();
                }
            }
        };
        _this.onKeyUp = function (e) {
            var isChanged = _this.state.isChanged;
            _this.setState({
                draggedThumbIndex: -1
            }, function () {
                if (isChanged) {
                    _this.fireOnFinalChange();
                }
            });
        };
        _this.onMove = function (clientX, clientY) {
            var _a = _this.state, draggedThumbIndex = _a.draggedThumbIndex, draggedTrackPos = _a.draggedTrackPos;
            var _b = _this.props, direction = _b.direction, min = _b.min, max = _b.max, onChange = _b.onChange, values = _b.values, step = _b.step, rtl = _b.rtl;
            if (draggedThumbIndex === -1 &&
                draggedTrackPos[0] === -1 &&
                draggedTrackPos[1] === -1)
                return null;
            var trackElement = _this.trackRef.current;
            // If component was closed down prematurely, A last onMove could be triggered based on requestAnimationFrame()
            if (!trackElement)
                return null;
            var trackRect = trackElement.getBoundingClientRect();
            var trackLength = utils_1.isVertical(direction)
                ? trackRect.height
                : trackRect.width;
            if (draggedTrackPos[0] !== -1 && draggedTrackPos[1] !== -1) {
                // calculate how much it moved since the last update
                var dX = clientX - draggedTrackPos[0];
                var dY = clientY - draggedTrackPos[1];
                // calculate the delta of the value
                var deltaValue = 0;
                switch (direction) {
                    case types_1.Direction.Right:
                    case types_1.Direction.Left:
                        deltaValue = (dX / trackLength) * (max - min);
                        break;
                    case types_1.Direction.Down:
                    case types_1.Direction.Up:
                        deltaValue = (dY / trackLength) * (max - min);
                        break;
                    default:
                        utils_1.assertUnreachable(direction);
                }
                // invert for RTL
                if (rtl) {
                    deltaValue *= -1;
                }
                if (Math.abs(deltaValue) >= step / 2) {
                    // adjust delta so it fits into the range
                    for (var i = 0; i < _this.thumbRefs.length; i++) {
                        if ((values[i] === max && Math.sign(deltaValue) === 1) ||
                            (values[i] === min && Math.sign(deltaValue) === -1))
                            return;
                        var thumbValue = values[i] + deltaValue;
                        if (thumbValue > max)
                            deltaValue = max - values[i];
                        else if (thumbValue < min)
                            deltaValue = min - values[i];
                    }
                    // add the delta to each thumb
                    var newValues = values.slice(0);
                    for (var i = 0; i < _this.thumbRefs.length; i++) {
                        newValues = utils_1.replaceAt(newValues, i, _this.normalizeValue(values[i] + deltaValue, i));
                    }
                    _this.setState({
                        draggedTrackPos: [clientX, clientY]
                    });
                    onChange(newValues);
                }
            }
            else {
                var newValue = 0;
                switch (direction) {
                    case types_1.Direction.Right:
                        newValue =
                            ((clientX - trackRect.left) / trackLength) * (max - min) + min;
                        break;
                    case types_1.Direction.Left:
                        newValue =
                            ((trackLength - (clientX - trackRect.left)) / trackLength) *
                                (max - min) +
                                min;
                        break;
                    case types_1.Direction.Down:
                        newValue =
                            ((clientY - trackRect.top) / trackLength) * (max - min) + min;
                        break;
                    case types_1.Direction.Up:
                        newValue =
                            ((trackLength - (clientY - trackRect.top)) / trackLength) *
                                (max - min) +
                                min;
                        break;
                    default:
                        utils_1.assertUnreachable(direction);
                }
                // invert for RTL
                if (rtl) {
                    newValue = max + min - newValue;
                }
                if (Math.abs(values[draggedThumbIndex] - newValue) >= step / 2) {
                    onChange(utils_1.replaceAt(values, draggedThumbIndex, _this.normalizeValue(newValue, draggedThumbIndex)));
                }
            }
        };
        _this.normalizeValue = function (value, index) {
            var _a = _this.props, min = _a.min, max = _a.max, step = _a.step, allowOverlap = _a.allowOverlap, values = _a.values;
            return utils_1.normalizeValue(value, index, min, max, step, allowOverlap, values);
        };
        _this.onEnd = function (e) {
            e.preventDefault();
            document.removeEventListener('mousemove', _this.schdOnMouseMove);
            document.removeEventListener('touchmove', _this.schdOnTouchMove);
            document.removeEventListener('mouseup', _this.schdOnEnd);
            document.removeEventListener('touchend', _this.schdOnEnd);
            document.removeEventListener('touchcancel', _this.schdOnEnd);
            if (_this.state.draggedThumbIndex === -1 &&
                _this.state.draggedTrackPos[0] === -1 &&
                _this.state.draggedTrackPos[1] === -1)
                return null;
            _this.setState({ draggedThumbIndex: -1, draggedTrackPos: [-1, -1] }, function () {
                _this.fireOnFinalChange();
            });
        };
        _this.fireOnFinalChange = function () {
            _this.setState({ isChanged: false });
            var _a = _this.props, onFinalChange = _a.onFinalChange, values = _a.values;
            if (onFinalChange) {
                onFinalChange(values);
            }
        };
        _this.calculateMarkOffsets = function () {
            if (!_this.props.renderMark ||
                !_this.trackRef ||
                _this.trackRef.current === null)
                return;
            var elStyles = window.getComputedStyle(_this.trackRef.current);
            var trackWidth = parseInt(elStyles.width, 10);
            var trackHeight = parseInt(elStyles.height, 10);
            var paddingLeft = parseInt(elStyles.paddingLeft, 10);
            var paddingTop = parseInt(elStyles.paddingTop, 10);
            var res = [];
            for (var i = 0; i < _this.numOfMarks + 1; i++) {
                var markHeight = 9999;
                var markWidth = 9999;
                if (_this.markRefs[i].current) {
                    var markRect = _this.markRefs[i].current.getBoundingClientRect();
                    markHeight = markRect.height;
                    markWidth = markRect.width;
                }
                if (_this.props.direction === types_1.Direction.Left ||
                    _this.props.direction === types_1.Direction.Right) {
                    res.push([
                        Math.round((trackWidth / _this.numOfMarks) * i + paddingLeft - markWidth / 2),
                        -Math.round((markHeight - trackHeight) / 2)
                    ]);
                }
                else {
                    res.push([
                        Math.round((trackHeight / _this.numOfMarks) * i + paddingTop - markHeight / 2),
                        -Math.round((markWidth - trackWidth) / 2)
                    ]);
                }
            }
            _this.setState({ markOffsets: res });
        };
        if (props.step === 0) {
            throw new Error('"step" property should be a positive number');
        }
        _this.numOfMarks = (props.max - props.min) / _this.props.step;
        _this.schdOnMouseMove = utils_1.schd(_this.onMouseMove);
        _this.schdOnTouchMove = utils_1.schd(_this.onTouchMove);
        _this.schdOnEnd = utils_1.schd(_this.onEnd);
        _this.thumbRefs = props.values.map(function () { return React.createRef(); });
        for (var i = 0; i < _this.numOfMarks + 1; i++) {
            _this.markRefs[i] = React.createRef();
        }
        return _this;
    }
    Range.prototype.componentDidMount = function () {
        var _this = this;
        var _a = this.props, values = _a.values, min = _a.min, step = _a.step;
        this.resizeObserver = window.ResizeObserver
            ? new window.ResizeObserver(this.onResize)
            : {
                observe: function () { return window.addEventListener('resize', _this.onResize); },
                unobserve: function () { return window.removeEventListener('resize', _this.onResize); }
            };
        document.addEventListener('touchstart', this.onMouseOrTouchStart, {
            passive: false
        });
        document.addEventListener('mousedown', this.onMouseOrTouchStart, {
            passive: false
        });
        !this.props.allowOverlap && utils_1.checkInitialOverlap(this.props.values);
        this.props.values.forEach(function (value) {
            return utils_1.checkBoundaries(value, _this.props.min, _this.props.max);
        });
        this.resizeObserver.observe(this.trackRef.current);
        utils_1.translateThumbs(this.getThumbs(), this.getOffsets(), this.props.rtl);
        this.calculateMarkOffsets();
        values.forEach(function (value) {
            if (!utils_1.isStepDivisible(min, value, step)) {
                console.warn('The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.');
            }
        });
    };
    Range.prototype.componentDidUpdate = function (prevProps, prevState) {
        var _a = this.props, max = _a.max, min = _a.min, step = _a.step, values = _a.values, rtl = _a.rtl;
        if (prevProps.max !== max ||
            prevProps.min !== min ||
            prevProps.step !== step) {
            this.markRefs = [];
            this.numOfMarks = (max - min) / step;
            for (var i = 0; i < this.numOfMarks + 1; i++) {
                this.markRefs[i] = React.createRef();
            }
        }
        utils_1.translateThumbs(this.getThumbs(), this.getOffsets(), rtl);
        // ensure offsets are calculated when the refs for the marks have been created
        // and those refs have been mounted to the dom
        // on the state update in calculateOffsets with new markOffsets are calculated
        if (prevProps.max !== max ||
            prevProps.min !== min ||
            prevProps.step !== step ||
            prevState.markOffsets.length !== this.state.markOffsets.length) {
            this.calculateMarkOffsets();
            values.forEach(function (value) {
                if (!utils_1.isStepDivisible(min, value, step)) {
                    console.warn('The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.');
                }
            });
        }
    };
    Range.prototype.componentWillUnmount = function () {
        var options = {
            passive: false
        };
        document.removeEventListener('mousedown', this.onMouseOrTouchStart, options);
        // These need to be removed!!
        document.removeEventListener('mousemove', this.schdOnMouseMove);
        document.removeEventListener('touchmove', this.schdOnTouchMove);
        document.removeEventListener('touchstart', this.onMouseOrTouchStart);
        document.removeEventListener('mouseup', this.schdOnEnd);
        document.removeEventListener('touchend', this.schdOnEnd);
        this.resizeObserver.unobserve(this.trackRef.current);
    };
    Range.prototype.render = function () {
        var _this = this;
        var _a = this.props, renderTrack = _a.renderTrack, renderThumb = _a.renderThumb, _b = _a.renderMark, renderMark = _b === void 0 ? function () { return null; } : _b, values = _a.values, min = _a.min, max = _a.max, allowOverlap = _a.allowOverlap, disabled = _a.disabled;
        var _c = this.state, draggedThumbIndex = _c.draggedThumbIndex, thumbZIndexes = _c.thumbZIndexes, markOffsets = _c.markOffsets;
        return renderTrack({
            props: {
                style: {
                    // creates stacking context that prevents z-index applied to thumbs
                    // interfere with other elements
                    transform: 'scale(1)',
                    cursor: draggedThumbIndex > -1
                        ? 'grabbing'
                        : this.props.draggableTrack
                            ? utils_1.isVertical(this.props.direction)
                                ? 'ns-resize'
                                : 'ew-resize'
                            : values.length === 1 && !disabled
                                ? 'pointer'
                                : 'inherit'
                },
                onMouseDown: disabled ? utils_1.voidFn : this.onMouseDownTrack,
                onTouchStart: disabled ? utils_1.voidFn : this.onTouchStartTrack,
                ref: this.trackRef
            },
            isDragged: this.state.draggedThumbIndex > -1,
            disabled: disabled,
            children: __spreadArrays(markOffsets.map(function (offset, index, arr) {
                return renderMark({
                    props: {
                        style: _this.props.direction === types_1.Direction.Left ||
                            _this.props.direction === types_1.Direction.Right
                            ? {
                                position: 'absolute',
                                left: offset[0] + "px",
                                marginTop: offset[1] + "px"
                            }
                            : {
                                position: 'absolute',
                                top: offset[0] + "px",
                                marginLeft: offset[1] + "px"
                            },
                        key: "mark" + index,
                        ref: _this.markRefs[index]
                    },
                    index: index
                });
            }), values.map(function (value, index) {
                var isDragged = _this.state.draggedThumbIndex === index;
                return renderThumb({
                    index: index,
                    value: value,
                    isDragged: isDragged,
                    props: {
                        style: {
                            position: 'absolute',
                            zIndex: thumbZIndexes[index],
                            cursor: disabled ? 'inherit' : isDragged ? 'grabbing' : 'grab',
                            userSelect: 'none',
                            touchAction: 'none',
                            WebkitUserSelect: 'none',
                            MozUserSelect: 'none',
                            msUserSelect: 'none'
                        },
                        key: index,
                        tabIndex: disabled ? undefined : 0,
                        'aria-valuemax': allowOverlap ? max : values[index + 1] || max,
                        'aria-valuemin': allowOverlap ? min : values[index - 1] || min,
                        'aria-valuenow': value,
                        draggable: false,
                        ref: _this.thumbRefs[index],
                        role: 'slider',
                        onKeyDown: disabled ? utils_1.voidFn : _this.onKeyDown,
                        onKeyUp: disabled ? utils_1.voidFn : _this.onKeyUp
                    }
                });
            }))
        });
    };
    Range.defaultProps = {
        step: 1,
        direction: types_1.Direction.Right,
        rtl: false,
        disabled: false,
        allowOverlap: false,
        draggableTrack: false,
        min: 0,
        max: 100
    };
    return Range;
}(React.Component));
Range$1.default = Range;

(function (exports) {
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkValuesAgainstBoundaries = exports.relativeValue = exports.useThumbOverlap = exports.Direction = exports.getTrackBackground = exports.Range = void 0;
var Range_1 = __importDefault(Range$1);
exports.Range = Range_1.default;
var utils_1 = utils;
Object.defineProperty(exports, "getTrackBackground", { enumerable: true, get: function () { return utils_1.getTrackBackground; } });
Object.defineProperty(exports, "useThumbOverlap", { enumerable: true, get: function () { return utils_1.useThumbOverlap; } });
Object.defineProperty(exports, "relativeValue", { enumerable: true, get: function () { return utils_1.relativeValue; } });
Object.defineProperty(exports, "checkValuesAgainstBoundaries", { enumerable: true, get: function () { return utils_1.checkValuesAgainstBoundaries; } });
var types_1 = types;
Object.defineProperty(exports, "Direction", { enumerable: true, get: function () { return types_1.Direction; } });
}(lib));

const CONTROLCLASS$5 = 'wpeform-control-number';
const SPINNER_UP_CLASS = getBemElement(CONTROLCLASS$5, 'spinner-up');
const SPINNER_DOWN_CLASS = getBemElement(CONTROLCLASS$5, 'spinner-down');
const SpinnerButton = styled.button `
	${buttonResetCss};
	display: flex;
	flex: 0 0 50%;
	height: 50%;
	width: 100%;
	font-size: ${props => numToCssSize(props.theme.fz.small2 - 2)};
	justify-content: center;
	align-items: center;
	text-align: center;
	background-color: ${props => props.theme.backgroundShade};
	color: ${props => props.theme.textColorSecondary};
	position: relative;
	border-left: 1px solid ${props => props.theme.borderColorBase};
	&:first-child {
		border-top-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
		border-bottom: 1px solid ${props => props.theme.borderColorBase};
	}
	&:last-child {
		border-bottom-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	}
	transition: ${props => getMultipleTransitionsWithWillChange(['color', 'height', 'flex-basis', 'background-color', 'border-color'], props.theme.transitionControl)};
	&:hover {
		background-color: ${props => props.theme.backgroundHover};
		color: ${props => props.theme.textColor};
		border-left-color: ${props => props.theme.primaryColor};
		z-index: 2;
	}
	&:focus,
	&:active {
		border-left-color: ${props => props.theme.primaryColor};
		color: ${props => props.theme.primaryColor};
		z-index: 1;
	}
`;
function Button(props) {
    const { onClick, ...btnProps } = props;
    return (jsx(SpinnerButton, Object.assign({}, btnProps, { onClick: e => {
            e.preventDefault();
            onClick();
        } }), void 0));
}
const Suffix = styled.div `
	position: absolute;
	right: 1px;
	top: 1px;
	bottom: 1px;
	overflow: hidden;
	width: ${props => numToCssSize(props.theme.controlHeightBase * 0.5)};
	border-top-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-bottom-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	display: flex;
	flex-flow: column nowrap;
	align-items: stretch;

	&:hover {
		${SpinnerButton} {
			&:hover {
				flex-basis: 65%;
				height: 65%;
			}
			&:not(:hover) {
				flex-basis: 35%;
				height: 35%;
			}
		}
	}
`;
const Container$2 = styled(Container$6) `
	${StyledInput} {
		padding-right: ${props => numToCssSize(props.theme.controlHeightBase * 0.5 + 2)};
		text-align: right;
		font-variant-numeric: tabular-nums;
	}
	&.${CONTROLCLASS$l}--type-MATERIAL {
		${Suffix} {
			bottom: 2px;
			border-bottom-right-radius: 0;
			${SpinnerButton} {
				&:last-child {
					border-bottom-right-radius: 0;
				}
			}
		}
	}
`;
function Number$1(props) {
    const { id, onChange, value, prefix, placeholder, controlType = SettingsAppearanceControlTypeEnum.BOXY, controlAlignment = SettingsAppearanceControlAlignmentEnum.LEFT, disabled = false, readOnly = false, hasError = false, onBlur, innerRef, className, size = GenericSizeEnum.DEFAULT, max = Infinity, min = 0, step = 1, precision = 2, isNullable = true, ...inputProps } = props;
    const [focused, setFocused] = useState$1(false);
    // localize the value for actual calculation
    const [localValue, setLocalValue] = useState$1('');
    // an effect to sync back the change from parent
    useEffect(() => {
        setLocalValue(value?.toFixed(precision) ?? '');
    }, [value, precision]);
    const containerClasses = classNames(getBemClassName(CONTROLCLASS$l, {
        'has-prefix': !!prefix,
        'is-not-empty': localValue !== '',
        'is-focused': focused,
        [`type-${controlType}`]: true,
        'has-error': hasError,
        [`align-${controlAlignment}`]: true,
        [`size-${size}`]: true,
    }, className), CONTROLCLASS$5);
    const inputClassName = getBemClassName(getBemElement(CONTROLCLASS$l, 'input'), {
        [`type-${controlType}`]: true,
        'has-error': hasError,
        [`size-${size}`]: true,
    }, getBemElement(CONTROLCLASS$5, 'input'));
    return (jsxs(Container$2, Object.assign({ className: containerClasses }, { children: [prefix ? jsx(Prefix$2, { children: prefix }, void 0) : null, typeof placeholder !== 'string' ? (jsx(Placeholder$1, { children: placeholder }, void 0)) : null, jsx(StyledInput, Object.assign({ id: id, type: "number", className: inputClassName, value: localValue, onChange: e => {
                    setLocalValue(e.target.value);
                }, onFocus: () => {
                    setFocused(true);
                }, onBlur: event => {
                    setFocused(false);
                    // if local value is empty and if the control is nullable
                    if (localValue === '' && isNullable) {
                        onChange(null);
                    }
                    else {
                        // get the current localValue and sanitize it
                        let sanitizedValue = getNumericValue(localValue, min);
                        sanitizedValue = roundNumber(sanitizedValue, precision);
                        // check if sanitized value is within min and max
                        if (sanitizedValue < min) {
                            sanitizedValue = min;
                        }
                        if (sanitizedValue > max) {
                            sanitizedValue = max;
                        }
                        // check if properly in steps
                        if (!validateValueInStep(sanitizedValue, step, min, precision)) {
                            sanitizedValue = getNearestValueInStep(sanitizedValue, step, min, precision);
                        }
                        // all sanitization done, call onChange
                        sanitizedValue = roundNumber(sanitizedValue, precision);
                        setLocalValue(sanitizedValue.toFixed(precision));
                        onChange(sanitizedValue);
                    }
                    onBlur?.(event);
                }, disabled: disabled, readOnly: readOnly, placeholder: typeof placeholder === 'string' ? placeholder : undefined, min: min, max: max, step: step, ref: innerRef }, inputProps), void 0), controlType === SettingsAppearanceControlTypeEnum.MATERIAL ? (jsx(MaterialBorder$2, {}, void 0)) : null, jsxs(Suffix, { children: [jsx(Button, Object.assign({ className: SPINNER_UP_CLASS, "aria-label": __('Increase value', 'wp-eform'), onClick: () => {
                            let newValue = value !== null ? value + step : min;
                            if (newValue < min) {
                                newValue = min;
                            }
                            if (newValue > max) {
                                newValue = max;
                            }
                            onChange(roundNumber(newValue, precision));
                        } }, { children: jsx(Icon, { iconClass: "fas fa-angle-up" }, void 0) }), void 0), jsx(Button, Object.assign({ className: SPINNER_DOWN_CLASS, "aria-label": __('Decrease value', 'wp-eform'), onClick: () => {
                            let newValue = value !== null ? value - step : min;
                            if (newValue < min) {
                                newValue = min;
                            }
                            if (newValue > max) {
                                newValue = max;
                            }
                            onChange(roundNumber(newValue, precision));
                        } }, { children: jsx(Icon, { iconClass: "fas fa-angle-down" }, void 0) }), void 0)] }, void 0)] }), void 0));
}

const CONTROLCLASS$4 = 'wpeform-control-slider';
const SLIDERCONTAINERCLASS = getBemElement(CONTROLCLASS$4, 'slider');
const INPUTMINCLASS = getBemElement(CONTROLCLASS$4, 'input-min');
const INPUTMAXCLASS = getBemElement(CONTROLCLASS$4, 'input-max');
const TRACKBASECLASS = getBemElement(CONTROLCLASS$4, 'track-base');
const TRACKLINECLASS = getBemElement(CONTROLCLASS$4, 'track-line');
const THUMBCLASS = getBemElement(CONTROLCLASS$4, 'thumb');
const THUMBTACKCLASS = getBemElement(CONTROLCLASS$4, 'thumb-tack');
const MARKCLASS = getBemElement(CONTROLCLASS$4, 'mark');
const MARKLABELCLASS = getBemElement(CONTROLCLASS$4, 'mark-label');
const InputContainer = styled.div `
	flex: 0 0 ${props => numToCssSize(props.theme.controlHeightBase * 1.5)};
	width: ${props => numToCssSize(props.theme.controlHeightBase * 1.5)};
	margin: 0;

	&.${INPUTMINCLASS} {
		margin-right: ${props => numToCssSize(props.theme.gutter * 1.25)};
	}
	&.${INPUTMAXCLASS} {
		margin-left: ${props => numToCssSize(props.theme.gutter * 1.25)};
	}
`;
const SliderContainer = styled.div `
	flex: 1 1 100%;
	width: 100%;
	margin: 0;
`;
const TrackBase = styled.div `
	width: 100%;
	display: flex;
	align-items: center;
	height: ${props => numToCssSize(props.theme.controlHeightBase * 0.75)};
	&.${TRACKBASECLASS}--hasMarks {
		height: ${props => numToCssSize(props.theme.controlHeightBase * 1.05 + props.theme.gutter * 0.05)};
	}
`;
const TrackLine = styled.div `
	height: ${props => numToCssSize(props.theme.controlHeightBase * 0.2)};
	width: 100%;
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	will-change: background;
	position: relative;
`;
const ThumbTack = styled.div `
	height: ${props => numToCssSize(props.theme.controlHeightBase * 0.25)};
	width: ${props => numToCssSize(props.theme.controlHeightBase * 0.05)};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	background-color: ${props => props.theme.borderColorSplit};
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color'], props.theme.transitionControl)};
	margin: 0 ${props => numToCssSize(props.theme.gutter * 0.075)};
`;
const Thumb = styled.div `
	height: ${props => numToCssSize(props.theme.controlHeightBase * 0.6)};
	width: ${props => numToCssSize(props.theme.controlHeightBase * 0.75)};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase / 2)};
	background-color: ${props => props.theme.backgroundShade};
	box-shadow: ${props => props.theme.boxShadow2dp},
		${props => props.theme.boxShadowNoneFocus};
	border: 1px solid ${props => props.theme.backgroundShade};
	display: flex;
	flex-flow: row nowrap;
	align-items: center;
	justify-content: center;
	transition: ${props => getMultipleTransitionsWithWillChange(['box-shadow', 'border-color'], props.theme.transitionControl)};

	&:hover,
	&.${THUMBCLASS}--isDragged {
		${ThumbTack} {
			background-color: ${props => props.theme.primaryColor};
		}
	}

	&:focus {
		outline: none;
		box-shadow: ${props => props.theme.boxShadow4dp},
			${props => props.theme.boxShadowNoneFocus};
	}

	&:focus-visible {
		outline: none;
		box-shadow: ${props => props.theme.boxShadow2dp},
			${props => props.theme.boxShadowControlFocus};
		border-color: ${props => props.theme.primaryColor};
	}

	&.${THUMBCLASS}--disabled {
		background-color: ${props => props.theme.appBackgroundColor};
		box-shadow: ${props => props.theme.boxShadow2dp},
			${props => props.theme.boxShadowNoneFocus};
		${ThumbTack} {
			background-color: ${props => props.theme.disabledColor};
		}
	}
`;
const MarkLabel = styled.span `
	position: absolute;
	font-size: ${props => numToCssSize(props.theme.fz.small2)};
	font-weight: bold;
	color: ${props => props.theme.textColorSecondary};
	left: 50%;
	top: ${props => numToCssSize(props.theme.controlHeightBase * 0.3 + props.theme.gutter * 0.05)};
	transform: translate(-50%, 0);
	transition: ${props => getMultipleTransitionsWithWillChange(['color'], props.theme.transitionControl)};
`;
const Mark = styled.div `
	height: ${props => numToCssSize(props.theme.controlHeightBase * 0.3)};
	&:nth-child(2n) {
		height: ${props => numToCssSize(props.theme.controlHeightBase * 0.2)};
	}
	width: ${props => numToCssSize(props.theme.controlHeightBase * 0.05)};
	border-radius: ${props => numToCssSize(props.theme.controlHeightBase * 0.05)};
	background-color: ${props => props.theme.backgroundSelected};
	margin-top: ${props => numToCssSize(props.theme.controlHeightBase * 0.3 + props.theme.gutter * 0.2)} !important;
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color'], props.theme.transitionControl)};
	&.${MARKCLASS}--inRange {
		background-color: ${props => props.theme.primaryColor};
		${MarkLabel} {
			color: ${props => props.theme.primaryColor};
		}
	}
`;
const Container$1 = styled.div `
	display: flex;
	flex-flow: row nowrap;
	align-items: center;
	justify-content: space-between;
	padding: 0 0 ${props => numToCssSize(props.theme.gutter / 4)} 0;
	&.${CONTROLCLASS$4}--has-marks {
		padding-bottom: ${props => numToCssSize(props.theme.gutter)};
	}

	&.${CONTROLCLASS$4}--control-type-MATERIAL {
		${TrackBase} {
			height: ${props => numToCssSize(props.theme.controlHeightBase * 0.5)};
			&.${TRACKBASECLASS}--hasMarks {
				height: ${props => numToCssSize(props.theme.controlHeightBase * 0.8 + props.theme.gutter * 0.05)};
			}
		}
		${TrackLine} {
			height: ${props => numToCssSize(props.theme.controlHeightBase * 0.1)};
		}
		${Thumb} {
			height: ${props => numToCssSize(props.theme.controlHeightBase * 0.5)};
			width: ${props => numToCssSize(props.theme.controlHeightBase * 0.5)};
			border-radius: ${props => numToCssSize(props.theme.controlHeightBase * 0.5)};
			background-color: ${props => props.theme.primaryColor};
			box-shadow: ${props => props.theme.boxShadowNoneFocus};
			border: 0 none;
			&:hover,
			&:focus {
				box-shadow: 0 0 0
					${props => numToCssSize(props.theme.controlHeightBase * 0.25)}
					${props => curriedTransparentize(0.8, props.theme.primaryColor)};
			}
			&.${THUMBCLASS}--isDragged {
				box-shadow: 0 0 0
					${props => numToCssSize(props.theme.controlHeightBase * 0.4)}
					${props => curriedTransparentize(0.8, props.theme.primaryColor)};
			}
			&.${THUMBCLASS}--disabled {
				background-color: ${props => props.theme.borderColorBase};
				box-shadow: ${props => props.theme.boxShadowNoneFocus};
			}
		}
		${ThumbTack} {
			display: none;
		}
	}

	&.${CONTROLCLASS$4}--disabled {
		cursor: not-allowed;

		${Mark} {
			&.${MARKCLASS}--inRange {
				background-color: ${props => props.theme.borderColorBase};
				${MarkLabel} {
					color: ${props => props.theme.borderColorBase};
				}
			}
		}
	}
`;

function Slider(props) {
    const { className, min, max, step, precision = 2, controlType, disabled = false, hasError, marks, onBlur, showFreeInput = true, } = props;
    if (step <= 0) {
        throw new Error(`Step cannot be less than or equal to 0, ${step} given.`);
    }
    if (min > max) {
        throw new Error(`Min value cannot be greater than max. Given min is ${min} and max is ${max}.`);
    }
    const theme = useTheme();
    const sliderDiv = useRef(null);
    const sliderSize = componentSize(sliderDiv);
    const maxMarks = roundNumber(Math.ceil((5 / 100) * sliderSize.width), 2);
    let totalMarks = roundNumber(Math.ceil((max - min) / step), 2);
    if (props.type === 'range') {
        totalMarks = totalMarks + 1;
    }
    let marksInterval = roundNumber(Math.ceil(totalMarks / maxMarks), 2);
    if (!Number.isFinite(marksInterval)) {
        marksInterval = 1;
    }
    let rangeValue;
    let rangeColors;
    const trackHighlightColor = disabled
        ? theme.borderColorBase
        : theme.primaryColor;
    const trackBgColor = theme.borderColorSplit;
    if (props.type === 'range') {
        rangeValue = props.value;
        rangeColors = [trackBgColor, trackHighlightColor, trackBgColor];
    }
    else {
        rangeValue = [props.value];
        rangeColors = [trackHighlightColor, trackBgColor];
    }
    // sanitize range value again, so that it doesn't throw errors
    if (rangeValue[0] < min) {
        rangeValue[0] = min;
    }
    if (rangeValue[1] && rangeValue[1] > max) {
        rangeValue[1] = max;
    }
    return (jsxs(Container$1, Object.assign({ className: getBemClassName(CONTROLCLASS$4, {
            [`control-type-${controlType ?? SettingsAppearanceControlTypeEnum.BOXY}`]: true,
            'has-marks': Array.isArray(marks),
            disabled,
        }, className) }, { children: [props.type === 'range' && showFreeInput ? (jsx(InputContainer, Object.assign({ className: INPUTMINCLASS }, { children: jsx(Number$1, { value: rangeValue[0], onChange: newVal => {
                        props.onChange([newVal ?? min, props.value[1]]);
                    }, min: min, max: max, step: step, precision: precision, hasError: hasError, onBlur: onBlur, readOnly: disabled, controlType: controlType, controlAlignment: SettingsAppearanceControlAlignmentEnum.LEFT, size: GenericSizeEnum.SMALL, isNullable: false }, void 0) }), void 0)) : null, jsx(SliderContainer, Object.assign({ className: SLIDERCONTAINERCLASS, ref: sliderDiv }, { children: jsx(lib.Range, { step: step, min: min, max: max, values: rangeValue, onChange: newValues => {
                        if (props.type === 'range') {
                            props.onChange([newValues[0], newValues[1]]);
                        }
                        else {
                            props.onChange(newValues[0]);
                        }
                    }, renderTrack: ({ children, disabled: trackDisabled, isDragged, props: trackProps, }) => (jsx(TrackBase, Object.assign({ className: getBemClassName(TRACKBASECLASS, {
                            isDragged,
                            disabled: trackDisabled,
                            hasMarks: !!marks,
                        }), onMouseDown: trackProps.onMouseDown, onTouchStart: trackProps.onTouchStart, style: trackProps.style }, { children: jsx(TrackLine, Object.assign({ className: getBemClassName(TRACKLINECLASS, {
                                isDragged,
                                disabled: trackDisabled,
                            }), ref: trackProps.ref, style: {
                                background: lib.getTrackBackground({
                                    values: rangeValue,
                                    colors: rangeColors,
                                    min,
                                    max,
                                }),
                            } }, { children: children }), void 0) }), void 0)), renderThumb: ({ props: thumbProps, isDragged }) => (jsxs(Thumb, Object.assign({ className: getBemClassName(THUMBCLASS, { isDragged, disabled }) }, thumbProps, { children: [jsx(ThumbTack, { className: THUMBTACKCLASS }, void 0), jsx(ThumbTack, { className: THUMBTACKCLASS }, void 0)] }), void 0)), renderMark: marks
                        ? ({ props: markProps, index }) => {
                            let inRange = false;
                            const currentValue = min + index * step;
                            if (props.type === 'single') {
                                inRange = currentValue <= rangeValue[0];
                            }
                            else {
                                inRange =
                                    currentValue >= rangeValue[0] &&
                                        currentValue <= rangeValue[1];
                            }
                            let showMark = index % marksInterval === 0;
                            let label = null;
                            if (Array.isArray(marks)) {
                                const currentMark = marks.find(m => m.index === currentValue);
                                if (currentMark) {
                                    showMark = true;
                                    label =
                                        currentMark.label?.replace('%%val%%', currentValue.toString()) ?? null;
                                }
                            }
                            return showMark ? (jsx(Mark, Object.assign({ className: getBemClassName(MARKCLASS, { inRange }) }, markProps, { children: label ? (jsx(MarkLabel, Object.assign({ className: MARKLABELCLASS }, { children: label }), void 0)) : null }), void 0)) : null;
                        }
                        : undefined, onFinalChange: onBlur, disabled: disabled }, void 0) }), void 0), showFreeInput ? (jsx(InputContainer, Object.assign({ className: INPUTMAXCLASS }, { children: jsx(Number$1, { value: props.type === 'range' ? rangeValue[1] : rangeValue[0], onChange: newVal => {
                        const parsedValue = getFloatValue(newVal, min);
                        if (props.type === 'range') {
                            props.onChange([props.value[0], parsedValue]);
                        }
                        else {
                            props.onChange(parsedValue);
                        }
                    }, min: props.type === 'range' ? props.value[0] : min, max: max, step: step, precision: precision, hasError: hasError, onBlur: onBlur, readOnly: disabled, controlType: controlType, controlAlignment: SettingsAppearanceControlAlignmentEnum.LEFT, size: GenericSizeEnum.SMALL, isNullable: false }, void 0) }), void 0)) : null] }), void 0));
}

const slider = {
    id: 'slider',
    hasSubmission: true,
    FormUi({ elementData, setElementTouched, submissionData, updateSubmissionData, controlType, hasError, }) {
        const config = elementData.config.slider;
        let marks;
        if (config?.interface?.showMarks) {
            marks = true;
            if (config.interface.customMarks.length) {
                marks = config.interface.customMarks.map(m => ({
                    index: m.index,
                    label: m.label ?? '',
                }));
            }
        }
        return (jsx(Slider, { max: config?.interface?.max ?? 10, min: config?.interface?.min ?? 0, step: config?.interface?.step ?? 1, precision: config?.interface?.precision ?? 2, type: "single", onChange: newVal => {
                updateSubmissionData(produce(submissionData, draftState => {
                    draftState.value.slider.selected = newVal;
                }));
            }, value: submissionData.value.slider.selected, controlType: controlType, disabled: config?.attributes.readonly, marks: marks, hasError: hasError, className: elementData.appearance?.className, onBlur: () => {
                setElementTouched(true);
            }, showFreeInput: config?.interface?.showFreeInput }, void 0));
    },
    getErrors(elementData, submissionDataValue) {
        const errors = [];
        const selected = submissionDataValue.slider.selected;
        const config = elementData.config.slider.interface;
        if (!config) {
            return errors;
        }
        if (config.min && selected < config.min) {
            errors.push(validationMessages.sliderMinUnderFlow.replaceAll('{min}', formatNumber(config.min, 2)));
        }
        if (config.max && selected > config.max) {
            errors.push(validationMessages.sliderMaxOverFlow.replaceAll('{max}', formatNumber(config.max, 2)));
        }
        if (!validateValueInStep(selected, config.step, config.min, config.precision)) {
            errors.push(validationMessages.sliderStepOverFlow.replaceAll('{step}', formatNumber(config.step, 2)));
        }
        return errors;
    },
    isQuestion: true,
    isRequired(elementData) {
        return false;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        const numberValue = getFloatValue(newValue, elementData.config.slider?.interface?.min);
        mutableSubmissionDataValue.slider.selected = numberValue;
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue) {
        let conditionStatus = false;
        const compareWith = getFloatValue(value, Number.NaN);
        if (Number.isNaN(compareWith)) {
            logger.l(`%c ERROR %c conditional operation on slider assumes numeric value. ${value} given.`, logger.style.error, logger.style.reset);
            return false;
        }
        const selected = submissionDataValue.slider.selected;
        if (comparison === EventComparisonEnum.EQUALS_TO) {
            conditionStatus = selected === compareWith;
        }
        else if (comparison === EventComparisonEnum.GREATER_THAN) {
            conditionStatus = selected > compareWith;
        }
        else if (comparison === EventComparisonEnum.LESS_THAN) {
            conditionStatus = selected < compareWith;
        }
        return operation === EventOperationEnum.IS
            ? conditionStatus
            : !conditionStatus;
    },
    getDisplayValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.slider.selected;
        return formatNumber(selected, elementData.config.slider?.interface?.precision ?? 2);
    },
    getAnswerValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.slider.selected;
        return formatNumber(selected, elementData.config.slider?.interface?.precision ?? 2);
    },
    getNumericValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.slider.selected;
        return selected ?? 0;
    },
    getPresetValue(elementData, defaultValue) {
        const newDefaultValue = produce(defaultValue, draftValue => {
            const allowedMinValue = elementData.config.slider?.interface?.min ?? 0;
            // If it has a set default value
            if (!isNullOrEmptyString(elementData.config.slider?.attributes.defaultValue)) {
                draftValue.slider.selected = getFloatValue(elementData.config.slider?.attributes.defaultValue);
            }
            // override if URL query parameter is used
            if (elementData.config.slider?.attributes.prefilType === PrefilEnum.URL) {
                const parsedValue = getFloatValue(getUrlParameterValue(window.location.search, elementData.config.slider.attributes.prefilParameter), Number.NaN);
                if (Number.isFinite(parsedValue)) {
                    draftValue.slider.selected = parsedValue;
                }
            }
            // override if meta based query is used
            if (elementData.config.slider?.attributes.prefilType === PrefilEnum.META) {
                const decodedExtra = decodeJSONRecord(elementData.extras);
                if (decodedExtra && decodedExtra.metaValue) {
                    // metavalue would be a number
                    const metaValue = decodedExtra.metaValue;
                    if (typeof metaValue === 'number') {
                        draftValue.slider.selected = metaValue;
                    }
                }
            }
            // override to allowed min value
            if (draftValue.slider.selected < allowedMinValue) {
                draftValue.slider.selected = allowedMinValue;
            }
        });
        return newDefaultValue;
    },
};

var _g;

function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }

function SvgGenericCheckboxChecked(props) {
  return /*#__PURE__*/React$2.createElement("svg", _extends$1({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, props), _g || (_g = /*#__PURE__*/React$2.createElement("g", {
    fillRule: "evenodd"
  }, /*#__PURE__*/React$2.createElement("path", {
    d: "M56 0a8 8 0 018 8v48a8 8 0 01-8 8H8a8 8 0 01-8-8V8a8 8 0 018-8h48zm-4 6H12a6 6 0 00-6 6v40a6 6 0 006 6h40a6 6 0 006-6V12a6 6 0 00-6-6z"
  }), /*#__PURE__*/React$2.createElement("path", {
    d: "M25.714 47.143c.476 0 .905-.19 1.286-.572l24.571-24.428c.381-.286.572-.667.572-1.143s-.19-.905-.572-1.286l-3.142-3.143c-.381-.38-.81-.571-1.286-.571s-.857.19-1.143.571l-20.286 20-8.428-8.714A2.09 2.09 0 0016 27.43c-.476 0-.857.142-1.143.428l-3.286 3.286A1.358 1.358 0 0011 32.286c0 .476.19.904.571 1.285l13 13c.286.381.667.572 1.143.572z"
  }))));
}

var _path;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function SvgGenericCheckboxUnchecked(props) {
  return /*#__PURE__*/React$2.createElement("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, props), _path || (_path = /*#__PURE__*/React$2.createElement("path", {
    fillRule: "evenodd",
    d: "M56 0a8 8 0 018 8v48a8 8 0 01-8 8H8a8 8 0 01-8-8V8a8 8 0 018-8h48zm-4 6H12a6 6 0 00-6 6v40a6 6 0 006 6h40a6 6 0 006-6V12a6 6 0 00-6-6z"
  })));
}

const singlecheckbox = {
    id: 'singlecheckbox',
    hasSubmission: true,
    FormUi({ elementData, id, setElementTouched, submissionData, updateSubmissionData, controlAlignment, }) {
        return (jsx(OptionGroup, Object.assign({ columns: OptionColumnEnum.AUTO, controlAlignment: controlAlignment }, { children: jsx(OptionGroup.Item, { children: jsx(Checkbox, { checked: submissionData.value.singlecheckbox.selected, onChange: checked => {
                        updateSubmissionData(produce(submissionData, draftState => {
                            draftState.value.singlecheckbox.selected = checked;
                        }));
                        setElementTouched(true);
                    }, className: elementData.appearance?.className, disabled: elementData.config.singlecheckbox?.attributes.readonly, icon: elementData.config.singlecheckbox?.interface?.icon, id: id, name: id, onBlur: () => {
                        setElementTouched(true);
                    }, text: jsx(SlateViewWithData, { mode: "singleline", nodes: getNodesFromJSON(elementData.appearance?.title), currentElementId: elementData.id }, void 0) }, void 0) }, void 0) }), void 0));
    },
    getErrors(elementData, submissionDataValue) {
        const errors = [];
        const isRequired = !!elementData.config.singlecheckbox?.validation?.required;
        // if this is required
        if (isRequired && !submissionDataValue.singlecheckbox?.selected) {
            errors.push(validationMessages.requiredCheckbox);
        }
        return errors;
    },
    isQuestion: true,
    isQuestionTitleHidden: true,
    isRequired(elementData) {
        return !!elementData.config.singlecheckbox?.validation?.required;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        if (newValue === 'true') {
            mutableSubmissionDataValue.singlecheckbox.selected = true;
        }
        else {
            mutableSubmissionDataValue.singlecheckbox.selected = false;
        }
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue) {
        let conditionStatus = false;
        const compareWith = value === 'true';
        // only EQUALS_TO is supported
        if (comparison === EventComparisonEnum.EQUALS_TO) {
            conditionStatus =
                compareWith === submissionDataValue.singlecheckbox.selected;
        }
        return operation === EventOperationEnum.IS
            ? conditionStatus
            : !conditionStatus;
    },
    getDisplayValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.singlecheckbox.selected;
        if (selected) {
            return __('Yes', 'wp-eform');
        }
        return __('No', 'wp-eform');
    },
    getNumericValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.singlecheckbox.selected;
        return selected ? 1 : 0;
    },
    getAnswerValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.singlecheckbox.selected;
        let label = __('Yes.', 'wp-eform');
        if (!selected) {
            label = __('No.', 'wp-eform');
        }
        return (jsxs("p", { children: [jsx(Icon, { children: selected ? (jsx(SvgGenericCheckboxChecked, {}, void 0)) : (jsx(SvgGenericCheckboxUnchecked, {}, void 0)) }, void 0), ' ', label] }, void 0));
    },
    getPresetValue(elementData, defaultValue) {
        const newDefaultValue = produce(defaultValue, draftValue => {
            // If it has a set default value
            if (!isNullOrEmptyString(elementData.config.singlecheckbox?.attributes.defaultValue)) {
                draftValue.singlecheckbox.selected =
                    elementData.config.singlecheckbox.attributes.defaultValue === 'true';
            }
            // override if URL query parameter is used
            if (elementData.config.singlecheckbox?.attributes.prefilType ===
                PrefilEnum.URL) {
                const compareWith = getUrlParameterValue(window.location.search, elementData.config.singlecheckbox.attributes.prefilParameter);
                if (compareWith === 'true') {
                    draftValue.singlecheckbox.selected = true;
                }
                else if (compareWith === 'false') {
                    draftValue.singlecheckbox.selected = false;
                }
            }
            // override if meta based query is used
            if (elementData.config.singlecheckbox?.attributes.prefilType ===
                PrefilEnum.META) {
                const decodedExtra = decodeJSONRecord(elementData.extras);
                if (decodedExtra && decodedExtra.metaValue) {
                    // metaValue would be a boolean
                    const metaValue = decodedExtra.metaValue;
                    if (typeof metaValue === 'boolean') {
                        draftValue.singlecheckbox.selected = metaValue;
                    }
                }
            }
        });
        return newDefaultValue;
    },
};

const wpEFormElementFrontCollection = new Collections('EForm Elements UI');
wpEFormElementFrontCollection.addItem(text.id, text);
wpEFormElementFrontCollection.addItem(textarea.id, textarea);
wpEFormElementFrontCollection.addItem(dropdown.id, dropdown);
wpEFormElementFrontCollection.addItem(group.id, group);
wpEFormElementFrontCollection.addItem(row.id, row);
wpEFormElementFrontCollection.addItem(column.id, column);
wpEFormElementFrontCollection.addItem(heading.id, heading);
wpEFormElementFrontCollection.addItem(checkbox.id, checkbox);
wpEFormElementFrontCollection.addItem(radio.id, radio);
wpEFormElementFrontCollection.addItem(buttons.id, buttons);
wpEFormElementFrontCollection.addItem(captcha.id, captcha);
wpEFormElementFrontCollection.addItem(slider.id, slider);
wpEFormElementFrontCollection.addItem(singlecheckbox.id, singlecheckbox);

var dayjs_min = {exports: {}};

(function (module, exports) {
!function(t,e){module.exports=e();}(this,(function(){var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",$="Invalid Date",l=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},m=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},g={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return +(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return {M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},D="en",v={};v[D]=M;var p=function(t){return t instanceof _},S=function(t,e,n){var r;if(!t)return D;if("string"==typeof t)v[t]&&(r=t),e&&(v[t]=e,r=t);else {var i=t.name;v[i]=t,r=i;}return !n&&r&&(D=r),r||!n&&D},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=g;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t);}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(l);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return O},m.isValid=function(){return !(this.$d.toString()===$)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),$=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},l=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,g="set"+(this.$u?"UTC":"");switch(h){case c:return r?$(1,0):$(31,11);case f:return r?$(1,M):$(0,M+1);case o:var D=this.$locale().weekStart||0,v=(y<D?y+7:y)-D;return $(r?m-v:m+(6-v),M);case a:case d:return l(g+"Hours",0);case u:return l(g+"Minutes",1);case s:return l(g+"Seconds",2);case i:return l(g+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),$=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],l=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[$](l),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else $&&this.$d[$](l);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,$=this;r=Number(r);var l=O.p(h),y=function(t){var e=w($);return O.w(e.date(e.date()+Math.round(t*r)),$)};if(l===f)return this.set(f,this.$M+r);if(l===c)return this.set(c,this.$y+r);if(l===a)return y(1);if(l===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[l]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||$;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].substr(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=n.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:i};return r.replace(y,(function(t,e){return e||l[t]||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,$){var l,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,g=this-M,D=O.m(this,M);return D=(l={},l[c]=D/12,l[f]=D,l[h]=D/3,l[o]=(g-m)/6048e5,l[a]=(g-m)/864e5,l[u]=g/n,l[s]=g/e,l[i]=g/t,l)[y]||g,$?D:O.a(D)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return v[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),b=_.prototype;return w.prototype=b,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){b[t[1]]=function(e){return this.$g(e,t[0],t[1])};})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=v[D],w.Ls=v,w.p={},w}));
}(dayjs_min));

var dayjs = dayjs_min.exports;

var customParseFormat$1 = {exports: {}};

(function (module, exports) {
!function(t,e){module.exports=e();}(this,(function(){var t={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},e=/(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,n=/\d\d/,r=/\d\d?/,i=/\d*[^\s\d-_:/()]+/,o={},s=function(t){return (t=+t)+(t>68?1900:2e3)};var a=function(t){return function(e){this[t]=+e;}},f=[/[+-]\d\d:?(\d\d)?|Z/,function(t){(this.zone||(this.zone={})).offset=function(t){if(!t)return 0;if("Z"===t)return 0;var e=t.match(/([+-]|\d\d)/g),n=60*e[1]+(+e[2]||0);return 0===n?0:"+"===e[0]?-n:n}(t);}],u=function(t){var e=o[t];return e&&(e.indexOf?e:e.s.concat(e.f))},h=function(t,e){var n,r=o.meridiem;if(r){for(var i=1;i<=24;i+=1)if(t.indexOf(r(i,0,e))>-1){n=i>12;break}}else n=t===(e?"pm":"PM");return n},d={A:[i,function(t){this.afternoon=h(t,!1);}],a:[i,function(t){this.afternoon=h(t,!0);}],S:[/\d/,function(t){this.milliseconds=100*+t;}],SS:[n,function(t){this.milliseconds=10*+t;}],SSS:[/\d{3}/,function(t){this.milliseconds=+t;}],s:[r,a("seconds")],ss:[r,a("seconds")],m:[r,a("minutes")],mm:[r,a("minutes")],H:[r,a("hours")],h:[r,a("hours")],HH:[r,a("hours")],hh:[r,a("hours")],D:[r,a("day")],DD:[n,a("day")],Do:[i,function(t){var e=o.ordinal,n=t.match(/\d+/);if(this.day=n[0],e)for(var r=1;r<=31;r+=1)e(r).replace(/\[|\]/g,"")===t&&(this.day=r);}],M:[r,a("month")],MM:[n,a("month")],MMM:[i,function(t){var e=u("months"),n=(u("monthsShort")||e.map((function(t){return t.substr(0,3)}))).indexOf(t)+1;if(n<1)throw new Error;this.month=n%12||n;}],MMMM:[i,function(t){var e=u("months").indexOf(t)+1;if(e<1)throw new Error;this.month=e%12||e;}],Y:[/[+-]?\d+/,a("year")],YY:[n,function(t){this.year=s(t);}],YYYY:[/\d{4}/,a("year")],Z:f,ZZ:f};function c(n){var r,i;r=n,i=o&&o.formats;for(var s=(n=r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(e,n,r){var o=r&&r.toUpperCase();return n||i[r]||t[r]||i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(t,e,n){return e||n.slice(1)}))}))).match(e),a=s.length,f=0;f<a;f+=1){var u=s[f],h=d[u],c=h&&h[0],l=h&&h[1];s[f]=l?{regex:c,parser:l}:u.replace(/^\[|\]$/g,"");}return function(t){for(var e={},n=0,r=0;n<a;n+=1){var i=s[n];if("string"==typeof i)r+=i.length;else {var o=i.regex,f=i.parser,u=t.substr(r),h=o.exec(u)[0];f.call(e,h),t=t.replace(h,"");}}return function(t){var e=t.afternoon;if(void 0!==e){var n=t.hours;e?n<12&&(t.hours+=12):12===n&&(t.hours=0),delete t.afternoon;}}(e),e}}return function(t,e,n){n.p.customParseFormat=!0,t&&t.parseTwoDigitYear&&(s=t.parseTwoDigitYear);var r=e.prototype,i=r.parse;r.parse=function(t){var e=t.date,r=t.utc,s=t.args;this.$u=r;var a=s[1];if("string"==typeof a){var f=!0===s[2],u=!0===s[3],h=f||u,d=s[2];u&&(d=s[2]),o=this.$locale(),!f&&d&&(o=n.Ls[d]),this.$d=function(t,e,n){try{if(["x","X"].indexOf(e)>-1)return new Date(("X"===e?1e3:1)*t);var r=c(e)(t),i=r.year,o=r.month,s=r.day,a=r.hours,f=r.minutes,u=r.seconds,h=r.milliseconds,d=r.zone,l=new Date,m=s||(i||o?1:l.getDate()),M=i||l.getFullYear(),Y=0;i&&!o||(Y=o>0?o-1:l.getMonth());var p=a||0,v=f||0,D=u||0,g=h||0;return d?new Date(Date.UTC(M,Y,m,p,v,D,g+60*d.offset*1e3)):n?new Date(Date.UTC(M,Y,m,p,v,D,g)):new Date(M,Y,m,p,v,D,g)}catch(t){return new Date("")}}(e,a,r),this.init(),d&&!0!==d&&(this.$L=this.locale(d).$L),h&&e!==this.format(a)&&(this.$d=new Date("")),o={};}else if(a instanceof Array)for(var l=a.length,m=1;m<=l;m+=1){s[1]=a[m-1];var M=n.apply(this,s);if(M.isValid()){this.$d=M.$d,this.$L=M.$L,this.init();break}m===l&&(this.$d=new Date(""));}else i.call(this,t);};}}));
}(customParseFormat$1));

var customParseFormat = customParseFormat$1.exports;

var utc$1 = {exports: {}};

(function (module, exports) {
!function(t,i){module.exports=i();}(this,(function(){var t="minute",i=/[+-]\d\d(?::?\d\d)?/g,e=/([+-]|\d\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1})};var o=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),o.call(this,t);};var r=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds();}else r.call(this);};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if("string"==typeof s&&null===(s=function(t){void 0===t&&(t="");var s=t.match(i);if(!s)return null;var f=(""+s[0]).match(e)||["-",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:"+"===n?u:-u}(s)))return this;var u=Math.abs(s)<=16?60*s:s,o=this;if(f)return o.$offset=u,o.$u=0===s,o;if(0!==s){var r=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(o=this.local().add(u+r,t)).$offset=u,o.$x.$localOffset=r;}else o=this.utc();return o};var h=u.format;u.format=function(t){var i=t||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||(new Date).getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return !!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return "s"===t&&this.$offset?n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)};}}));
}(utc$1));

var utc = utc$1.exports;

var localizedFormat = {exports: {}};

(function (module, exports) {
!function(e,t){module.exports=t();}(this,(function(){var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};return function(t,o,n){var r=o.prototype,i=r.format;n.en.formats=e,r.format=function(t){void 0===t&&(t="YYYY-MM-DDTHH:mm:ssZ");var o=this.$locale().formats,n=function(t,o){return t.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var i=r&&r.toUpperCase();return n||o[r]||e[r]||o[i].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,o){return t||o.slice(1)}))}))}(t,void 0===o?{}:o);return i.call(this,n)};}}));
}(localizedFormat));

var LocalizedFormat = localizedFormat.exports;

var relativeTime$1 = {exports: {}};

(function (module, exports) {
!function(r,e){module.exports=e();}(this,(function(){return function(r,e,t){r=r||{};var n=e.prototype,o={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};function i(r,e,t,o){return n.fromToBase(r,e,t,o)}t.en.relativeTime=o,n.fromToBase=function(e,n,i,d,u){for(var f,a,s,l=i.$locale().relativeTime||o,h=r.thresholds||[{l:"s",r:44,d:"second"},{l:"m",r:89},{l:"mm",r:44,d:"minute"},{l:"h",r:89},{l:"hh",r:21,d:"hour"},{l:"d",r:35},{l:"dd",r:25,d:"day"},{l:"M",r:45},{l:"MM",r:10,d:"month"},{l:"y",r:17},{l:"yy",d:"year"}],m=h.length,c=0;c<m;c+=1){var y=h[c];y.d&&(f=d?t(e).diff(i,y.d,!0):i.diff(e,y.d,!0));var p=(r.rounding||Math.round)(Math.abs(f));if(s=f>0,p<=y.r||!y.r){p<=1&&c>0&&(y=h[c-1]);var v=l[y.l];u&&(p=u(""+p)),a="string"==typeof v?v.replace("%d",p):v(p,n,y.l,s);break}}if(n)return a;var M=s?l.future:l.past;return "function"==typeof M?M(a):M.replace("%s",a)},n.to=function(r,e){return i(r,e,this,!0)},n.from=function(r,e){return i(r,e,this)};var d=function(r){return r.$u?t.utc():t()};n.toNow=function(r){return this.to(d(this),r)},n.fromNow=function(r){return this.from(d(this),r)};}}));
}(relativeTime$1));

var relativeTime = relativeTime$1.exports;

var duration$1 = {exports: {}};

(function (module, exports) {
!function(t,s){module.exports=s();}(this,(function(){var t,s,n=1e3,i=6e4,e=36e5,r=864e5,o=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,u=31536e6,h=2592e6,a=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/,d={years:u,months:h,days:r,hours:e,minutes:i,seconds:n,milliseconds:1,weeks:6048e5},c=function(t){return t instanceof p},f=function(t,s,n){return new p(t,n,s.$l)},m=function(t){return s.p(t)+"s"},l=function(t){return t<0},$=function(t){return l(t)?Math.ceil(t):Math.floor(t)},y=function(t){return Math.abs(t)},g=function(t,s){return t?l(t)?{negative:!0,format:""+y(t)+s}:{negative:!1,format:""+t+s}:{negative:!1,format:""}},p=function(){function l(t,s,n){var i=this;if(this.$d={},this.$l=n,void 0===t&&(this.$ms=0,this.parseFromMilliseconds()),s)return f(t*d[m(s)],this);if("number"==typeof t)return this.$ms=t,this.parseFromMilliseconds(),this;if("object"==typeof t)return Object.keys(t).forEach((function(s){i.$d[m(s)]=t[s];})),this.calMilliseconds(),this;if("string"==typeof t){var e=t.match(a);if(e){var r=e.slice(2).map((function(t){return Number(t)}));return this.$d.years=r[0],this.$d.months=r[1],this.$d.weeks=r[2],this.$d.days=r[3],this.$d.hours=r[4],this.$d.minutes=r[5],this.$d.seconds=r[6],this.calMilliseconds(),this}}return this}var y=l.prototype;return y.calMilliseconds=function(){var t=this;this.$ms=Object.keys(this.$d).reduce((function(s,n){return s+(t.$d[n]||0)*d[n]}),0);},y.parseFromMilliseconds=function(){var t=this.$ms;this.$d.years=$(t/u),t%=u,this.$d.months=$(t/h),t%=h,this.$d.days=$(t/r),t%=r,this.$d.hours=$(t/e),t%=e,this.$d.minutes=$(t/i),t%=i,this.$d.seconds=$(t/n),t%=n,this.$d.milliseconds=t;},y.toISOString=function(){var t=g(this.$d.years,"Y"),s=g(this.$d.months,"M"),n=+this.$d.days||0;this.$d.weeks&&(n+=7*this.$d.weeks);var i=g(n,"D"),e=g(this.$d.hours,"H"),r=g(this.$d.minutes,"M"),o=this.$d.seconds||0;this.$d.milliseconds&&(o+=this.$d.milliseconds/1e3);var u=g(o,"S"),h=t.negative||s.negative||i.negative||e.negative||r.negative||u.negative,a=e.format||r.format||u.format?"T":"",d=(h?"-":"")+"P"+t.format+s.format+i.format+a+e.format+r.format+u.format;return "P"===d||"-P"===d?"P0D":d},y.toJSON=function(){return this.toISOString()},y.format=function(t){var n=t||"YYYY-MM-DDTHH:mm:ss",i={Y:this.$d.years,YY:s.s(this.$d.years,2,"0"),YYYY:s.s(this.$d.years,4,"0"),M:this.$d.months,MM:s.s(this.$d.months,2,"0"),D:this.$d.days,DD:s.s(this.$d.days,2,"0"),H:this.$d.hours,HH:s.s(this.$d.hours,2,"0"),m:this.$d.minutes,mm:s.s(this.$d.minutes,2,"0"),s:this.$d.seconds,ss:s.s(this.$d.seconds,2,"0"),SSS:s.s(this.$d.milliseconds,3,"0")};return n.replace(o,(function(t,s){return s||String(i[t])}))},y.as=function(t){return this.$ms/d[m(t)]},y.get=function(t){var s=this.$ms,n=m(t);return "milliseconds"===n?s%=1e3:s="weeks"===n?$(s/d[n]):this.$d[n],0===s?0:s},y.add=function(t,s,n){var i;return i=s?t*d[m(s)]:c(t)?t.$ms:f(t,this).$ms,f(this.$ms+i*(n?-1:1),this)},y.subtract=function(t,s){return this.add(t,s,!0)},y.locale=function(t){var s=this.clone();return s.$l=t,s},y.clone=function(){return f(this.$ms,this)},y.humanize=function(s){return t().add(this.$ms,"ms").locale(this.$l).fromNow(!s)},y.milliseconds=function(){return this.get("milliseconds")},y.asMilliseconds=function(){return this.as("milliseconds")},y.seconds=function(){return this.get("seconds")},y.asSeconds=function(){return this.as("seconds")},y.minutes=function(){return this.get("minutes")},y.asMinutes=function(){return this.as("minutes")},y.hours=function(){return this.get("hours")},y.asHours=function(){return this.as("hours")},y.days=function(){return this.get("days")},y.asDays=function(){return this.as("days")},y.weeks=function(){return this.get("weeks")},y.asWeeks=function(){return this.as("weeks")},y.months=function(){return this.get("months")},y.asMonths=function(){return this.as("months")},y.years=function(){return this.get("years")},y.asYears=function(){return this.as("years")},l}();return function(n,i,e){t=e,s=e().$utils(),e.duration=function(t,s){var n=e.locale();return f(t,{$l:n},s)},e.isDuration=c;var r=i.prototype.add,o=i.prototype.subtract;i.prototype.add=function(t,s){return c(t)&&(t=t.asMilliseconds()),r.bind(this)(t,s)},i.prototype.subtract=function(t,s){return c(t)&&(t=t.asMilliseconds()),o.bind(this)(t,s)};}}));
}(duration$1));

var duration = duration$1.exports;

var advancedFormat = {exports: {}};

(function (module, exports) {
!function(e,t){module.exports=t();}(this,(function(){return function(e,t,r){var n=t.prototype,s=n.format;r.en.ordinal=function(e){var t=["th","st","nd","rd"],r=e%100;return "["+e+(t[(r-20)%10]||t[r]||t[0])+"]"},n.format=function(e){var t=this,r=this.$locale(),n=this.$utils(),a=(e||"YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,(function(e){switch(e){case"Q":return Math.ceil((t.$M+1)/3);case"Do":return r.ordinal(t.$D);case"gggg":return t.weekYear();case"GGGG":return t.isoWeekYear();case"wo":return r.ordinal(t.week(),"W");case"w":case"ww":return n.s(t.week(),"w"===e?1:2,"0");case"W":case"WW":return n.s(t.isoWeek(),"W"===e?1:2,"0");case"k":case"kk":return n.s(String(0===t.$H?24:t.$H),"k"===e?1:2,"0");case"X":return Math.floor(t.$d.getTime()/1e3);case"x":return t.$d.getTime();case"z":return "["+t.offsetName()+"]";case"zzz":return "["+t.offsetName("long")+"]";default:return e}}));return s.bind(this)(a)};}}));
}(advancedFormat));

var AdvancedFormat = advancedFormat.exports;

var quarterOfYear = {exports: {}};

(function (module, exports) {
!function(t,n){module.exports=n();}(this,(function(){var t="month",n="quarter";return function(e,i){var r=i.prototype;r.quarter=function(t){return this.$utils().u(t)?Math.ceil((this.month()+1)/3):this.month(this.month()%3+3*(t-1))};var s=r.add;r.add=function(e,i){return e=Number(e),this.$utils().p(i)===n?this.add(3*e,t):s.bind(this)(e,i)};var u=r.startOf;r.startOf=function(e,i){var r=this.$utils(),s=!!r.u(i)||i;if(r.p(e)===n){var o=this.quarter()-1;return s?this.month(3*o).startOf(t).startOf("day"):this.month(3*o+2).endOf(t).endOf("day")}return u.bind(this)(e,i)};}}));
}(quarterOfYear));

var QuarterOfYear = quarterOfYear.exports;

var isoWeek$1 = {exports: {}};

(function (module, exports) {
!function(e,t){module.exports=t();}(this,(function(){var e="day";return function(t,i,s){var a=function(t){return t.add(4-t.isoWeekday(),e)},d=i.prototype;d.isoWeekYear=function(){return a(this).year()},d.isoWeek=function(t){if(!this.$utils().u(t))return this.add(7*(t-this.isoWeek()),e);var i,d,n,o,r=a(this),u=(i=this.isoWeekYear(),d=this.$u,n=(d?s.utc:s)().year(i).startOf("year"),o=4-n.isoWeekday(),n.isoWeekday()>4&&(o+=7),n.add(o,e));return r.diff(u,"week")+1},d.isoWeekday=function(e){return this.$utils().u(e)?this.day()||7:this.day(this.day()%7?e:e-7)};var n=d.startOf;d.startOf=function(e,t){var i=this.$utils(),s=!!i.u(t)||t;return "isoweek"===i.p(e)?s?this.date(this.date()-(this.isoWeekday()-1)).startOf("day"):this.date(this.date()-1-(this.isoWeekday()-1)+7).endOf("day"):n.bind(this)(e,t)};}}));
}(isoWeek$1));

var isoWeek = isoWeek$1.exports;

// do the side-effect to extend it
dayjs.extend(AdvancedFormat);
dayjs.extend(QuarterOfYear);
dayjs.extend(utc);
dayjs.extend(LocalizedFormat);
dayjs.extend(duration);
dayjs.extend(relativeTime);
dayjs.extend(customParseFormat);
dayjs.extend(isoWeek);
/**
 * DayJS format for parsing mySQL datetime field
 */
const mysqlFormat = 'YYYY-MM-DD HH:mm:ss';
function getMinDate(dateOne, dateTwo, format) {
    if (dateOne === '') {
        return dateOne;
    }
    if (dateTwo === '') {
        return dateTwo;
    }
    const dateOneObj = dayjs(dateOne, format);
    const dateTwoObj = dayjs(dateTwo, format);
    if (dateOneObj.isBefore(dateTwoObj)) {
        return dateOne;
    }
    return dateTwo;
}
function getMaxDate(dateOne, dateTwo, format) {
    if (dateOne === '') {
        return dateTwo;
    }
    if (dateTwo === '') {
        return dateOne;
    }
    const dateOneObj = dayjs(dateOne, format);
    const dateTwoObj = dayjs(dateTwo, format);
    if (dateOneObj.isAfter(dateTwoObj)) {
        return dateOne;
    }
    return dateTwo;
}
function getDefaultDateTimeFormatString(pickerType) {
    // figure out the dateTimeFormat
    let dateTimeFormat;
    if (pickerType === 'datetime') {
        dateTimeFormat = 'YYYY-MM-DD HH:mm:ss';
    }
    else if (pickerType === 'date') {
        dateTimeFormat = 'YYYY-MM-DD';
    }
    else {
        dateTimeFormat = 'HH:mm:ss';
    }
    return dateTimeFormat;
}
/**
 * Parse possible mysql datetime string.
 *
 * @param input Input string.
 * @returns String if parsed properly. False otherwise.
 */
function parsePossibleMySQLDateTimeString(input) {
    const dt = dayjs.utc(input, mysqlFormat);
    if (dt.isValid()) {
        return dt.format(mysqlFormat);
    }
    return undefined;
}
function parsePossibleDateTimeFormula(input, currentTime) {
    if (!input) {
        return undefined;
    }
    // if it is just current
    if (input.toLowerCase().trim() === 'current') {
        return dayjs.unix(currentTime ?? dayjs.utc().unix()).format(mysqlFormat);
    }
    const matches = input.match(/\s?(current)\s?(-|\+)\s?(\d+)\s?(second|minute|hour|day|month)s?/i);
    if (matches) {
        const compareTime = currentTime ?? dayjs.utc().unix();
        const operator = matches[2].trim() === '-' ? -1 : 1;
        const number = Number.parseInt(matches[3], 10);
        const unit = matches[4].trim();
        const unitToSecondMap = {
            second: 1,
            minute: 1 * 60,
            hour: 1 * 60 * 60,
            day: 1 * 24 * 60 * 60,
        };
        logger.debug(`matched formula == operator: ${operator}, number: ${number}, unit: ${unit}`);
        const formulaTime = compareTime +
            number * unitToSecondMap[unit] * operator;
        const dt = dayjs.unix(formulaTime);
        return dt.format(mysqlFormat);
    }
    return parsePossibleMySQLDateTimeString(input);
}
/**
 * Compare two datetime string. Both must be in mySQL compatible datetime
 * format. Returns 1 if $compare_with is greater than $compare_to, 0 if both
 * are equal, and -1 if $compare_with is less than $compare_to. If at-least one
 * of them in invalid format, then returns NULL.
 *
 * @param compareWith With value.
 * @param compareTo To value.
 * @return null|int
 */
function compareDates(compareWith, compareTo) {
    const withVal = dayjs(compareWith, mysqlFormat);
    const toVal = dayjs(compareTo, mysqlFormat);
    if (!withVal.isValid() || !toVal.isValid()) {
        return null;
    }
    const diff = withVal.diff(toVal);
    if (diff > 0) {
        return 1;
    }
    if (diff === 0) {
        return 0;
    }
    return -1;
}
function getDayjsFromMySQLInput(value) {
    return dayjs(value, mysqlFormat);
}

function useSlateJsonDynamicAnchors(jsonDynamicAnchors, additionalAnchors) {
    return useMemo(() => {
        let links = {};
        try {
            const ams = JSON.parse(jsonDynamicAnchors ?? '');
            if (typeof ams === 'object' && Object.keys(ams).length) {
                // Add redirect to login and logout links
                if (ams['%LOGIN_LINK%']) {
                    const loginInLink = new URL(ams['%LOGIN_LINK%']);
                    loginInLink.searchParams.append('redirect_to', window.location.href);
                    ams['%LOGIN_LINK%'] = loginInLink.toString();
                }
                if (ams['%LOGOUT_LINK%']) {
                    const logOutLink = new URL(ams['%LOGOUT_LINK%']);
                    logOutLink.searchParams.append('redirect_to', window.location.href);
                    ams['%LOGOUT_LINK%'] = logOutLink.toString();
                }
                links = ams;
            }
        }
        catch (e) {
            // do nothing
        }
        if (additionalAnchors) {
            links = {
                ...links,
                ...additionalAnchors,
            };
        }
        return links;
    }, [jsonDynamicAnchors, additionalAnchors]);
}
function useSlateJsonMentions(jsonMentions, additionalMentions) {
    return useMemo(() => {
        let record = {};
        try {
            const ams = JSON.parse(jsonMentions ?? '');
            if (typeof ams === 'object' && Object.keys(ams).length) {
                if (ams['::submissionStartDate::']) {
                    ams['::submissionStartDate::'] = dayjs
                        .utc(ams['::submissionStartDate::'])
                        .local()
                        .format('LLL');
                }
                if (ams['::submissionEndDate::']) {
                    ams['::submissionEndDate::'] = dayjs
                        .utc(ams['::submissionEndDate::'])
                        .local()
                        .format('LLL');
                }
                record = ams;
            }
        }
        catch (e) {
            // do nothing
        }
        // Now append additional mentions if any
        if (additionalMentions) {
            record = {
                ...record,
                ...additionalMentions,
            };
        }
        return record;
    }, [jsonMentions, additionalMentions]);
}
function getDesignation(type, designations, score) {
    let possibleReturn = null;
    designations.forEach(des => {
        if (des.scoreCategory === score.id) {
            // calculate
            let currentScoreRangeCheckVal = score.obtained;
            if (des.fromToType === ScoreFromToTypeEnum.PERCENTAGE) {
                currentScoreRangeCheckVal = (score.obtained / score.outof) * 100;
            }
            if (Number.isFinite(currentScoreRangeCheckVal) &&
                currentScoreRangeCheckVal >= des.from &&
                currentScoreRangeCheckVal <= des.to) {
                if (type === 'name') {
                    possibleReturn = (jsx(SlateView, { mode: "singleline", nodes: getNodesFromJSON(des.name) }, void 0));
                }
                else {
                    possibleReturn = (jsx(SlateView, { mode: "multiline", nodes: getNodesFromJSON(des.description) }, void 0));
                }
            }
        }
    });
    return possibleReturn;
}
function getScoreMentionsResult(mentionsCharacter, scoresObtained, scoreSettings) {
    if (scoresObtained &&
        scoresObtained.length &&
        scoreSettings?.scoreLists.length) {
        if (scoresObtained.length) {
            const scoreSubmissionDataDictionary = convertListToDictionary(scoresObtained.map(s => ({
                id: s.scoreId,
                has: s.has,
                obtained: s.obtained,
                outof: s.outof,
            })));
            let highestScoreId = null;
            Object.keys(scoreSubmissionDataDictionary).forEach(sKey => {
                const sData = scoreSubmissionDataDictionary[sKey];
                if (sData.has) {
                    if (!highestScoreId) {
                        highestScoreId = sKey;
                    }
                    else {
                        const lastScorePercentage = scoreSubmissionDataDictionary[highestScoreId].obtained /
                            scoreSubmissionDataDictionary[highestScoreId].outof;
                        const currentScorePercentage = sData.obtained / sData.outof;
                        if (Number.isFinite(currentScorePercentage) &&
                            Number.isFinite(lastScorePercentage) &&
                            currentScorePercentage > lastScorePercentage) {
                            highestScoreId = sKey;
                        }
                    }
                }
            });
            // Now return stuff
            if (highestScoreId) {
                const highestScoreData = scoreSettings.scoreLists.find(sl => sl.id === highestScoreId);
                if (mentionsCharacter === '::score-obtained-high::') {
                    return formatNumber(scoreSubmissionDataDictionary[highestScoreId].obtained, scoreSettings.precision);
                }
                if (mentionsCharacter === '::score-outof-high::') {
                    return formatNumber(scoreSubmissionDataDictionary[highestScoreId].outof, scoreSettings.precision);
                }
                if (mentionsCharacter === '::score-name-high::') {
                    return (jsx(SlateView, { nodes: getNodesFromJSON(highestScoreData?.outcomeName), mode: "singleline" }, void 0));
                }
                if (mentionsCharacter === '::score-description-high::') {
                    return (jsx(SlateView, { nodes: getNodesFromJSON(highestScoreData?.outcomeDescription), mode: "multiline" }, void 0));
                }
                if (mentionsCharacter === '::score-designation-high::') {
                    return getDesignation('name', scoreSettings.designations, scoreSubmissionDataDictionary[highestScoreId]);
                }
                if (mentionsCharacter === '::score-designationd-high::') {
                    return getDesignation('description', scoreSettings.designations, scoreSubmissionDataDictionary[highestScoreId]);
                }
            }
            let possibleScoreNode = null;
            scoreSettings.scoreLists.forEach(score => {
                const scoreId = score.id;
                if (mentionsCharacter === `::score-name-${scoreId}::`) {
                    possibleScoreNode = (jsx(SlateView, { nodes: getNodesFromJSON(score.outcomeName), mode: "singleline" }, void 0));
                }
                else if (mentionsCharacter === `::score-description-${scoreId}::`) {
                    possibleScoreNode = (jsx(SlateView, { nodes: getNodesFromJSON(score.outcomeDescription), mode: "multiline" }, void 0));
                }
                else if (mentionsCharacter === `::score-obtained-${scoreId}::`) {
                    possibleScoreNode = formatNumber(scoreSubmissionDataDictionary[scoreId]?.obtained, scoreSettings.precision);
                }
                else if (mentionsCharacter === `::score-outof-${scoreId}::`) {
                    possibleScoreNode = formatNumber(scoreSubmissionDataDictionary[scoreId]?.outof, scoreSettings.precision);
                }
                else if (mentionsCharacter === `::score-designation-${scoreId}::`) {
                    possibleScoreNode = getDesignation('name', scoreSettings.designations, scoreSubmissionDataDictionary[scoreId]);
                }
                else if (mentionsCharacter === `::score-designationd-${scoreId}::`) {
                    possibleScoreNode = getDesignation('description', scoreSettings.designations, scoreSubmissionDataDictionary[scoreId]);
                }
            });
            return possibleScoreNode;
        }
    }
    return null;
}
function getSlateMentionsOnElementsAndScore(elementId, elementsSubmissionData, elementsConfig, primitives, scoreSettings, scoresObtained) {
    const elementSubmissionData = elementsSubmissionData[elementId];
    const elementConfig = elementsConfig[elementId];
    if (elementConfig &&
        elementSubmissionData &&
        elementSubmissionData.errors.length === 0 &&
        wpEFormElementFrontCollection.hasItem(elementSubmissionData.type)) {
        const elmDef = wpEFormElementFrontCollection.getItem(elementSubmissionData.type);
        if (elmDef.getDisplayValue) {
            return elmDef.getDisplayValue(elementConfig, elementSubmissionData.value);
        }
    }
    // Now do mutationData dependent
    if (primitives &&
        typeof primitives[elementId] === 'string') {
        return primitives[elementId];
    }
    // TODO: Add others from form-builder/components/BuilderRichEditor/mentions.ts
    // pre-calculate score related stuff
    if (elementId.startsWith('::score')) {
        return getScoreMentionsResult(elementId, scoresObtained, scoreSettings);
    }
    return null;
}
function SlateViewWithData(props) {
    const { mode = 'singleline', nodes, currentElementId, jsonMentions, jsonDynamicAnchorTags, additionalMentions, additionalAnchors, } = props;
    const excludeMentionsCharacters = useMemo(() => {
        return currentElementId ? [currentElementId] : [];
    }, [currentElementId]);
    const parsedMentions = useSlateJsonMentions(jsonMentions, additionalMentions);
    const parsedDynamicAnchorTags = useSlateJsonDynamicAnchors(jsonDynamicAnchorTags, additionalAnchors);
    return (jsx(SlateView, { mode: mode, nodes: nodes, excludeMentionsCharacters: excludeMentionsCharacters, additionalMentions: parsedMentions, additionalDynamicAnchorTags: parsedDynamicAnchorTags }, void 0));
}
function SlateViewWithoutMentions(props) {
    const { mode = 'singleline', nodes } = props;
    return jsx(SlateView, { mode: mode, nodes: nodes, renderMentions: false }, void 0);
}
function useNodesFromJson(json) {
    const nodes = useMemo(() => {
        const parsed = getNodesFromJSON(json);
        if (isNodesEmpty(parsed)) {
            return false;
        }
        return parsed;
    }, [json]);
    return nodes;
}

const dynamicAnchorContext = createContext({});
function DynamicAnchorProvider(props) {
    const { children, dynamicAnchors } = props;
    return (jsx(dynamicAnchorContext.Provider, Object.assign({ value: dynamicAnchors }, { children: children }), void 0));
}
function LeafRenderer(props) {
    const { leaf } = props;
    if (!leaf) {
        return null;
    }
    let childrenToRender = leaf.text;
    if (leaf.bold) {
        childrenToRender = jsx("strong", { children: childrenToRender }, void 0);
    }
    if (leaf.italic) {
        childrenToRender = jsx("em", { children: childrenToRender }, void 0);
    }
    if (leaf.underline) {
        childrenToRender = jsx("u", { children: childrenToRender }, void 0);
    }
    if (leaf.strikethrough) {
        childrenToRender = jsx("s", { children: childrenToRender }, void 0);
    }
    if (leaf.code) {
        childrenToRender = jsx("code", { children: childrenToRender }, void 0);
    }
    if (leaf.sup) {
        childrenToRender = jsx("sup", { children: childrenToRender }, void 0);
    }
    if (leaf.sub) {
        childrenToRender = jsx("sub", { children: childrenToRender }, void 0);
    }
    if (leaf.color) {
        childrenToRender = (jsx("span", Object.assign({ style: { color: leaf.color } }, { children: childrenToRender }), void 0));
    }
    if (leaf.fz) {
        childrenToRender = (jsx("span", Object.assign({ style: { fontSize: `${leaf.fz}%` } }, { children: childrenToRender }), void 0));
    }
    return jsx("span", { children: childrenToRender }, void 0);
}
function ElementRenderer(props) {
    const { element, mode, excludeMentionsCharacters = [], renderMentions, additionalMentions, additionalDynamicAnchorTags, } = props;
    const dynamicAnchors = useContext(dynamicAnchorContext);
    let href;
    if (!element) {
        return null;
    }
    const children = element.children ? (
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    jsx(RecursiveSlateRenderer, Object.assign({ mode: mode, excludeMentionsCharacters: excludeMentionsCharacters, renderMentions: renderMentions, additionalMentions: additionalMentions, additionalDynamicAnchorTags: additionalDynamicAnchorTags }, { children: element.children }), void 0)) : null;
    switch (element.type) {
        // built-ins defaults
        case 'blockquote':
            return (jsx("blockquote", Object.assign({ style: getStyleWithAlignment(element.align) }, { children: children }), void 0));
        case 'bulleted-list':
            return (jsx("ul", Object.assign({ style: getStyleWithAlignment(element.align) }, { children: children }), void 0));
        case 'heading-one':
            return (jsx("h1", Object.assign({ style: getStyleWithAlignment(element.align) }, { children: children }), void 0));
        case 'heading-two':
            return (jsx("h2", Object.assign({ style: getStyleWithAlignment(element.align) }, { children: children }), void 0));
        case 'heading-three':
            return (jsx("h3", Object.assign({ style: getStyleWithAlignment(element.align) }, { children: children }), void 0));
        case 'heading-four':
            return (jsx("h4", Object.assign({ style: getStyleWithAlignment(element.align) }, { children: children }), void 0));
        case 'heading-five':
            return (jsx("h5", Object.assign({ style: getStyleWithAlignment(element.align) }, { children: children }), void 0));
        case 'heading-six':
            return (jsx("h6", Object.assign({ style: getStyleWithAlignment(element.align) }, { children: children }), void 0));
        case 'preformatted':
            return jsx("pre", { children: children }, void 0);
        case 'list-item':
            return jsx("li", { children: children }, void 0);
        case 'numbered-list':
            return (jsx("ol", Object.assign({ style: getStyleWithAlignment(element.align) }, { children: children }), void 0));
        // for plugins/link.ts
        case 'link':
            href = element.url;
            if (dynamicAnchors[href]) {
                href = dynamicAnchors[href];
            }
            if (additionalDynamicAnchorTags && additionalDynamicAnchorTags[href]) {
                href = additionalDynamicAnchorTags[href];
            }
            return (jsx("a", Object.assign({ href: href, title: element.title, target: (element.target || '_self'), rel: element.rel }, { children: children }), void 0));
        case 'media':
            return jsx(Media, { element: element }, void 0);
        case 'latex':
            return jsx(LatexRenderer, { element: element }, void 0);
        case 'mentions':
            if (renderMentions === false) {
                return jsx(MentionsContainer, Object.assign({ empty: true }, { children: "\u2026" }), void 0);
            }
            if (excludeMentionsCharacters.includes(element.character)) {
                return (jsx(MentionsContainer, Object.assign({ empty: true }, { children: __('ERROR: cannot render an element inside the same element.', 'wp-eform') }), void 0));
            }
            return (jsx(MentionsRenderer, { additionalMentions: additionalMentions, element: element }, void 0));
        case 'paragraph':
        default:
            return mode === 'multiline' ? (jsx("div", Object.assign({ className: "para", style: getStyleWithAlignment(element.align) }, { children: children }), void 0)) : (jsx("span", Object.assign({ style: getStyleWithAlignment(element.align) }, { children: children }), void 0));
    }
}
function RecursiveSlateRenderer(props) {
    const { children, mode, excludeMentionsCharacters, renderMentions, additionalMentions, additionalDynamicAnchorTags, } = props;
    // bail out for empty children
    if (!children || !children.length) {
        return null;
    }
    return (jsx(Fragment, { children: children.map((child, index) => {
            if (Text$4.isText(child)) {
                return jsx(LeafRenderer, { leaf: child }, index);
            }
            return (jsx(ElementRenderer, { excludeMentionsCharacters: excludeMentionsCharacters, mode: mode, element: child, renderMentions: renderMentions, additionalMentions: additionalMentions, additionalDynamicAnchorTags: additionalDynamicAnchorTags }, index));
        }) }, void 0));
}
/**
 * A component to that takes in SlateJS Nodes and renders corresponding
 * ReactNodes that our application understands. Pass saved values of all
 * RichEditor controls through this component and it will show up properly in
 * the application.
 */
function SlateView(props) {
    const { nodes, mode, className, excludeMentionsCharacters, renderMentions = true, additionalMentions, additionalDynamicAnchorTags, } = props;
    if (isNodesEmpty(nodes)) {
        return null;
    }
    return (jsx(SlateViewContainer, Object.assign({ className: getBemClassName(CONTROLCLASS$m, {
            inline: mode === 'singleline',
        }, className), as: mode === 'singleline' ? 'span' : 'div' }, { children: mode === 'multiline' ? (jsx(RecursiveSlateRenderer, Object.assign({ excludeMentionsCharacters: excludeMentionsCharacters, mode: mode, renderMentions: renderMentions, additionalMentions: additionalMentions, additionalDynamicAnchorTags: additionalDynamicAnchorTags }, { children: nodes }), void 0)) : (jsx(RecursiveSlateRenderer, Object.assign({ excludeMentionsCharacters: excludeMentionsCharacters, mode: mode, renderMentions: renderMentions, additionalMentions: additionalMentions, additionalDynamicAnchorTags: additionalDynamicAnchorTags }, { children: [nodes[0]] }), void 0)) }), void 0));
}

const CONTROLCLASS$3 = 'wpeform-component-optiongroup';
const OptionItemContainer = styled.div `
	flex: 0 0 auto;
	width: auto;
	max-width: 100%;
	padding: ${props => numToCssSize(props.theme.gutter / 4)};
`;
const OptionGroupContainerInner = styled.div `
	margin: ${props => numToCssSize(props.theme.gutter / -2)};
	display: flex;
	flex-flow: row wrap;
`;
const OptionGroupContainer = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter / 4)};

	&.${CONTROLCLASS$3}--column-AUTO {
		// FIX iOS bug
		${OptionItemContainer} {
			.${CONTROLCLASS$m}--inline {
				display: inline-block;
				width: 102%;
				&:hover {
					display: inline-block;
					width: 102%;
				}
				.${CONTROLCLASS$m}--inline {
					display: inline;
					width: auto;
					&:hover {
						display: inline;
						width: auto;
					}
				}
			}
		}
	}

	&.${CONTROLCLASS$3}--column-AUTO.${CONTROLCLASS$3}--align-CENTER {
		${OptionGroupContainerInner} {
			justify-content: center;
		}
	}
	&.${CONTROLCLASS$3}--column-AUTO.${CONTROLCLASS$3}--align-RIGHT {
		${OptionGroupContainerInner} {
			justify-content: flex-end;
		}
	}

	/** Sizes */
	&.${CONTROLCLASS$3}--column-FOUR,
		&.${CONTROLCLASS$3}--column-THREE,
		&.${CONTROLCLASS$3}--column-TWO,
		&.${CONTROLCLASS$3}--column-ONE {
		${OptionItemContainer} {
			flex-basis: 100%;
			width: 100%;
		}
	}

	/** Tablet layout */
	&.${CONTROLCLASS$3}--size-tablet {
		&.${CONTROLCLASS$3}--column-FOUR,
			&.${CONTROLCLASS$3}--column-THREE,
			&.${CONTROLCLASS$3}--column-TWO {
			${OptionItemContainer} {
				flex-basis: 50%;
				width: 50%;
			}
		}
	}
	/** Desktop layout */
	&.${CONTROLCLASS$3}--size-desktop {
		&.${CONTROLCLASS$3}--column-FOUR {
			${OptionItemContainer} {
				flex-basis: 25%;
				width: 25%;
			}
		}
		&.${CONTROLCLASS$3}--column-THREE {
			${OptionItemContainer} {
				flex-basis: 33.333333%;
				width: 33.333333%;
			}
		}
		&.${CONTROLCLASS$3}--column-TWO {
			${OptionItemContainer} {
				flex-basis: 50%;
				width: 50%;
			}
		}
	}
`;
/**
 * An OptionGroup component to group options of `Checkbox` or `Radio`
 * buttons by column alignment on different container sizes. It expects
 * all children to be `OptionGroup.Item` for proper alignment. Like
 *
 * ```jsx
 * <OptionGroup>
 * 	<OptionGroup.Item>Option 1</OptionGroup.Item>
 * 	<OptionGroup.Item>Option 2</OptionGroup.Item>
 * 	<OptionGroup.Item>Option 3</OptionGroup.Item>
 * 	<OptionGroup.Item>Option 4</OptionGroup.Item>
 * </OptionGroup>
 * ```
 */
function OptionGroup(props) {
    const { columns, children, controlAlignment } = props;
    const size = useContainerSize();
    const className = useResponsiveClassNames(size, CONTROLCLASS$3, {
        [`column-${columns}`]: true,
        [`align-${controlAlignment}`]: true,
    });
    return (jsx(OptionGroupContainer, Object.assign({ className: className }, { children: jsx(OptionGroupContainerInner, { children: children }, void 0) }), void 0));
}
OptionGroup.Item = OptionItemContainer;

const Container = styled.div `
	${cssReset};
	font-family: ${props => props.theme.fontFamilyBody};
	padding: ${props => numToCssSize(props.theme.gutter)};
	background-color: ${props => props.theme.appBackgroundColor};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border: 1px solid ${props => props.theme.borderColorLight};
`;
function Wrapper(props) {
    return jsx(Container, { children: props.children }, void 0);
}

const SkeletonContainer$1 = styled.div `
	${cssReset}
	margin: 0 auto;
`;
function PreviewToolbar() {
    const theme = useTheme();
    return (jsxs(Fragment, { children: [jsx(Skeleton, { shape: "rectangle", height: 32 + theme.gutter / 2, width: "100%", marginBottom: "small" }, void 0), jsx(Skeleton, { shape: "rectangle", height: 2, width: "100%", marginBottom: "large" }, void 0)] }, void 0));
}
function PreviewHeader() {
    return (jsxs(Fragment, { children: [jsx(PreviewToolbar, {}, void 0), jsx(Skeleton, { shape: "rectangle", height: 167, width: "100%", marginBottom: "large" }, void 0)] }, void 0));
}
// seeded value for consistency
const headingWidthSet = [
    52, 36, 49, 65, 42, 63, 86, 38, 75, 57, 43, 51, 85, 72, 44, 55, 45, 59, 75,
    76,
];
function PreviewControl(props) {
    const theme = useTheme();
    const { widthSet } = props;
    const headingWidth = headingWidthSet[(widthSet % headingWidthSet.length) - 1];
    return (jsxs(Fragment, { children: [jsx(Skeleton, { shape: "rectangle", width: `${headingWidth}%`, height: theme.fz.base * 1.5, marginBottom: "small" }, void 0), jsx(Skeleton, { shape: "rectangle", width: "100%", height: 92, marginBottom: "large" }, void 0), jsx(Skeleton, { shape: "rectangle", width: "100%", height: 2, marginBottom: "large" }, void 0)] }, void 0));
}
function PreviewPage(props) {
    const theme = useTheme();
    const controls = [];
    for (let i = 0; i < props.controls; i++) {
        controls.push(jsx(PreviewControl, { widthSet: i + 1 }, i));
    }
    return (jsxs(Fragment, { children: [jsx(Skeleton, { shape: "rectangle", height: theme.fz.small1 * 1.5 + theme.gutter / 6, width: "100%", marginBottom: theme.gutter / 6 }, void 0), jsx(Skeleton, { shape: "rectangle", height: 1, width: "100%", marginBottom: "large" }, void 0), controls] }, void 0));
}
const CONTROLCLASS$2 = 'wpeform-component-submissionskeleton';
function SubmissionSkeleton(props) {
    const { panels = 2, controls = 5 } = props;
    const pages = [];
    for (let i = 0; i < panels; i++) {
        pages.push(jsx(PreviewPage, { controls: i === 0 ? controls : 3 }, i));
    }
    return (jsx(SkeletonContainer$1, Object.assign({ className: CONTROLCLASS$2 }, { children: jsxs(Wrapper, { children: [jsx(PreviewHeader, {}, void 0), pages] }, void 0) }), void 0));
}
SubmissionSkeleton.PreviewToolbar = PreviewToolbar;

const CONTROLCLASS$1 = 'wpeform-component-formskeleton';
const SkeletonWrapper = styled.div `
	${cssReset};
`;
const SkeletonContainer = styled.div `
	margin: 0 auto;
	box-shadow: ${props => props.theme.boxShadow4dp};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	overflow: hidden;
`;
const SkeletonTabsContainer = styled.div `
	background-color: ${props => curriedLighten(0.003, props.theme.backgroundControl)};
	width: 100%;
	overflow: hidden;
	border-top-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-top-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	padding: 0 ${props => numToCssSize(props.theme.gutter)} 0 0;
`;
const SkeletonTabsButtonsContainer = styled.div `
	height: ${props => numToCssSize(props.theme.controlHeightBase * 1.25)};
	overflow: hidden;
	display: flex;
	flex-flow: row nowrap;
	align-items: center;
`;
const TabButtonContainer = styled.div `
	display: flex;
	flex-flow: row nowrap;
	width: 150px;
	padding: 0 ${props => numToCssSize(props.theme.gutter)};
	align-items: center;
	justify-content: flex-start;
`;
const TabButtonIcon = styled.div `
	flex: 0 0 ${props => numToCssSize(props.theme.fz.large3)};
	width: ${props => numToCssSize(props.theme.fz.large3)};
	margin: 0 ${props => numToCssSize(props.theme.gutter / 2)} 0 0;
`;
const TabButtonLabels = styled.div `
	flex: 0 0
		calc(
			100% -
				${props => numToCssSize(props.theme.gutter / 2 + props.theme.fz.large3)}
		);
	display: flex;
	flex-flow: column nowrap;
	justify-content: space-between;
	align-items: flex-start;
`;
function TabButton() {
    const theme = useTheme();
    return (jsxs(TabButtonContainer, { children: [jsx(TabButtonIcon, { children: jsx(Skeleton.Avatar, { height: theme.fz.large3, color: "darker" }, void 0) }, void 0), jsxs(TabButtonLabels, { children: [jsx(Skeleton, { height: theme.fz.large1, shape: "rectangle", width: "50px", marginBottom: theme.gutter * 0.25, color: "darker" }, void 0), jsx(Skeleton, { height: theme.fz.small2, shape: "rectangle", width: "90px", color: "darker" }, void 0)] }, void 0)] }, void 0));
}
// seeded value for consistency
const headingWidthsSet = [
    { title: 48, subtitle: 68 },
    { title: 33, subtitle: 68 },
    { title: 36, subtitle: 68 },
    { title: 31, subtitle: 62 },
    { title: 29, subtitle: 61 },
    { title: 36, subtitle: 61 },
    { title: 36, subtitle: 51 },
    { title: 21, subtitle: 57 },
    { title: 32, subtitle: 56 },
    { title: 33, subtitle: 59 },
    { title: 24, subtitle: 58 },
    { title: 37, subtitle: 52 },
    { title: 22, subtitle: 60 },
    { title: 21, subtitle: 54 },
    { title: 29, subtitle: 59 },
    { title: 25, subtitle: 56 },
    { title: 37, subtitle: 55 },
    { title: 38, subtitle: 63 },
    { title: 43, subtitle: 68 },
    { title: 49, subtitle: 53 },
];
// seeded value for consistency
const mcqWidthSet = [
    [172, 128, 140, 149],
    [197, 167, 74, 137],
    [145, 108, 140, 166],
    [178, 101, 108, 148],
    [140, 194, 114, 105],
    [138, 123, 170, 115],
    [148, 107, 129, 165],
    [129, 192, 140, 137],
    [109, 186, 175, 81],
    [87, 166, 68, 154],
    [194, 199, 110, 193],
    [133, 75, 93, 86],
    [114, 108, 173, 82],
    [154, 126, 98, 110],
    [168, 196, 183, 106],
    [92, 147, 170, 178],
    [92, 144, 138, 70],
    [112, 119, 149, 116],
    [172, 187, 114, 162],
    [153, 107, 150, 153],
];
function Radios(props) {
    const { widthSet } = props;
    const controlWidths = mcqWidthSet[(widthSet % mcqWidthSet.length) - 1];
    return (jsxs(OptionGroup, Object.assign({ columns: OptionColumnEnum.ONE, controlAlignment: SettingsAppearanceControlAlignmentEnum.LEFT }, { children: [jsx(OptionGroup.Item, { children: jsx(Skeleton.MCQOption, { type: "radio", width: controlWidths[0] }, void 0) }, void 0), jsx(OptionGroup.Item, { children: jsx(Skeleton.MCQOption, { type: "radio", width: controlWidths[1] }, void 0) }, void 0)] }), void 0));
}
function Checkboxes(props) {
    const { widthSet } = props;
    const controlWidths = mcqWidthSet[(widthSet % mcqWidthSet.length) - 1];
    return (jsxs(OptionGroup, Object.assign({ columns: OptionColumnEnum.ONE, controlAlignment: SettingsAppearanceControlAlignmentEnum.LEFT }, { children: [jsx(OptionGroup.Item, { children: jsx(Skeleton.MCQOption, { type: "checkbox", width: controlWidths[0] }, void 0) }, void 0), jsx(OptionGroup.Item, { children: jsx(Skeleton.MCQOption, { type: "checkbox", width: controlWidths[1] }, void 0) }, void 0), jsx(OptionGroup.Item, { children: jsx(Skeleton.MCQOption, { type: "checkbox", width: controlWidths[2] }, void 0) }, void 0), jsx(OptionGroup.Item, { children: jsx(Skeleton.MCQOption, { type: "checkbox", width: controlWidths[3] }, void 0) }, void 0)] }), void 0));
}
function FormControlHeading(props) {
    const { widthSet } = props;
    const { title, subtitle } = headingWidthsSet[(widthSet % headingWidthsSet.length) - 1];
    return (jsx(Skeleton.Label, { titleWidth: `${title}%`, subtitleWidth: `${subtitle}%` }, void 0));
}
function FormControl(props) {
    const { type, widthSet } = props;
    return (jsx(Grid.Item, Object.assign({ columnSize: WidthPresetsEnum.FULL, widths: [] }, { children: jsxs(Grid.Gutter, { children: [jsx(FormControlHeading, { widthSet: widthSet }, void 0), type === 'checkbox' ? (jsx(Checkboxes, { widthSet: widthSet }, void 0)) : type === 'radio' ? (jsx(Radios, { widthSet: widthSet }, void 0)) : type === 'input' ? (jsx(Skeleton.Text, {}, void 0)) : (jsx(Skeleton.Textarea, {}, void 0))] }, void 0) }), void 0));
}
function FormHeader(props) {
    const { panels = 3 } = props;
    const tabPanels = [];
    if (panels >= 1) {
        for (let i = 0; i < panels; i++) {
            tabPanels.push(jsx(TabButton, {}, i));
        }
    }
    else {
        tabPanels.push(jsx(TabButton, {}, "1"));
    }
    return (jsx(SkeletonTabsContainer, { children: jsx(SkeletonTabsButtonsContainer, { children: tabPanels }, void 0) }, void 0));
}
function FormBody(props) {
    const { controls = 5 } = props;
    const formControls = [];
    if (controls < 1) {
        formControls.push(jsx(FormControl, { widthSet: 1, type: "radio" }, "0"));
    }
    if (controls >= 1) {
        formControls.push(jsx(FormControl, { widthSet: 1, type: "radio" }, "1"));
    }
    if (controls >= 2) {
        formControls.push(jsx(FormControl, { widthSet: 2, type: "input" }, "2"));
    }
    if (controls >= 3) {
        formControls.push(jsx(FormControl, { widthSet: 3, type: "checkbox" }, "3"));
    }
    if (controls >= 4) {
        formControls.push(jsx(FormControl, { widthSet: 4, type: "textarea" }, "4"));
    }
    if (controls >= 5) {
        formControls.push(jsx(FormControl, { widthSet: 5, type: "radio" }, "5"));
    }
    return jsx(Fragment, { children: formControls }, void 0);
}
const SkeletonTabsPanelContainer = styled.div `
	background-color: ${props => props.theme.appBackgroundColor};
	border-bottom-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-bottom-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
`;
function FormSkeleton({ panels = 3, controls = 5, hasEditHeader = false, }) {
    return (jsxs(SkeletonWrapper, Object.assign({ className: CONTROLCLASS$1 }, { children: [hasEditHeader ? jsx(SubmissionSkeleton.PreviewToolbar, {}, void 0) : null, jsxs(SkeletonContainer, { children: [jsx(FormHeader, { panels: panels }, void 0), jsx(SkeletonTabsPanelContainer, { children: jsx(Grid, { children: jsx(FormBody, { controls: Math.max(2, controls) }, void 0) }, void 0) }, void 0)] }, void 0)] }), void 0));
}
FormSkeleton.FormControl = FormControl;

// 403
function AuthErrorIcon(props) {
    return (jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: 512, height: 512, viewBox: "0 0 512 512" }, props, { children: jsx("path", { d: "M46 181c0 16.436 95.391 60 210 60s210-43.564 210-60c0-7.48-20.206-7.368-28.154-7.368-13.975 0-32.915 1.084-59.209 2.681C344.389 178.393 301.791 181 256 181s-88.389-2.607-122.783-4.702c-26.177-1.582-45.103-2.666-59.092-2.666-7.983 0-28.125-.159-28.125 7.368zM15 512h482c8.291 0 15-6.709 15-15V286c0-8.291-6.709-15-15-15H15c-8.291 0-15 6.709-15 15v211c0 8.291 6.709 15 15 15zm331-91h90c8.291 0 15 6.709 15 15s-6.709 15-15 15h-90c-8.291 0-15-6.709-15-15s6.709-15 15-15zm-136.465-39.507c-7.178-4.146-9.639-13.315-5.493-20.493 4.131-7.192 13.315-9.653 20.493-5.493L241 365.014V346c0-8.291 6.709-15 15-15s15 6.709 15 15v19.014l16.465-9.507c7.148-4.16 16.333-1.699 20.493 5.493 4.146 7.178 1.685 16.348-5.493 20.493L286.002 391l16.463 9.507c7.178 4.146 9.639 13.315 5.493 20.493-4.149 7.183-13.341 9.624-20.493 5.493L271 416.986V436c0 8.291-6.709 15-15 15s-15-6.709-15-15v-19.014l-16.465 9.507c-7.139 4.124-16.337 1.703-20.493-5.493-4.146-7.178-1.685-16.348 5.493-20.493L225.998 391l-16.463-9.507zm-150 0c-7.178-4.146-9.639-13.315-5.493-20.493 4.131-7.192 13.301-9.653 20.493-5.493L91 365.014V346c0-8.291 6.709-15 15-15s15 6.709 15 15v19.014l16.465-9.507c7.134-4.16 16.348-1.699 20.493 5.493 4.146 7.178 1.685 16.348-5.493 20.493L136.002 391l16.463 9.507c7.178 4.146 9.639 13.315 5.493 20.493-4.149 7.183-13.341 9.624-20.493 5.493L121 416.986V436c0 8.291-6.709 15-15 15s-15-6.709-15-15v-19.014l-16.465 9.507c-7.139 4.124-16.337 1.703-20.493-5.493-4.146-7.178-1.685-16.348 5.493-20.493L75.998 391l-16.463-9.507zm201.27-355.946c-5.244 7.354-4.38 7.339-9.595.015C239.828 9.551 221.62 0 202.504 0c-28.286 0-52.837 20.127-58.374 47.856l-19.376 97.89c3.402.201 6.606.386 10.28.61C169.311 148.437 211.337 151 256 151c44.546 0 86.426-2.549 120.073-4.585 4.016-.245 7.495-.447 11.173-.665L367.87 47.856C362.333 20.127 337.782 0 309.496 0c-19.116 0-37.324 9.551-48.691 25.547z" }, void 0) }), void 0));
}
// 500
function ServerErrorIcon(props) {
    return (jsxs("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: 512, height: 512, viewBox: "0 0 512 512" }, props, { children: [jsx("path", { d: "M506.415 456.55L393.802 273.576c-6.42-10.878-18.363-17.639-31.224-17.639-12.86 0-24.805 6.761-31.054 17.383l-112.42 182.675c-15.463 22.885 1.194 55.88 30.691 55.88h225.566c29.838 0 45.834-33.57 31.054-55.325zm-143.837 23.333c-11.773 0-21.328-9.555-21.328-21.328s9.555-21.328 21.328-21.328 21.328 9.555 21.328 21.328-9.555 21.328-21.328 21.328zm21.328-85.313c0 11.773-9.533 21.328-21.328 21.328-11.794 0-21.328-9.555-21.328-21.328v-63.984c0-11.773 9.534-21.328 21.328-21.328 11.795 0 21.328 9.555 21.328 21.328v63.984zM405.234 0H63.984C28.644 0 0 28.644 0 63.984c0 35.341 28.644 63.985 63.984 63.985h341.25c35.341 0 63.985-28.644 63.985-63.985C469.219 28.644 440.575 0 405.234 0zM63.984 85.312c-11.773 0-21.328-9.555-21.328-21.328s9.555-21.328 21.328-21.328 21.328 9.555 21.328 21.328-9.555 21.328-21.328 21.328zm85.313 0c-11.773 0-21.328-9.555-21.328-21.328s9.555-21.328 21.328-21.328 21.328 9.555 21.328 21.328-9.555 21.328-21.328 21.328z" }, void 0), jsx("path", { d: "M405.234 170.625H63.984C28.58 170.625 0 199.205 0 234.609c0 35.405 28.58 63.985 63.984 63.985h201.978l29.22-47.562c13.436-23.034 39.456-37.75 67.396-37.75 27.94 0 53.96 14.716 68.037 38.603l18.129 29.433c12.583-11.517 20.475-28.153 20.475-46.709 0-35.404-28.58-63.984-63.985-63.984zm-341.25 85.312c-11.73 0-21.328-9.597-21.328-21.328 0-11.73 9.598-21.328 21.328-21.328 11.73 0 21.328 9.598 21.328 21.328 0 11.73-9.597 21.328-21.328 21.328zm85.313 0c-11.73 0-21.328-9.597-21.328-21.328 0-11.73 9.597-21.328 21.328-21.328 11.73 0 21.328 9.598 21.328 21.328 0 11.73-9.598 21.328-21.328 21.328zM63.984 341.25C28.58 341.25 0 369.83 0 405.234c0 35.405 28.58 63.985 63.984 63.985h107.068c.853-13.437 5.332-26.02 12.796-37.111l55.88-90.858H63.984zm0 85.312c-11.73 0-21.328-9.597-21.328-21.328 0-11.73 9.598-21.328 21.328-21.328 11.73 0 21.328 9.598 21.328 21.328 0 11.73-9.597 21.328-21.328 21.328zm85.313 0c-11.73 0-21.328-9.597-21.328-21.328 0-11.73 9.597-21.328 21.328-21.328 11.73 0 21.328 9.598 21.328 21.328 0 11.73-9.598 21.328-21.328 21.328z" }, void 0)] }), void 0));
}
// 404
function Error404Icon(props) {
    return (jsxs("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: 512, height: 512, viewBox: "0 0 512 512" }, props, { children: [jsx("path", { d: "M142 111V31H15C6.716 31 0 37.716 0 46v65h142zm355-80H172v80h340V46c0-8.284-6.716-15-15-15zM406.598 292.182c.114-19.66.192-38.614.188-52.311-7.762 13.197-18.66 32.36-29.808 52.311h29.62zm-278.71-52.311c-7.761 13.197-18.66 32.36-29.808 52.311h29.621c.114-19.663.192-38.613.187-52.311z" }, void 0), jsx("path", { d: "M0 141v325c0 8.284 6.716 15 15 15h482c8.284 0 15-6.716 15-15V141H0zm202.103 106.4c0-29.719 24.178-53.897 53.897-53.897 29.719 0 53.897 24.179 53.897 53.897v62.205c0 29.719-24.179 53.897-53.897 53.897s-53.897-24.179-53.897-53.897V247.4zM59.677 314.808a15.002 15.002 0 01-.217-14.872c11.073-20.07 47.816-86.311 55.736-96.027 7.12-8.735 16.785-12.273 25.85-9.467 9.148 2.834 15.644 11.673 16.548 22.519.417 5.006.311 41.438.112 75.222h2.803c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15h-3.003c-.088 11.918-.169 21.542-.211 26.449-.071 8.24-6.773 14.871-14.997 14.871h-.132c-8.284-.072-14.941-6.846-14.87-15.129.069-8.014.14-16.917.208-26.191h-54.91a15.003 15.003 0 01-12.917-7.375zM376 428.502H136c-8.284 0-15-6.716-15-15 0-8.284 6.716-15 15-15h240c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15zm63.406-106.32h-3.003c-.089 11.918-.169 21.542-.212 26.449-.07 8.24-6.773 14.871-14.996 14.871h-.132c-8.284-.072-14.942-6.846-14.87-15.129.068-8.014.14-16.917.207-26.191h-54.909a15 15 0 01-13.134-22.246c11.072-20.07 47.815-86.311 55.735-96.027 7.12-8.733 16.779-12.274 25.852-9.466 9.148 2.833 15.644 11.673 16.547 22.519.417 5.006.311 41.438.112 75.221h2.803c8.284 0 15 6.716 15 15 0 8.284-6.716 14.999-15 14.999z" }, void 0), jsx("path", { d: "M256 333.502c13.177 0 23.897-10.721 23.897-23.897V247.4c0-13.177-10.721-23.897-23.897-23.897-13.176 0-23.897 10.721-23.897 23.897v62.205c0 13.176 10.72 23.897 23.897 23.897z" }, void 0)] }), void 0));
}
// client
function ClientErrorIcon(props) {
    return (jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", width: 512, height: 512, viewBox: "0 0 512 512" }, props, { children: jsx("path", { d: "M497 121c-8.291 0-15 6.708-15 15v41.454c0 5.728-3.179 10.87-8.291 13.418l-34.069 17.034c3.104 9.63 5.75 19.5 7.696 29.696l39.791-19.894c15.337-7.676 24.873-23.1 24.873-40.254V136c0-8.29-6.709-15-15-15zm-9.873 203.29l-36.017-18.008c-.831 10.682-2.401 21.1-4.486 31.302l27.085 13.542c5.112 2.55 8.291 7.69 8.291 13.418V406c0 8.291 6.709 15 15 15s15-6.709 15-15v-41.455c0-17.153-9.536-32.578-24.873-40.254zm-60 90l-7.782-3.89c-5.112 8.852-10.864 17.14-16.983 25.053l11.347 5.673c5.112 2.55 8.291 7.69 8.291 13.418V497c0 8.291 6.709 15 15 15s15-6.709 15-15v-42.455c0-17.153-9.536-32.578-24.873-40.254zM92.655 410.4l-7.782 3.89C69.536 421.966 60 437.391 60 454.544V497c0 8.291 6.709 15 15 15s15-6.709 15-15v-42.455c0-5.728 3.179-10.869 8.291-13.418l11.347-5.673c-6.119-7.914-11.871-16.2-16.983-25.054zM60.89 306.281L24.873 324.29C9.536 331.966 0 347.391 0 364.544V406c0 8.291 6.709 15 15 15s15-6.709 15-15v-41.455c0-5.728 3.179-10.869 8.291-13.418l27.085-13.542c-2.086-10.203-3.655-20.62-4.486-31.302zm-22.599-115.41c-5.112-2.549-8.291-7.69-8.291-13.418V136c0-8.29-6.709-15-15-15s-15 6.71-15 15v41.455c0 17.153 9.536 32.578 24.873 40.254l39.791 19.894c1.946-10.197 4.592-20.067 7.696-29.696l-34.069-17.034zM326.605 4.394c-5.859-5.859-15.352-5.859-21.211 0l-28.817 29.817c-16.566-4.735-28.193-3.556-41.109.046L206.605 4.394c-5.859-5.859-15.352-5.859-21.211 0-5.859 5.86-5.859 15.352 0 21.211l22.339 23.34c-8.685 7.314-15.813 16.378-20.453 26.756C208.691 66.353 231.788 61 256 61c24.077 0 47.049 5.3 68.359 14.548-4.563-10.128-11.294-19.263-20.032-26.664l22.278-23.278c5.86-5.86 5.86-15.352 0-21.21zM256 91c-52.643 0-100.492 29.396-130.725 74.907C139.99 188.508 188.894 211 256 211c67.595 0 116.031-22.31 130.738-45.075C356.505 120.402 308.65 91 256 91zM109.603 193.961C97.119 221.396 90 252.727 90 286c0 101.536 67.031 185.103 151 194.101V240.343c-56.97-2.648-105.971-20.004-131.397-46.382zM196 391c-8.284 0-15-6.716-15-15 0-8.286 6.716-15 15-15 8.284 0 15 6.714 15 15 0 8.284-6.716 15-15 15zm0-90c-8.284 0-15-6.716-15-15 0-8.286 6.716-15 15-15 8.284 0 15 6.714 15 15 0 8.284-6.716 15-15 15zm206.338-107.18C376.835 220.02 327.539 237.61 271 240.315V480.1c83.969-8.998 151-92.565 151-194.1 0-33.328-7.137-64.714-19.662-92.182zM316 390.998c-8.284 0-15-6.716-15-15 0-8.286 6.716-15 15-15 8.284 0 15 6.714 15 15 0 8.284-6.716 15-15 15zm0-90c-8.284 0-15-6.716-15-15 0-8.286 6.716-15 15-15 8.284 0 15 6.714 15 15 0 8.284-6.716 15-15 15z" }, void 0) }), void 0));
}
const CONTROLCLASS = 'wpeform-component-exception';
const HEADERCLASS = getBemElement(CONTROLCLASS, 'header');
const HEADERINNERCLASS = getBemElement(CONTROLCLASS, 'header-inner');
const LABELCLASS = getBemElement(CONTROLCLASS, 'label');
const ICONCLASS = getBemElement(CONTROLCLASS, 'icon');
const CONTENTCLASS = getBemElement(CONTROLCLASS, 'content');
const TITLECLASS = getBemElement(CONTROLCLASS, 'title');
const BODYCLASS = getBemElement(CONTROLCLASS, 'body');
const BUTTONSCLASS = getBemElement(CONTROLCLASS, 'buttons');
const Header = styled.header `
	background-color: ${props => props.theme.errorColor};
	color: ${props => props.theme.primaryBgText};
	flex: 0 0 100%;
	padding: ${props => numToCssSize(props.theme.gutter / 2)}
		${props => numToCssSize(props.theme.gutter)};
	border-top-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-top-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	display: flex;
	align-items: center;
`;
const HeaderInner = styled.div `
	display: flex;
	flex-flow: row nowrap;
	align-items: center;
	justify-content: flex-start;
	width: 100%;
	flex: 0 0 100%;
`;
const IconContainer = styled.div `
	font-size: 18px;
	flex: 0 0 ${props => numToCssSize(18 + props.theme.gutter * 1.5)};
	height: ${props => numToCssSize(18 + props.theme.gutter * 1.5)};
	width: ${props => numToCssSize(18 + props.theme.gutter * 1.5)};
	border-radius: ${props => numToCssSize(18 + props.theme.gutter * 1.5)};
	border: 4px solid ${props => props.theme.appBackgroundColor};
	background-color: ${props => props.theme.errorBackgroundColor};
	color: ${props => props.theme.errorColor};
	margin: 0 ${props => numToCssSize(props.theme.gutter)} 0 0;
	padding: ${props => numToCssSize(props.theme.gutter)};
	display: flex;
	justify-content: center;
	align-items: center;
`;
const Label = styled.p `
	margin: 0;
	padding: 0;
	font-size: ${props => numToCssSize(props.theme.fz.large1)};
	color: ${props => props.theme.primaryBgText};
	text-transform: uppercase;
	font-weight: bold;
`;
const Content = styled.article `
	flex: 0 0 100%;
`;
const Title = styled.h3 `
	margin: ${props => numToCssSize(props.theme.gutter)} 0;
	color: ${props => props.theme.headingColor};
	padding: 0 ${props => numToCssSize(props.theme.gutter)};
	font-size: ${props => numToCssSize(props.theme.fz.large2)};
`;
const Body = styled.div `
	padding: 0 ${props => numToCssSize(props.theme.gutter)};
	${proseCss};
`;
const Footer = styled.footer `
	background-color: ${props => props.theme.disabledBackgroundColor};
	margin: ${props => numToCssSize(props.theme.gutter)} 0 0 0;
	padding: ${props => numToCssSize(props.theme.gutter / 4)}
		${props => numToCssSize(props.theme.gutter / 2)};
	border-bottom-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-bottom-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	display: flex;
	align-items: center;
	justify-content: flex-start;
	flex-flow: row wrap;
	> * {
		flex: 0 0 auto;
		margin: ${props => numToCssSize(props.theme.gutter / 4)}
			${props => numToCssSize(props.theme.gutter / 2)};
	}
`;
const ExceptionContianer = styled.section `
	width: 600px;
	max-width: calc(100% - ${props => numToCssSize(props.theme.gutter * 2)});
	margin: ${props => numToCssSize(props.theme.gutter)} auto;
	background-color: ${props => props.theme.appBackgroundColor};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	box-shadow: ${props => props.theme.boxShadowBase};
	display: flex;
	flex-flow: row wrap;
	align-items: stretch;
	justify-content: center;

	&.${CONTROLCLASS}--size-tablet {
		${Header} {
			flex: 0 0 200px;
			margin: 0;
			border-radius: 0;
			border-top-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
			border-bottom-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};

			${HeaderInner} {
				flex-flow: row wrap;
				align-items: center;
				justify-content: center;
			}

			${IconContainer} {
				margin: 0 0 ${props => numToCssSize(props.theme.gutter)} 0;
				font-size: 36px;
				flex: 0 0 ${props => numToCssSize(36 + props.theme.gutter * 2)};
				height: ${props => numToCssSize(36 + props.theme.gutter * 2)};
				width: ${props => numToCssSize(36 + props.theme.gutter * 2)};
				border-radius: ${props => numToCssSize(36 + props.theme.gutter * 2)};
				border: 6px solid ${props => props.theme.appBackgroundColor};
			}
			${Label} {
				text-align: center;
				flex: 0 0 100%;
			}
		}
		${Content} {
			flex: 0 0 calc(100% - 200px);

			${Body} {
				min-height: 100px;
			}

			${Footer} {
				border-radius: 0;
				border-top-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
				border-bottom-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
			}
		}
	}
`;
const defaultConfig = {
    403: {
        icon: AuthErrorIcon,
        iconTitle: __('AUTH ERROR', 'wp-eform'),
        title: 'You are not permitted - Error 403',
        desc: "Sorry, you don't have access to this page!",
    },
    404: {
        icon: Error404Icon,
        iconTitle: __('ERROR 404', 'wp-eform'),
        title: 'Page not found - Error 404',
        desc: 'Sorry, the page you visited does not exist!',
    },
    500: {
        icon: ServerErrorIcon,
        iconTitle: __('SERVER ERROR', 'wp-eform'),
        title: 'Internal Server Error - Error 500',
        desc: 'Sorry, the server is reporting an error!',
    },
    client: {
        icon: ClientErrorIcon,
        iconTitle: __('APP ERROR', 'wp-eform'),
        title: 'Application Error',
        desc: 'Sorry, something bad happened in the application. Please retry.',
    },
};
function Exception(props) {
    const { type, title, description, icon, footer } = props;
    const size = useContainerSize();
    const className = useResponsiveClassNames(size, CONTROLCLASS);
    return (jsxs(ExceptionContianer, Object.assign({ className: classNames(className, `${CONTROLCLASS}--type-${type}`) }, { children: [jsx(Header, Object.assign({ className: HEADERCLASS }, { children: jsxs(HeaderInner, Object.assign({ className: HEADERINNERCLASS }, { children: [jsx(IconContainer, Object.assign({ className: ICONCLASS }, { children: jsx(Icon, { children: createElement(icon || defaultConfig[type].icon) }, void 0) }), void 0), jsx(Label, Object.assign({ className: LABELCLASS }, { children: defaultConfig[type].iconTitle }), void 0)] }), void 0) }), void 0), jsxs(Content, Object.assign({ className: CONTENTCLASS, "data-testid": "exception-msg" }, { children: [jsx(Title, Object.assign({ role: "alert", className: TITLECLASS, "data-testid": "exception-title" }, { children: title ?? defaultConfig[type].title }), void 0), jsx(Body, Object.assign({ className: BODYCLASS, "data-testid": "exception-note" }, { children: description || defaultConfig[type].desc }), void 0), footer ? jsx(Footer, Object.assign({ className: BUTTONSCLASS }, { children: footer }), void 0) : null] }), void 0)] }), void 0));
}

export { useRipple as $, ThemedContainer as A, ButtonIconPositionEnum as B, ConsequenceActionEnum as C, DarkThemeModeEnum as D, EventComparisonEnum as E, FormElementCategoryEnum as F, GenericAlignmentEnum as G, HeadingSizeEnum as H, AppErrorBoundary as I, Exception as J, Button$1 as K, curriedLighten as L, MaskTypeEnum as M, NumberComparisonEnum as N, OptionColumnEnum as O, PaginationTypeEnum as P, getBemClassName as Q, RedirectTypeEnum as R, ScoreFromToTypeEnum as S, TrashEnum as T, buttonResetCss as U, ValidationFilterTypeEnum as V, WidthPresetsEnum as W, numToCssSize as X, curriedTransparentize as Y, getMultipleTransitionsWithWillChange as Z, __ as _, ButtonOpenTypeEnum as a, componentSize as a$, getIntValueGreaterThan as a0, scrollBarVerticalCss as a1, Select as a2, Icon as a3, Text$2 as a4, _x as a5, Dropdown as a6, getMultipleTransition as a7, longWordBreakCss as a8, userInputWhiteSpace as a9, Grid as aA, Heading as aB, OptionGroup as aC, Question as aD, ResponsiveContainer as aE, SlateView as aF, SubmissionSkeleton as aG, Slider as aH, Textarea as aI, useIsMounted as aJ, usePrevious as aK, useTimerCountDown as aL, removeItemFromArrayByMutation as aM, insertItemInArrayByMutation as aN, reOrderArrayByMutation as aO, replaceItemInArrayByMutation as aP, deleteItemInArrayByMutation as aQ, shuffleArray as aR, useResponsiveClassNames as aS, _default as aT, scrollParents as aU, proseCss as aV, getHoursMinutesSeconds as aW, _n as aX, useClampedSpringConfig as aY, formatNumber as aZ, scrollBarHorizontalCss as a_, classNames as aa, sprintf as ab, Skeleton as ac, IconMessage as ad, useIsResponsiveBreakpoint as ae, useContainerSize as af, getRandomInt as ag, getOrderlyIndexedItemInArray as ah, getBemElement as ai, cssReset as aj, useResponsiveOuterContainerRef as ak, getDefaultDateTimeFormatString as al, getMinDate as am, getMaxDate as an, getCurrentOrigin as ao, roundNumber as ap, useQuestionId as aq, getNextEvenNumber as ar, Radio as as, Checkbox as at, Alert as au, AnimatedConditional as av, AnimateIn as aw, AnswerPreview as ax, ButtonsGroup as ay, ControlAddon as az, EventHasEnum as b, isNullOrEmptyString as b$, dayjs as b0, curriedDarken as b1, textEllipsisCss as b2, CONTROLCLASS$m as b3, inputCssReset as b4, screenReaderTextCss as b5, checkObjectPropertiesSomeHaveValue as b6, checkObjectPropertiesAllHaveValue as b7, useDebouncedCallback as b8, CONTROLCLASS$8 as b9, useSubmissionFormMeta as bA, submissionStoreStructuresSelector as bB, submissionStoreStartTimeSelector as bC, useSubmissionFormRenderMode as bD, useFormElementConditionalMap as bE, getActiveStructuresAfterReset as bF, getActiveElementsAfterReset as bG, submissionForceShowErrorsContext as bH, activeErrorElementContext as bI, formNavActionsContext as bJ, getSlateMentionsOnElementsAndScore as bK, DynamicAnchorProvider as bL, useThemeStyleFromFormStyle as bM, SubmissionStore as bN, defaultInitialSubmissionData as bO, submissionFormDataContext as bP, submissionFormMetaContext as bQ, submissionFormRenderModeContext as bR, formElementConditionalMapContext as bS, convertFormData as bT, useFormSubmissionSubmit as bU, getCurrentUrl as bV, logger as bW, produce as bX, validationMessages as bY, validateValueInStep as bZ, getFloatValue as b_, CONTROLCLASS$9 as ba, CONTROLCLASS$k as bb, deDupArray as bc, removeItemInArray as bd, useSubmissionFormData as be, useSubmissionStore as bf, submissionStoreCurrentPageSelector as bg, submissionStoreLastTouchedElementIdSelector as bh, useFormNavActions as bi, useSubmissionStoreApi as bj, getAllConditionallyShownChildrenOfCurrentPage as bk, areElementsErrorFree as bl, GridElements as bm, useSlateJsonMentions as bn, useSlateJsonDynamicAnchors as bo, useNodesFromJson as bp, getDefaultSlateNodeWithChildren as bq, SlateViewWithData as br, getNodesFromJSON as bs, MentionsProvider as bt, submissionStoreElementsSelector as bu, useScheduledInvoke as bv, areLogicEventsCheckedOut as bw, fsIsPlanOrHigher as bx, submissionStoreRemarksSelector as by, useSubmissionDispatch as bz, EventOperationEnum as c, getUrlParameterValue as c0, decodeJSONRecord as c1, Node as c2, getStringValueFromJSON as c3, wpEFormElementFrontCollection as c4, MemoizedElement as c5, verifyJsonDataStructureForStorage as c6, getLengthComparisonStatus as c7, getConditionStatusBasedOnOperation as c8, SlateViewWithoutMentions as c9, SvgGenericCheckboxChecked as ca, SvgGenericCheckboxUnchecked as cb, areArraysEqual as cc, Collections as cd, parsePossibleDateTimeFormula as ce, parsePossibleMySQLDateTimeString as cf, mysqlFormat as cg, compareDates as ch, getDayjsFromMySQLInput as ci, makeTheme as cj, wpEFormThemes as ck, OverrideDarkModeProvider as cl, EventRelationEnum as d, FormPaginationRestrictionEnum as e, FormPaymentTypeEnum as f, FormPaymentsCouponTypeEnum as g, FormSettingsBackgroundAttachmentEnum as h, FormSettingsBackgroundOriginAndClipEnum as i, FormSettingsBackgroundRepeatEnum as j, FormSettingsLimitOnLoginEnum as k, GenericSizeEnum as l, HeadingTagEnum as m, PrefilEnum as n, ResourceViewModeEnum as o, ScoreOperationEnum as p, SelectTypeEnum as q, SettingsAppearanceContainerLayoutEnum as r, SettingsAppearanceControlAlignmentEnum as s, SettingsAppearanceControlLayoutEnum as t, SettingsAppearanceControlTypeEnum as u, SettingsAppearanceProgressBarPositionEnum as v, SubmissionStatIntervalEnum as w, SubmitTimerEnum as x, Shadow as y, FormSkeleton as z };
