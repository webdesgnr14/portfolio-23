import { L as List$1, a as arrayMove, C as CONTROLCLASS$b, D as DateTimePicker, T as Table } from '../index-chunk-wpeform-react-081736f4.js';
export { A as ActionFeedback, f as Address, b as AnimatedSvg, c as ControlGroup, D as DateTimePicker, I as InlineCountDown, M as MathOutput, g as MatrixChoice, h as MatrixInput, P as Progressbar, R as Rating, i as Sortable, S as Spinner, T as Table, d as Tabs, e as Timer, j as Toggle } from '../index-chunk-wpeform-react-081736f4.js';
import { L as curriedLighten, Q as getBemClassName, U as buttonResetCss, X as numToCssSize, Y as curriedTransparentize, Z as getMultipleTransitionsWithWillChange, $ as useRipple, a0 as getIntValueGreaterThan, a1 as scrollBarVerticalCss, _ as __, u as SettingsAppearanceControlTypeEnum, a2 as Select, q as SelectTypeEnum, l as GenericSizeEnum, K as Button, a3 as Icon, a4 as Text, a5 as _x, a6 as Dropdown, a7 as getMultipleTransition, a8 as longWordBreakCss, a9 as userInputWhiteSpace, aa as classNames, ab as sprintf, ac as Skeleton, ad as IconMessage, ae as useIsResponsiveBreakpoint, af as useContainerSize, ag as getRandomInt, ah as getOrderlyIndexedItemInArray, ai as getBemElement, aj as cssReset, ak as useResponsiveOuterContainerRef, s as SettingsAppearanceControlAlignmentEnum, al as getDefaultDateTimeFormatString, am as getMinDate, an as getMaxDate, ao as getCurrentOrigin, ap as roundNumber, aq as useQuestionId, ar as getNextEvenNumber, as as Radio, at as Checkbox } from '../index-chunk-wpeform-react-daf2eca0.js';
export { au as Alert, aw as AnimateIn, av as AnimatedConditional, ax as AnswerPreview, I as AppErrorBoundary, K as Button, B as ButtonIconPositionEnum, a as ButtonOpenTypeEnum, ay as ButtonsGroup, at as Checkbox, C as ConsequenceActionEnum, az as ControlAddon, D as DarkThemeModeEnum, a6 as Dropdown, E as EventComparisonEnum, b as EventHasEnum, c as EventOperationEnum, d as EventRelationEnum, J as Exception, F as FormElementCategoryEnum, e as FormPaginationRestrictionEnum, f as FormPaymentTypeEnum, g as FormPaymentsCouponTypeEnum, h as FormSettingsBackgroundAttachmentEnum, i as FormSettingsBackgroundOriginAndClipEnum, j as FormSettingsBackgroundRepeatEnum, k as FormSettingsLimitOnLoginEnum, z as FormSkeleton, G as GenericAlignmentEnum, l as GenericSizeEnum, aA as Grid, aB as Heading, H as HeadingSizeEnum, m as HeadingTagEnum, a3 as Icon, ad as IconMessage, M as MaskTypeEnum, N as NumberComparisonEnum, O as OptionColumnEnum, aC as OptionGroup, P as PaginationTypeEnum, n as PrefilEnum, aD as Question, as as Radio, R as RedirectTypeEnum, o as ResourceViewModeEnum, aE as ResponsiveContainer, S as ScoreFromToTypeEnum, p as ScoreOperationEnum, a2 as Select, q as SelectTypeEnum, r as SettingsAppearanceContainerLayoutEnum, s as SettingsAppearanceControlAlignmentEnum, t as SettingsAppearanceControlLayoutEnum, u as SettingsAppearanceControlTypeEnum, v as SettingsAppearanceProgressBarPositionEnum, ac as Skeleton, aF as SlateView, aH as Slider, aG as SubmissionSkeleton, w as SubmissionStatIntervalEnum, x as SubmitTimerEnum, a4 as Text, aI as Textarea, A as ThemedContainer, T as TrashEnum, V as ValidationFilterTypeEnum, W as WidthPresetsEnum, aQ as deleteItemInArrayByMutation, aN as insertItemInArrayByMutation, aO as reOrderArrayByMutation, aM as removeItemFromArrayByMutation, aP as replaceItemInArrayByMutation, aR as shuffleArray, aJ as useIsMounted, aK as usePrevious, aq as useQuestionId, $ as useRipple, aL as useTimerCountDown } from '../index-chunk-wpeform-react-daf2eca0.js';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import styled, { useTheme, css, keyframes } from 'styled-components';
import { animated, useSpring, useTransition } from '@react-spring/web';
import * as React from 'react';
import { useMemo, createContext, useState, useEffect, useRef, useLayoutEffect } from 'react';
import 'query-string';
import '@use-gesture/react';
import 'react-dom';
import 'react-dom/server';
import 'react-is';
import 'react-intersection-observer';
import 'zustand';
import '@fortawesome/fontawesome-svg-core';
import '@fortawesome/react-fontawesome';

const CONTROLCLASS$a = 'wpeform-component-animatedcircle';
const CircleContainer = styled.div `
	display: inline-flex;
	align-items: center;
	justify-content: center;
	svg {
		stroke: currentColor;
		fill: none;
		display: block;
		height: 1em;
		width: 1em;
		flex: 0 0 1em;
	}
	color: ${props => curriedLighten(0.1, props.theme.textColorSecondary)};

	&.${CONTROLCLASS$a}--type-error {
		color: ${props => curriedLighten(0.1, props.theme.errorColor)};
	}
	&.${CONTROLCLASS$a}--type-success {
		color: ${props => curriedLighten(0.1, props.theme.successColor)};
	}
	&.${CONTROLCLASS$a}--type-warning {
		color: ${props => curriedLighten(0.1, props.theme.warningColor)};
	}
`;
const SvgAnimatedCircle = styled(animated.circle) `
	stroke-width: 4;
	stroke-dasharray: 65 66;
	will-change: stroke-dashoffset;
`;
function AnimatedCircle(props) {
    const theme = useTheme();
    const { type, delay } = props;
    const springStyle = useSpring({
        from: { strokeDashoffset: 66 },
        to: { strokeDashoffset: 0 },
        config: theme.springConfigSlow,
        delay,
    });
    return (jsx(CircleContainer, Object.assign({ className: getBemClassName(CONTROLCLASS$a, { [`type-${type}`]: true }) }, { children: jsx("svg", Object.assign({ width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, { children: jsx(SvgAnimatedCircle, { cx: 12, cy: 12, r: 8, strokeDashoffset: springStyle.strokeDashoffset }, void 0) }), void 0) }), void 0));
}

const CONTROLCLASS$9 = 'wpeform-component-controlbutton';
const ButtonText = styled.span `
	transform-origin: center center;
`;
const StyledButton = styled.button `
	${buttonResetCss};
	display: flex;
	flex: 0 0 auto;
	height: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
	min-width: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
	padding: 0 ${props => numToCssSize(props.theme.controlHeightBase * 0.15)};
	align-items: center;
	justify-content: center;
	font-size: ${props => numToCssSize(props.theme.fz.small2)};
	background-color: ${props => curriedTransparentize(1, props.theme.backgroundShade)};
	border: 1px solid ${props => curriedTransparentize(1, props.theme.backgroundShade)};
	color: ${props => props.theme.textColorSecondary};
	box-shadow: ${props => props.theme.boxShadowNoneFocus};
	position: relative;
	overflow: hidden;
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'box-shadow', 'border-color', 'color'], props.theme.transitionControl)};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};

	&:hover,
	&:active {
		color: ${props => props.theme.textColor};
		border-color: ${props => curriedTransparentize(0, props.theme.backgroundShade)};
		background-color: ${props => curriedTransparentize(0, props.theme.backgroundShade)};
	}

	&:focus-visible {
		border-color: ${props => props.theme.primaryColor};
		box-shadow: ${props => props.theme.boxShadowControlFocus};
	}

	&:active {
		${ButtonText} {
			transform: scale(0.85);
		}
	}

	&.${CONTROLCLASS$9}--type-new {
		border-color: ${props => curriedTransparentize(1, props.theme.successBackgroundColor)};
		background-color: ${props => curriedTransparentize(1, props.theme.successBackgroundColor)};
		&:hover,
		&:active {
			border-color: ${props => curriedTransparentize(0, props.theme.successBackgroundColor)};
			background-color: ${props => curriedTransparentize(0, props.theme.successBackgroundColor)};
		}

		&:focus-visible {
			border-color: ${props => props.theme.successColor};
			box-shadow: ${props => props.theme.boxShadowControlFocusSuccess};
		}
	}
	&.${CONTROLCLASS$9}--type-delete {
		border-color: ${props => curriedTransparentize(1, props.theme.errorBackgroundColor)};
		background-color: ${props => curriedTransparentize(1, props.theme.errorBackgroundColor)};
		&:hover,
		&:active {
			border-color: ${props => curriedTransparentize(0, props.theme.errorBackgroundColor)};
			background-color: ${props => curriedTransparentize(0, props.theme.errorBackgroundColor)};
		}

		&:focus-visible {
			border-color: ${props => props.theme.errorColor};
			box-shadow: ${props => props.theme.boxShadowControlFocusError};
		}
	}
`;
function ControlButton(props) {
    const { children, className, onClick, type, ...buttonProps } = props;
    const [addRipple, ripples] = useRipple();
    return (jsxs(StyledButton, Object.assign({ type: "button", className: getBemClassName(CONTROLCLASS$9, { [`type-${type}`]: true }, className), onClick: e => {
            addRipple(e);
            e.preventDefault();
            if (onClick) {
                onClick();
            }
        } }, buttonProps, { children: [ripples, jsx(ButtonText, { children: children }, void 0)] }), void 0));
}
const Group = styled.div `
	display: flex;
	flex-flow: row wrap;

	${StyledButton} {
		flex: 0 0 auto;
	}
`;
ControlButton.Group = Group;

const CONTROLCLASS$8 = 'wpeform-component-countup';
const Container$9 = styled(animated.span) `
	font-variant-numeric: tabular-nums;
`;
function CountUp(props) {
    const { value, precision } = props;
    const theme = useTheme();
    const animatedValue = useSpring({
        from: { value: 0 },
        to: { value },
        config: useMemo(() => ({ ...theme.springConfigSlow, clamp: true }), [theme]),
    });
    return (jsx(Container$9, Object.assign({ className: CONTROLCLASS$8 }, { children: animatedValue.value.to(val => val.toFixed(precision)) }), void 0));
}
function SplitCountUp(props) {
    const { value, precision = 0 } = props;
    const stringValue = Math.abs(value).toFixed(precision);
    const [beforeDecimal, afterDecimal] = stringValue.split('.');
    return (jsxs(Fragment, { children: [value < 0 ? jsx(Container$9, Object.assign({ className: CONTROLCLASS$8 }, { children: "-" }), void 0) : null, beforeDecimal.split('').map((val, index) => (jsx(CountUp, { value: getIntValueGreaterThan(val, 0, -1), precision: 0 }, index))), afterDecimal && afterDecimal.length ? (jsxs(Fragment, { children: [jsx(Container$9, Object.assign({ className: CONTROLCLASS$8 }, { children: "." }), void 0), afterDecimal.split('').map((val, index) => (jsx(CountUp, { value: getIntValueGreaterThan(val, 0, -1), precision: 0 }, index)))] }, void 0)) : null] }, void 0));
}
CountUp.Split = SplitCountUp;

const CONTROLCLASS$7 = 'wpeform-component-datatable';
const DataTableColumns = styled.div `
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	display: flex;
	flex-flow: row nowrap;
`;
const widgetBox = css `
	background-color: ${props => props.theme.appBackgroundColor};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	box-shadow: ${props => props.theme.boxShadowElevationOne};
`;
const DataHeader = styled.header `
	${widgetBox};
	display: flex;
	flex-flow: row wrap;
	width: 100%;
	align-items: center;
	justify-content: space-between;
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
`;
const DataHeaderRowOne = styled.div ``;
const DateHeaderRowTwo = styled.div `
	max-width: 100%;
	overflow-x: auto;
`;
const DataContainer = styled.div `
	flex: 0 0 ${props => (props.isPreviewShowable ? '350px' : '100%')};
	max-width: ${props => (props.isPreviewShowable ? '350px' : '100%')};
	${DataHeaderRowOne},
	${DateHeaderRowTwo} {
		flex: 1 0 auto;
		padding: ${props => numToCssSize(props.theme.gutter * 0.4)};
		max-width: ${props => (props.isPreviewShowable ? '350px' : '100%')};
	}
`;
const DataPreviewContainer = styled.div `
	width: calc(100% - 350px);
	flex: 0 0 calc(100% - 350px);
	align-self: stretch;
	padding: 0 0 0 ${props => numToCssSize(props.theme.gutter / 2)};
	display: flex;
	flex-flow: row nowrap;
`;
const DataPreviewContent = styled.div `
	width: 100%;
	overflow-y: auto;
	${scrollBarVerticalCss};
	padding: 0;
	padding-bottom: 120px;
`;
const PreviewStickContainer = styled.div `
	height: calc(
		100vh -
			${props => numToCssSize(props.theme.gutter + props.stickyOffset ?? 0)}
	);
	min-height: 200px;
	width: 100%;
	position: sticky;
	top: ${props => numToCssSize(props.theme.gutter / 2 + props.stickyOffset)};
	${widgetBox};
	${DataPreviewContent} {
		height: calc(
			100vh -
				${props => numToCssSize(props.theme.gutter + props.stickyOffset ?? 0)}
		);
		min-height: 200px;
	}
`;
const DataPreviewEmptyContent = styled.div `
	padding: 50px 0;
	max-width: 250px;
	margin: 0 auto;
`;
const DataTableContainer = styled.div `
	background-color: ${props => props.theme.backgroundShade};
	padding: ${props => numToCssSize(props.theme.gutter / 2)};
	&.${CONTROLCLASS$7}--border-top {
		border-top-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
		border-top-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	}
	&.${CONTROLCLASS$7}--border-bottom {
		border-bottom-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
		border-bottom-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	}
	&.${CONTROLCLASS$7}--border-both {
		border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	}
`;
const DataTableFooter = styled.footer `
	${widgetBox};
	padding: ${props => numToCssSize(props.theme.gutter)};
	margin: ${props => numToCssSize(props.theme.gutter / 2)} 0 0 0;
`;

const dataTableDispatchContext = createContext(() => { });

const Separator$1 = styled.span `
	font-size: ${props => numToCssSize(props.theme.fz.large1)};
	font-weight: bold;
	color: ${props => props.theme.textColorSecondary};
	width: 1em;
	text-align: center;
`;
const PageNum = styled.span `
	color: ${props => props.theme.textColor};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	line-height: 1;
`;
const NumInput = styled.span `
	width: 2.5em;
	flex: 0 0 2.5em;
	input[type='number'] {
		appearance: none;
		&::-webkit-inner-spin-button,
		&::-webkit-outer-spin-button {
			margin: 0;
			-webkit-appearance: none;
		}
		text-align: right;
	}
`;
const PerPage = styled.div `
	width: 120px;
	flex: 0 0 120px;
`;
const Paginator = styled.div `
	flex: 0 0 auto;
	display: flex;
	flex-flow: row nowrap;
	align-items: center;
	justify-content: flex-start;
	> * {
		margin: 0 ${props => numToCssSize(props.theme.gutter * 0.4)} 0 0;
		&:last-child {
			margin-right: 0;
		}
	}
`;
const Container$8 = styled.div `
	display: flex;
	flex-flow: row nowrap;
	font-variant-numeric: tabular-nums;
	align-items: center;
	justify-content: space-between;
	max-width: 100%;
	@media screen and (max-width: 350px) {
		overflow-x: auto;
	}
`;
const perPageSelectItems = [
    {
        label: __('10 items', 'wp-eform'),
        value: 10,
        plain: __('10 items', 'wp-eform'),
    },
    {
        label: __('20 items', 'wp-eform'),
        value: 20,
        plain: __('20 items', 'wp-eform'),
    },
    {
        label: __('30 items', 'wp-eform'),
        value: 30,
        plain: __('30 items', 'wp-eform'),
    },
    {
        label: __('40 items', 'wp-eform'),
        value: 40,
        plain: __('40 items', 'wp-eform'),
    },
];
function Pagination(props) {
    const { total, pageSize, onChange, current, perPage, onPerPageChange, controlType = SettingsAppearanceControlTypeEnum.BOXY, } = props;
    let numberOfPages = total > 0 ? Math.ceil(total / pageSize) : 0;
    let canPaginate = true;
    if (numberOfPages === 0) {
        canPaginate = false;
        numberOfPages = 1;
    }
    const canPrevious = current !== 1;
    const canNext = current !== numberOfPages;
    return (jsxs(Container$8, { children: [jsx(PerPage, { children: jsx(Select, { value: [perPage], mode: SelectTypeEnum.SINGLE, onChange: newVal => {
                        if (!newVal.length) {
                            onPerPageChange(20);
                        }
                        else {
                            onPerPageChange(newVal[0]);
                        }
                    }, size: GenericSizeEnum.SMALL, items: perPageSelectItems, showSearch: false, placeholder: __('per page', 'wp-eform'), emptyResultPlaceholder: __('no results found.', 'wp-eform'), searchPlaceholder: "", canClear: false, controlType: controlType }, void 0) }, void 0), jsxs(Paginator, { children: [jsx(Button, Object.assign({ style: "transparent", colorful: false, size: "TINY", disabled: !canPrevious || !canPaginate, onClick: e => {
                            e.preventDefault();
                            onChange(current - 1);
                        }, "aria-label": __('Go previous', 'wp-eform') }, { children: jsx(Icon, { iconClass: "fas fa-chevron-left" }, void 0) }), void 0), jsx(NumInput, { children: jsx(Text, { type: "number", size: GenericSizeEnum.SMALL, min: 1, max: numberOfPages, step: 1, disabled: !canPaginate, onChange: nextValue => {
                                let newPage = getIntValueGreaterThan(nextValue, 1, 0);
                                if (newPage > numberOfPages) {
                                    newPage = numberOfPages;
                                }
                                onChange(newPage);
                            }, value: current.toString(), controlType: controlType }, void 0) }, void 0), jsx(Separator$1, { children: _x('/', 'pagination-separator', 'wp-eform') }, void 0), jsx(PageNum, { children: numberOfPages }, void 0), jsx(Button, Object.assign({ disabled: !canNext || !canPaginate, style: "transparent", colorful: false, size: "TINY", onClick: e => {
                            e.preventDefault();
                            onChange(current + 1);
                        }, "aria-label": __('Go next', 'wp-eform') }, { children: jsx(Icon, { iconClass: "fas fa-chevron-right" }, void 0) }), void 0)] }, void 0)] }, void 0));
}

const SearchContainer = styled.div `
	width: calc(100% - 120px);
	flex: 1 1 calc(100% - 120px);
	padding: 0 ${props => numToCssSize(props.theme.gutter / 2)} 0 0;
`;
const OrderContainer = styled.div `
	width: 120px;
	flex: 0 0 120px;
`;
const Container$7 = styled.div `
	display: flex;
	align-items: center;
	justify-content: space-between;
`;
const orderDirItems = [
    {
        label: __('Ascending', 'wp-eform'),
        value: 'ascend',
    },
    {
        label: __('Descending', 'wp-eform'),
        value: 'descend',
    },
];
function SearchSort(props) {
    const { dispatch, orderBys, state, searchPlaceholder = __('search items', 'wp-eform'), controlType = SettingsAppearanceControlTypeEnum.BOXY, } = props;
    return (jsxs(Container$7, { children: [jsx(SearchContainer, { children: jsx(Text, { type: "search", onChange: nextValue => {
                        dispatch({ type: 'SET_SEARCH', payload: { search: nextValue } });
                    }, value: state.search, size: GenericSizeEnum.SMALL, controlType: controlType, placeholder: searchPlaceholder, prefix: jsx(Icon, { iconClass: "fas fa-search" }, void 0) }, void 0) }, void 0), jsx(OrderContainer, { children: jsx(Dropdown, { prefix: jsx(Icon, { iconClass: "fas fa-sort" }, void 0), buttonLabel: __('Sort by', 'wp-eform'), size: GenericSizeEnum.SMALL, controlType: controlType, minMenuWidth: 300, menu: () => (jsxs(Dropdown.SplitMenu, { children: [jsx(Dropdown.SplitMenuColumn, { children: orderBys.map(ob => (jsx(Dropdown.MenuItem, Object.assign({ onClick: () => {
                                        dispatch({
                                            type: 'SET_ORDERBY',
                                            payload: { orderBy: ob.value },
                                        });
                                    }, active: ob.value === state.orderBy }, { children: ob.label }), ob.value))) }, void 0), jsx(Dropdown.SplitMenuColumn, { children: orderDirItems.map(od => (jsx(Dropdown.MenuItem, Object.assign({ onClick: () => {
                                        dispatch({
                                            type: 'SET_ORDERDIR',
                                            payload: { orderDir: od.value },
                                        });
                                    }, active: od.value === state.orderDir }, { children: od.label }), od.value))) }, void 0)] }, void 0)) }, void 0) }, void 0)] }, void 0));
}

const DataList = styled.ul `
	list-style: none;
	margin: 0;
	padding: 0;
`;
const DataListItemInner = styled.div `
	margin: 0;
	padding: ${props => numToCssSize(props.theme.gutter)};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	display: flex;
	flex-flow: row nowrap;
	align-items: stretch;
	justify-content: flex-start;
	position: relative;

	/** FOCUS and SELECT */
	&::after {
		border: 12px solid ${props => curriedTransparentize(1, props.theme.primaryColor)};
		content: '';
		position: absolute;
		bottom: -1px;
		right: -1px;
		display: block;
		transition: ${props => getMultipleTransitionsWithWillChange(['border-color'], props.theme.transition)};
	}
`;
const DataListItem = styled(animated.li) `
	list-style: none;
	overflow: hidden;
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
	background-color: ${props => props.theme.appBackgroundColor};
	padding: 0;
	will-change: opacity, transform, max-height, box-shadow, border-color;
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	box-shadow: ${props => props.theme.boxShadowElevationOne};
	border: 1px solid ${props => curriedTransparentize(1, props.theme.primaryColor)};
	&:last-of-type {
		margin-bottom: 0;
	}
	transition: ${props => getMultipleTransition(['box-shadow', 'border-color'], props.theme.transition)};

	/** FOCUS and SELECT */
	&:hover {
		box-shadow: ${props => props.theme.boxShadow1dp};
	}

	&.is-selected {
		box-shadow: ${props => props.theme.boxShadow2dp};
	}

	&:focus,
	&.focused {
		outline: none;
		border-color: ${props => curriedTransparentize(0, props.theme.primaryColor)};

		${DataListItemInner} {
			position: relative;
			outline: none;
			z-index: 1;

			&::after {
				border-right-color: ${props => curriedTransparentize(0, props.theme.primaryColor)};
				border-bottom-color: ${props => curriedTransparentize(0, props.theme.primaryColor)};
			}
		}
	}

	&.is-header {
		box-shadow: ${props => props.theme.boxShadowElevationOne};
		&:hover {
			box-shadow: ${props => props.theme.boxShadowElevationOne};
		}
		${DataListItemInner} {
			padding-top: ${props => numToCssSize(props.theme.gutter / 2)};
			padding-bottom: ${props => numToCssSize(props.theme.gutter / 2)};
		}
	}
	&.is-loading {
		svg {
			display: block;
		}
	}
`;
const DataListItemContent = styled.div `
	flex: 0 0 auto;
	width: 100%;
`;
const DataListItemPreviewHeader = styled.div `
	display: flex;
	flex-flow: row nowrap;
	width: 100%;
	align-items: flex-start;
	justify-content: flex-start;
	max-width: 100%;
`;
const DataListItemPreviewTitle = styled.h3 `
	${longWordBreakCss};
	margin: 0;
	padding: 0 ${props => numToCssSize(props.theme.gutter)} 0 0;
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	font-weight: 700;
	color: ${props => props.theme.headingColor};
	flex: 0 1 auto;
`;
const DataListItemPreviewMeta = styled.div `
	margin: 0 0 0 auto;
	padding: 0;
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	font-weight: 400;
	color: ${props => props.theme.textColorSecondary};
	flex: 0 0 auto;
	line-height: ${props => numToCssSize(props.theme.fz.base * 1.5715)};
`;
const DataListItemPreviewData = styled.div `
	margin: ${props => numToCssSize(props.theme.gutter)} 0 0 0;
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	color: ${props => props.theme.textColor};
	&:only-child {
		margin-top: 0;
	}
	p {
		font-size: ${props => numToCssSize(props.theme.fz.base)};
		line-height: 1.5;
	}
	a {
		text-align: left;
		background: transparent;
		border: 0 none;
		outline: none;
		padding: 0;
		cursor: pointer;
		display: inline;
		color: ${props => props.theme.primaryDarkColor};
		font-weight: 600;
		font-style: normal;
		text-decoration: none;
		&:hover {
			text-decoration: underline;
		}
	}
	em {
		font-style: italic;
		color: ${props => props.theme.textColorSecondary};
	}
	strong {
		font-weight: 600;
		color: ${props => props.theme.headingColor};
		border-bottom: 2px dashed ${props => props.theme.borderColorBase};
	}
	code {
		color: ${props => props.theme.errorColor};
		font-family: ${props => props.theme.fontFamilyMono};
	}
	p {
		margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
		&:last-child {
			margin-bottom: 0;
		}
	}
	.user-input {
		${longWordBreakCss};
	}
`;
const DataListItemPreviewActions = styled.div `
	margin: ${props => numToCssSize(props.theme.gutter)} 0 0;
`;
const DataListItemPreview = styled.div `
	width: 100%;
	&.is-header {
		${DataListItemPreviewTitle} {
			text-transform: uppercase;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			color: ${props => props.theme.textColorSecondary};
			font-size: ${props => numToCssSize(props.theme.fz.small1)};
		}
	}
`;
const DataListItemPreviewDataUserInput = styled.div `
	${userInputWhiteSpace};
`;
const DataListItemPreviewDataHeading = styled.h5 `
	color: ${props => props.theme.textColorSecondary};
	font-weight: bold;
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	text-transform: uppercase;
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
`;
const DataListItemPreviewEmptyPlaceholder = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter)};
	max-width: 300px;
	margin: 0 auto;
`;

function useAnimatedListsData(items, getItemId, state, displayMode = 'preview') {
    // Transition items
    const theme = useTheme();
    const transitionItems = useTransition(items, {
        keys: getItemId,
        from: {
            opacity: 0,
            transform: displayMode === 'preview'
                ? 'translate(0px, -30px)'
                : 'translate(-20px, 0x)',
            maxHeight: '400px',
        },
        enter: {
            opacity: 1,
            transform: 'translate(0px, 0px)',
            maxHeight: '400px',
        },
        leave: {
            opacity: 0,
            transform: 'translate(20px, 0px)',
            maxHeight: '0px',
        },
        config: {
            ...theme.springConfigGeneral,
            clamp: true,
        },
        trail: state.canTrailItems ? 125 : undefined,
    });
    return transitionItems;
}

function AnimatedLists(props) {
    const { items, state, dispatch, generateItemRow, getItemId } = props;
    const transitionItems = useAnimatedListsData(items, getItemId, state);
    return (jsx(Fragment, { children: transitionItems((styleProp, item) => {
            const itemKey = getItemId(item);
            const selected = state.selectedRows.includes(itemKey);
            return (jsx(DataListItem, Object.assign({ style: {
                    opacity: styleProp.opacity,
                    transform: styleProp.transform,
                    maxHeight: styleProp.maxHeight?.to(val => {
                        if (val === '400px') {
                            return 'none';
                        }
                        return val;
                    }),
                }, tabIndex: 0, role: "button", className: classNames({
                    focused: state.previewItemId === itemKey,
                    'is-selected': selected,
                }), onClick: e => {
                    dispatch({
                        type: 'SET_PREVIEW_ITEM_ID',
                        payload: {
                            previewItemId: itemKey,
                        },
                    });
                }, onKeyDown: e => {
                    if (e.code === 'Enter' || e.code === 'Space') {
                        dispatch({
                            type: 'SET_PREVIEW_ITEM_ID',
                            payload: {
                                previewItemId: itemKey,
                            },
                        });
                    }
                } }, { children: jsx(DataListItemInner, { children: jsx(DataListItemContent, { children: generateItemRow(item) }, void 0) }, void 0) }), void 0));
        }) }, void 0));
}

function ItemsInPage(props) {
    const { items, itemNamePlural, itemNameSingular, state, totalItems, loadingData, } = props;
    const itemsInViewStart = 1 + (state.currentPage - 1) * state.itemsPerPage;
    const itemsInViewEnd = (items?.length ?? (loadingData ? state.itemsPerPage : 0)) +
        (state.currentPage - 1) * state.itemsPerPage;
    const itemType = items?.length === 1 ? itemNameSingular : itemNamePlural;
    const text = sprintf(_x('Showing %1$d-%2$d / %3$d %4$s', 'datatable-items-in-page', 'wp-eform'), items?.length || loadingData ? itemsInViewStart : 0, itemsInViewEnd, totalItems, itemType);
    return (jsx(DataListItem, Object.assign({ className: "is-header" }, { children: jsx(DataListItemInner, { children: jsx(DataListItemContent, { children: jsx(DataListItemPreview, Object.assign({ className: "is-header" }, { children: jsx(DataListItemPreviewHeader, { children: jsx(DataListItemPreviewTitle, { children: text }, void 0) }, void 0) }), void 0) }, void 0) }, void 0) }), void 0));
}

const ButtonSkeleton = styled.div `
	display: inline-block;
	margin: 0 ${props => numToCssSize(props.theme.gutter / 2)};
`;
function SkeletonLoader() {
    const theme = useTheme();
    return (jsx(DataListItem, Object.assign({ className: "is-loading" }, { children: jsx(DataListItemInner, { children: jsx(DataListItemContent, { children: jsxs(DataListItemPreview, { children: [jsxs(DataListItemPreviewHeader, { children: [jsx(DataListItemPreviewTitle, Object.assign({ style: { width: '65%' } }, { children: jsx(Skeleton, { shape: "rectangle", width: "100%", height: theme.fz.base * 1.5 }, void 0) }), void 0), jsx(DataListItemPreviewMeta, Object.assign({ style: { width: '25%', maxWidth: '80px' } }, { children: jsx(Skeleton, { shape: "rectangle", width: "100%", height: theme.fz.base * 1.5 }, void 0) }), void 0)] }, void 0), jsxs(DataListItemPreviewData, { children: [jsx(Skeleton.Paragraph, { width: "90%" }, void 0), jsx(Skeleton.Paragraph, { width: "40%" }, void 0)] }, void 0), jsxs(DataListItemPreviewActions, { children: [jsx(ButtonSkeleton, { children: jsx(Skeleton, { shape: "rectangle", width: "110px", height: theme.controlHeightBase * 0.8 }, void 0) }, void 0), jsx(ButtonSkeleton, { children: jsx(Skeleton, { shape: "rectangle", width: "80px", height: theme.controlHeightBase * 0.8 }, void 0) }, void 0)] }, void 0)] }, void 0) }, void 0) }, void 0) }), void 0));
}
function PreviewSkeleton(props) {
    const { itemsPerPage } = props;
    return (jsx(Fragment, { children: Array.from({ length: itemsPerPage }).map((_, i) => (
        // eslint-disable-next-line react/no-array-index-key
        jsx(SkeletonLoader, {}, i))) }, void 0));
}

function ListItems(props) {
    const { items, getItemId, state, dispatch, generateItemRow, loadingData, emptyText, ...itemsInPageProps } = props;
    // This will cause the unmount on pagination immediate
    const animatedKey = `${state.currentPage}${state.currentView}${JSON.stringify(state.filters)}${state.orderBy}${state.orderDir}${state.search}`;
    return (jsxs(DataList, { children: [jsx(ItemsInPage, Object.assign({ items: items, state: state, loadingData: loadingData }, itemsInPageProps), void 0), loadingData && !items ? (jsx(PreviewSkeleton, { itemsPerPage: state.itemsPerPage }, void 0)) : items && items.length ? (jsx(AnimatedLists, { items: items, getItemId: getItemId, dispatch: dispatch, generateItemRow: generateItemRow, state: state }, animatedKey)) : (jsx(DataListItem, { children: jsx(DataListItemInner, { children: jsx(DataListItemContent, { children: jsx(DataListItemPreview, { children: jsx(DataListItemPreviewData, { children: jsx(DataListItemPreviewEmptyPlaceholder, { children: jsx(IconMessage, Object.assign({ icon: jsx(Icon, { iconClass: "fas fa-clipboard" }, void 0) }, { children: emptyText }), void 0) }, void 0) }, void 0) }, void 0) }, void 0) }, void 0) }, void 0))] }, void 0));
}

function DataTable(props) {
    const { state, dispatch, generatePreview, emptyPreview, totalItems, orderBys, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    initialFilters, stickyOffset = 0, roundedBorder = 'bottom', className, searchPlaceholder, controlType = SettingsAppearanceControlTypeEnum.BOXY, ...listItemProps } = props;
    const [localTotalItem, setLocalTotalItem] = useState(totalItems ?? 1);
    useEffect(() => {
        if (totalItems !== undefined) {
            setLocalTotalItem(totalItems);
        }
    }, [totalItems]);
    const mainRef = useRef(null);
    const isPreviewShowable = useIsResponsiveBreakpoint(useContainerSize(), 899);
    const containerClass = getBemClassName(CONTROLCLASS$7, {
        [`border-${roundedBorder}`]: true,
    }, className);
    return (jsx(dataTableDispatchContext.Provider, Object.assign({ value: dispatch }, { children: jsxs(DataTableContainer, Object.assign({ className: containerClass, ref: mainRef }, { children: [jsxs(DataTableColumns, { children: [jsxs(DataContainer, Object.assign({ isPreviewShowable: isPreviewShowable }, { children: [jsxs(DataHeader, { children: [jsx(DataHeaderRowOne, { children: jsx(SearchSort, { state: state, dispatch: dispatch, orderBys: orderBys, searchPlaceholder: searchPlaceholder, controlType: controlType }, void 0) }, void 0), jsx(DateHeaderRowTwo, { children: jsx(Pagination, { controlType: controlType, perPage: state.itemsPerPage, onPerPageChange: newPerPage => {
                                                    dispatch({
                                                        type: 'SET_ITEMS_PER_PAGE',
                                                        payload: {
                                                            itemsPerPage: newPerPage,
                                                        },
                                                    });
                                                }, current: state.currentPage, onChange: newPage => {
                                                    dispatch({
                                                        type: 'SET_CURRENT_PAGE',
                                                        payload: { currentPage: newPage },
                                                    });
                                                }, pageSize: state.itemsPerPage, total: localTotalItem }, void 0) }, void 0)] }, void 0), jsx(ListItems, Object.assign({ state: state, dispatch: dispatch, totalItems: localTotalItem }, listItemProps), void 0)] }), void 0), isPreviewShowable ? (jsx(DataPreviewContainer, { children: jsx(PreviewStickContainer, Object.assign({ stickyOffset: stickyOffset }, { children: jsx(DataPreviewContent, { children: state.previewItemId ? (generatePreview(state.previewItemId)) : (jsx(DataPreviewEmptyContent, { children: jsx(IconMessage, Object.assign({ icon: jsx(Icon, { iconClass: "fas fa-comment-alt" }, void 0) }, { children: emptyPreview }), void 0) }, void 0)) }, void 0) }), void 0) }, void 0)) : null] }, void 0), jsx(DataTableFooter, { children: jsx(Pagination, { controlType: controlType, perPage: state.itemsPerPage, onPerPageChange: newPerPage => {
                            dispatch({
                                type: 'SET_ITEMS_PER_PAGE',
                                payload: {
                                    itemsPerPage: newPerPage,
                                },
                            });
                            if (mainRef.current) {
                                mainRef.current.scrollIntoView({ behavior: 'smooth' });
                            }
                        }, current: state.currentPage, onChange: newPage => {
                            dispatch({
                                type: 'SET_CURRENT_PAGE',
                                payload: { currentPage: newPage },
                            });
                            if (mainRef.current) {
                                mainRef.current.scrollIntoView({ behavior: 'smooth' });
                            }
                        }, pageSize: state.itemsPerPage, total: localTotalItem }, void 0) }, void 0)] }), void 0) }), void 0));
}
DataTable.PreviewHeader = DataListItemPreviewHeader;
DataTable.PreviewTitle = DataListItemPreviewTitle;
DataTable.PreviewMeta = DataListItemPreviewMeta;
DataTable.PreviewData = DataListItemPreviewData;
DataTable.PreviewActions = DataListItemPreviewActions;
DataTable.Preview = DataListItemPreview;
DataTable.PreviewDataUserInput = DataListItemPreviewDataUserInput;
DataTable.PreviewDataHeading = DataListItemPreviewDataHeading;

const CONTROLCLASS$6 = 'wpeform-component-graphskeleton';
const Container$6 = styled.div `
	display: flex;
	flex-flow: row nowrap;
	max-width: 100%;
	overflow: hidden;
	min-height: 50px;
	align-items: flex-end;
	justify-content: space-between;
`;
const barAnimation = keyframes `
	0% {
			height: 14%;
	}
	50% {
			height: 100%;
	}
	100% {
		height:14%;
	}
`;
const Bar = styled.div `
	margin: 0 1px;
	background-color: ${props => props.theme.backgroundShade};
	flex: 0 0 auto;
	animation: ${barAnimation} 2300ms infinite;
`;
function GraphSkeleton(props) {
    const { barWidth = 6, bars = 4, color, height = 70, type = 'bar', className, } = props;
    const barStyle = {
        width: numToCssSize(barWidth),
    };
    if (color) {
        barStyle.backgroundColor = color;
    }
    const delays = useMemo(() => {
        return Array.from({ length: 10 }).map(() => getRandomInt(100, 1000));
    }, []);
    const durations = useMemo(() => {
        return Array.from({ length: 10 }).map(() => getRandomInt(200, 300));
    }, []);
    return (jsx(Container$6, Object.assign({ className: getBemClassName(CONTROLCLASS$6, { [`type-${type}`]: true }, className), style: { height: numToCssSize(height) } }, { children: Array.from({ length: bars }).map((_, index) => {
            const duration = 2300 + getOrderlyIndexedItemInArray(index, durations);
            const delay = index * -1 * getOrderlyIndexedItemInArray(index, delays);
            return (jsx(Bar
            // eslint-disable-next-line react/no-array-index-key
            , { style: {
                    ...barStyle,
                    animationDuration: `${duration}ms`,
                    WebkitAnimationDuration: `${duration}ms`,
                    MozAnimationDuration: `${duration}ms`,
                    animationDelay: `${delay}ms`,
                    WebkitAnimationDelay: `${delay}ms`,
                    MozAnimationDelay: `${delay}ms`,
                } }, index));
        }) }), void 0));
}

/**
 * Highlight matched portion from a fuzzy search. You can provide which
 * component to be used for highlighting, which give you most fine-grained
 * control of the highlight.
 *
 * Use with a library like [fuzzysearch](https://github.com/bevacqua/fuzzysearch).
 */
function HighlightFuzzySearch(props) {
    const { query: originalQuery, text, tag: Tag = 'strong' } = props;
    const query = originalQuery.toLowerCase();
    if (query.length === 0) {
        return jsx(Fragment, { children: text }, void 0);
    }
    const output = [];
    let missionAccomplished = true;
    const querySplits = query.split('');
    let searchText = text.toLowerCase();
    let remainingText = text;
    let lastOffset = searchText.indexOf(querySplits[0]);
    if (lastOffset === -1) {
        return jsx(Fragment, { children: text }, void 0);
    }
    output.push(remainingText.slice(0, lastOffset));
    output.push(jsx(Tag, { children: remainingText[lastOffset] }, void 0));
    remainingText = remainingText.slice(lastOffset + 1);
    searchText = searchText.slice(lastOffset + 1);
    for (let i = 1; i < querySplits.length; i++) {
        const q = querySplits[i];
        // get the first matching from the remaining text
        lastOffset = searchText.indexOf(q);
        if (lastOffset === -1) {
            missionAccomplished = false;
            break;
        }
        output.push(remainingText.slice(0, lastOffset));
        output.push(jsx(Tag, { children: remainingText[lastOffset] }, void 0));
        remainingText = remainingText.slice(lastOffset + 1);
        searchText = searchText.slice(lastOffset + 1);
    }
    output.push(remainingText);
    if (missionAccomplished) {
        return React.createElement(React.Fragment, {}, ...output);
    }
    return jsx(Fragment, { children: text }, void 0);
}

const getKf = (color) => keyframes `
	0% {
    transform: scale(0.94, 0.94);
    box-shadow: 0 0 0 0 ${curriedTransparentize(0.3, color)};
  }

  70% {
    transform: scale(1);
    box-shadow: 0 0 0 0.5em ${curriedTransparentize(1, color)};
  }

  100% {
    transform: scale(0.94, 0.94);
    box-shadow: 0 0 0 0 ${curriedTransparentize(1, color)};
  }
`;
const CONTROLCLASS$5 = 'wpeform-component-pulse';
const Blob = styled.span `
	display: inline-block;
	height: 0.8em;
	width: 0.8em;
	margin: 0 0.25em;
	border-radius: 0.8em;
	transform: scale(0.94, 0.94);
	transform-origin: center center;

	background-color: ${props => curriedLighten(0.1, props.theme.borderColorBase)};

	&.${CONTROLCLASS$5}--active {
		animation: ${props => getKf(curriedLighten(0.1, props.theme.borderColorBase))} 2s
			infinite;
	}

	&.${CONTROLCLASS$5}--type-success {
		background-color: ${props => curriedLighten(0.1, props.theme.successColor)};
		&.${CONTROLCLASS$5}--active {
			animation: ${props => getKf(curriedLighten(0.1, props.theme.successColor))} 2s
				infinite;
		}
	}
	&.${CONTROLCLASS$5}--type-error {
		background-color: ${props => curriedLighten(0.1, props.theme.errorColor)};
		&.${CONTROLCLASS$5}--active {
			animation: ${props => getKf(curriedLighten(0.1, props.theme.errorColor))} 2s
				infinite;
		}
	}
	&.${CONTROLCLASS$5}--type-warning {
		background-color: ${props => curriedLighten(0.1, props.theme.warningColor)};
		&.${CONTROLCLASS$5}--active {
			animation: ${props => getKf(curriedLighten(0.1, props.theme.warningColor))} 2s
				infinite;
		}
	}
	&.${CONTROLCLASS$5}--type-primary {
		background-color: ${props => curriedLighten(0.1, props.theme.primaryColor)};
		&.${CONTROLCLASS$5}--active {
			animation: ${props => getKf(curriedLighten(0.1, props.theme.primaryColor))} 2s
				infinite;
		}
	}
`;
function Pulse(props) {
    const { label, type, className, active = true } = props;
    return (jsx(Blob, { "aria-hidden": label ? 'false' : 'true', className: getBemClassName(CONTROLCLASS$5, { [`type-${type}`]: true, active }, className), title: label }, void 0));
}

const CONTROLCLASS$4 = 'wpeform-component-repeatable';
const LISTCLASS = getBemElement(CONTROLCLASS$4, 'list');
const LISTITEMCLASS = getBemElement(CONTROLCLASS$4, 'list-item');
const ITEMCONTAINERLCASS = getBemElement(CONTROLCLASS$4, 'item-container');
const ITEMCONTENTCLASS = getBemElement(CONTROLCLASS$4, 'item-content');
const ITEMHEADERCLASS = getBemElement(CONTROLCLASS$4, 'item-header');
const ITEMHEADERLABELCLASS = getBemElement(CONTROLCLASS$4, 'item-header-label');
const ITEMHEADERCONTROLSCLASS = getBemElement(CONTROLCLASS$4, 'item-header-controls');
const SORTBUTTONCLASS = getBemElement(CONTROLCLASS$4, 'sort-btn');
const FOOTERCLASS$1 = getBemElement(CONTROLCLASS$4, 'footer');
const List = styled.ul `
	list-style: none;
	margin: 0;
	padding: ${props => numToCssSize(props.theme.gutter / 2)};
	background-color: ${props => props.theme.appBackgroundColor};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color'], props.theme.transitionControl)};
	&.${LISTCLASS}--isDragged {
		background-color: ${props => props.theme.backgroundShade};
	}
`;
const ItemContent = styled.div `
	color: ${props => props.theme.textColor};
	margin: 0;
	padding: 0;
`;
const ItemHeaderLabel = styled.h4 `
	font-size: ${props => numToCssSize(props.theme.fz.small2)};
	color: ${props => props.theme.textColorSecondary};
	font-weight: bold;
	line-height: 1.2;
	margin: 0;
	padding: 0 ${props => numToCssSize(props.theme.gutter / 2)};
	flex: 0 1 auto;
`;
const ItemHeaderControls = styled.div `
	flex: 0 0 auto;
	margin: 0 0 0 auto;
	display: flex;
	flex-flow: row nowrap;
	align-items: center;
	justify-content: flex-end;

	.${CONTROLCLASS$9} {
		border-radius: 0;
		&:last-child {
			border-top-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
		}
	}
`;
const ItemHeader = styled.header `
	display: flex;
	flex-flow: row nowrap;
	align-items: center;
	justify-content: space-between;
	min-height: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
	background-color: ${props => props.theme.backgroundControl};
	border-bottom: 1px solid ${props => props.theme.borderColorLight};
	border-top-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-top-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'border-color'], props.theme.transitionControl)};
`;
const ItemContainer = styled(animated.div) `
	color: ${props => props.theme.textColor};
	padding: 0;
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	line-height: 1.2;
	border: 1px solid ${props => props.theme.borderColorLight};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	margin: 0;
	font-family: ${props => props.theme.fontFamilyBody};
	background-color: ${props => props.theme.appBackgroundColor};
	box-shadow: ${props => props.theme.boxShadowBottom},
		${props => props.theme.boxShadowNoneFocus};
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'border-color', 'box-shadow'], props.theme.transitionControl)};
`;
const Item = styled.li `
	list-style: none;
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
	padding: 0;
	z-index: 9999999;

	&:hover,
	&:focus {
		${ItemContainer} {
			border-color: ${props => props.theme.borderColorSplit};
		}
	}

	.${SORTBUTTONCLASS} {
		cursor: grab;
	}

	&:focus-visible {
		outline: none;
		${ItemContainer} {
			box-shadow: ${props => props.theme.boxShadowBottom},
				${props => props.theme.boxShadowControlFocus};
			border-color: ${props => props.theme.primaryColor};
		}
	}

	&.${LISTITEMCLASS}--isSelected {
		outline: none;
		${ItemHeader} {
			background-color: ${props => props.theme.backgroundSelected};
			border-color: ${props => props.theme.primaryColor};
		}
		${ItemContainer} {
			box-shadow: ${props => props.theme.boxShadowBottom},
				${props => props.theme.boxShadowControlFocus};
			border-color: ${props => props.theme.primaryColor};
		}
	}

	&.${LISTITEMCLASS}--isDragged {
		.${SORTBUTTONCLASS} {
			cursor: grabbing;
		}
		${ItemHeader} {
			background-color: ${props => props.theme.backgroundHover};
			border-color: ${props => props.theme.borderColorBase};
		}
		${ItemContainer} {
			border-color: ${props => props.theme.borderColorBase};
		}
	}

	&.${LISTITEMCLASS}--isOutOfBounds {
		cursor: not-allowed;
		${ItemHeader} {
			background-color: ${props => props.theme.errorBackgroundColor};
			border-color: ${props => props.theme.errorColor};
		}
		${ItemContainer} {
			border-color: ${props => props.theme.errorColor};
		}
	}
`;
const Footer$1 = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter / 2)}
		${props => numToCssSize(props.theme.gutter / 2)} 0
		${props => numToCssSize(props.theme.gutter / 2)};
`;
const Container$5 = styled.div `
	${cssReset};
`;

function AnimateIn(props) {
    const { children, onRest, doAnimation } = props;
    const theme = useTheme();
    const springStyle = useSpring({
        from: {
            opacity: 0,
            backgroundColor: theme.successBackgroundColor,
            transform: 'translate3d(-50px, 0px, 0px)',
        },
        to: {
            opacity: 1,
            backgroundColor: theme.appBackgroundColor,
            transform: 'translate3d(0px, 0px, 0px)',
        },
        config: theme.springConfigSlow,
        onRest,
    });
    const ref = useRef(null);
    useLayoutEffect(() => {
        if (!doAnimation) {
            return;
        }
        if (ref.current) {
            const parentElement = ref.current.parentElement;
            if (!parentElement) {
                return;
            }
            const contentElement = parentElement.querySelector(`.${ITEMCONTENTCLASS}`);
            if (!contentElement) {
                parentElement.focus();
                return;
            }
            const interactiveElements = [
                'input',
                'textarea',
                'select',
                'option',
                'optgroup',
                'video',
                'audio',
                'button',
                'a',
            ];
            const firstItem = contentElement.querySelector(interactiveElements.join(', '));
            if (firstItem) {
                firstItem.focus();
            }
            else {
                parentElement.focus();
            }
        }
    }, [doAnimation]);
    return (jsx(ItemContainer, Object.assign({ className: ITEMCONTAINERLCASS, style: doAnimation ? springStyle : undefined, ref: ref }, { children: children }), void 0));
}

function AnimateOut(props) {
    const { children, onRest } = props;
    const theme = useTheme();
    const springStyle = useSpring({
        from: {
            opacity: 1,
            transform: 'translate3d(0px, 0px, 0px)',
            backgroundColor: theme.appBackgroundColor,
        },
        to: {
            opacity: 0,
            transform: 'translate3d(50px, 0px, 0px)',
            backgroundColor: theme.errorBackgroundColor,
        },
        config: { ...theme.springConfigGeneral, clamp: true },
        onRest,
    });
    return (jsx(ItemContainer, Object.assign({ className: ITEMCONTAINERLCASS, style: springStyle }, { children: children }), void 0));
}

function Repeatable(props) {
    const { className, items, renderItem, headingLabel, onDelete, onNew, onSort, addButtonLabel = __('ADD NEW', 'wp-eform'), addButtonAfterLabel = __('Add new item after this', 'wp-eform'), sortButtonLabel = __('Click and drag to rearrange item', 'wp-eform'), deleteButtonLabel = __('Delete this item', 'wp-eform'), deleteConfirmationMessage = __('Are you sure you want to delete this item?', 'wp-eform'), } = props;
    const [lastAddedItemId, setLastAddedItemId] = useState(null);
    const [lastDeletedItemId, setLastDeletedItemId] = useState(null);
    const container = useResponsiveOuterContainerRef();
    return (jsxs(Container$5, Object.assign({ className: getBemClassName(CONTROLCLASS$4, undefined, className) }, { children: [jsx(List$1, { values: items, disabled: onSort === undefined, onChange: ({ oldIndex, newIndex }) => {
                    if (onSort) {
                        onSort(arrayMove(items, oldIndex, newIndex));
                    }
                }, renderList: ({ children, isDragged, props: listProps }) => (jsx(List, Object.assign({ className: getBemClassName(LISTCLASS, { isDragged }) }, listProps, { children: children }), void 0)), getKey: item => item.id, renderItem: ({ isDragged, isOutOfBounds, isSelected, props: itemProps, value, index, }) => {
                    const children = (jsxs(Fragment, { children: [jsxs(ItemHeader, Object.assign({ className: ITEMHEADERCLASS }, { children: [headingLabel ? (jsx(ItemHeaderLabel, Object.assign({ className: ITEMHEADERLABELCLASS }, { children: headingLabel(index ?? 0, value) }), void 0)) : null, onNew || onDelete || onSort ? (jsxs(ItemHeaderControls, Object.assign({ className: ITEMHEADERCONTROLSCLASS }, { children: [onSort ? (jsx(ControlButton, Object.assign({ type: "regular", title: sortButtonLabel, onClick: () => {
                                                    // do nothing
                                                }, className: SORTBUTTONCLASS, "data-movable-handle": true }, { children: jsx(Icon, { iconClass: "fas fa-grip-lines" }, void 0) }), void 0)) : null, onNew ? (jsx(ControlButton, Object.assign({ type: "new", title: addButtonAfterLabel, onClick: () => {
                                                    setLastAddedItemId(onNew((index ?? 0) + 1));
                                                } }, { children: jsx(Icon, { iconClass: "fas fa-plus" }, void 0) }), void 0)) : null, onDelete ? (jsx(ControlButton, Object.assign({ type: "delete", title: deleteButtonLabel, onClick: () => {
                                                    // eslint-disable-next-line no-alert
                                                    const conscent = window.confirm(deleteConfirmationMessage);
                                                    if (conscent) {
                                                        setLastDeletedItemId(value.id);
                                                    }
                                                } }, { children: jsx(Icon, { iconClass: "fas fa-trash" }, void 0) }), void 0)) : null] }), void 0)) : null] }), void 0), jsx(ItemContent, Object.assign({ className: ITEMCONTENTCLASS }, { children: renderItem(value) }), void 0)] }, void 0));
                    const isLastAdded = lastAddedItemId === value.id;
                    return (jsx(Item, Object.assign({ className: getBemClassName(LISTITEMCLASS, {
                            isDragged,
                            isOutOfBounds,
                            isSelected,
                        }) }, itemProps, { children: lastDeletedItemId !== value.id ? (jsx(AnimateIn, Object.assign({ doAnimation: isLastAdded, onRest: isLastAdded
                                ? () => {
                                    setLastAddedItemId(null);
                                }
                                : undefined }, { children: children }), void 0)) : (jsx(AnimateOut, Object.assign({ onRest: () => {
                                if (onDelete) {
                                    onDelete(value);
                                }
                            } }, { children: children }), void 0)) }), void 0));
                }, container: container }, void 0), onNew ? (jsx(Footer$1, Object.assign({ className: FOOTERCLASS$1 }, { children: jsx(Button, Object.assign({ style: "3d", colorful: true, size: GenericSizeEnum.SMALL, onClick: () => {
                        setLastAddedItemId(onNew(items.length));
                    }, icon: "fas fa-plus" }, { children: addButtonLabel }), void 0) }), void 0)) : null] }), void 0));
}

const CONTROLCLASS$3 = 'wpeform-component-widget';
const TitleContainer = styled.header `
	margin: 0;
	padding: ${props => numToCssSize(props.theme.gutter * 0.75)}
		${props => numToCssSize(props.theme.gutter)};
	border-bottom: 1px solid ${props => props.theme.borderColorLight};
	display: flex;
	flex-flow: row nowrap;
	align-items: center;
	justify-content: space-between;
`;
const Title = styled.h3 `
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	font-weight: bold;
	color: ${props => props.theme.headingColor};
	text-transform: uppercase;
	margin: 0;
	padding: 0;
	flex: 1 1 auto;
`;
const TitleControl = styled.aside `
	flex: 0 1 auto;
	max-width: 500px;

	.ant-btn.reload:not(.ant-btn-dashed) {
		color: ${props => props.theme.textColorSecondary};
	}
`;
const Body$1 = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter)};
`;
const Muted = styled.div `
	font-size: ${props => numToCssSize(props.theme.fz.small2)};
	font-weight: bold;
	color: ${props => props.theme.textColorSecondary};
	display: inline-flex;
	align-items: center;
`;
const Container$4 = styled.section `
	background-color: ${props => props.theme.appBackgroundColor};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	box-shadow: ${props => props.theme.boxShadowElevationOne};
	&.${CONTROLCLASS$3}--minimal {
		${TitleContainer} {
			border-bottom: 0 none;
			padding-bottom: ${props => numToCssSize(props.theme.gutter * 0.25)};
			padding-top: ${props => numToCssSize(props.theme.gutter * 1.5)};
		}
		${Title} {
			font-size: ${props => numToCssSize(props.theme.fz.base)};
		}
		${Body$1} {
			padding-top: ${props => numToCssSize(props.theme.gutter * 0.5)};
			padding-bottom: ${props => numToCssSize(props.theme.gutter * 1.5)};
		}
	}
	&.${CONTROLCLASS$3}--hasTitleControl {
		${Title} {
			padding-right: ${props => numToCssSize(props.theme.gutter)};
		}
		&.${CONTROLCLASS$3}--minimal {
			${TitleContainer} {
				position: relative;
			}
			${TitleControl} {
				position: absolute;
				top: ${props => numToCssSize(props.theme.gutter / 2)};
				right: ${props => numToCssSize(props.theme.gutter / 2)};
				opacity: 0;
				transition: ${props => getMultipleTransitionsWithWillChange(['opacity'], props.theme.transitionControl)};
			}
			&:hover {
				${TitleControl} {
					opacity: 1;
				}
			}
		}
	}
`;
function Widget(props) {
    const { children, title, minimal = false, className, titleControl } = props;
    return (jsxs(Container$4, Object.assign({ className: getBemClassName(CONTROLCLASS$3, { minimal, hasTitleControl: !!titleControl }, className) }, { children: [title ? (jsxs(TitleContainer, { children: [jsx(Title, { children: title }, void 0), titleControl ? jsx(TitleControl, { children: titleControl }, void 0) : null] }, void 0)) : null, jsx(Body$1, { children: children }, void 0)] }), void 0));
}
Widget.Muted = Muted;
const Controls = styled.div `
	display: flex;
	align-items: center;
	flex-flow: row wrap;
	max-width: 100%;
	position: relative;
	right: ${props => numToCssSize(props.theme.gutter * -0.2 * 2)};
	margin-top: ${props => numToCssSize(props.theme.gutter * -0.2)};
	margin-bottom: ${props => numToCssSize(props.theme.gutter * -0.2)};
	> * {
		margin: ${props => numToCssSize(props.theme.gutter * 0.2)};
	}
`;
Widget.Controls = Controls;

const CONTROLCLASS$2 = 'wpeform-control-datetimerange';
const SEPARATORCLASS = getBemElement(CONTROLCLASS$2, 'separator');
const UIWRAPPERCLASS = getBemElement(CONTROLCLASS$2, 'ui');
const Separator = styled.div `
	margin: ${props => numToCssSize(props.theme.gutter / 4)} 0;
	flex: 0 0 auto;
	min-width: 20px;
	text-align: center;
	padding: 0 ${props => numToCssSize((props.theme.gutter / 2) * 1.5)};
	position: relative;
	font-size: ${props => numToCssSize(props.theme.fz.small2)};
	font-weight: bold;
	text-transform: uppercase;
	color: ${props => props.theme.textColorSecondary};
	&::before,
	&::after {
		content: '';
		display: block;
		position: absolute;
		top: 50%;
		margin-top: -1px;
		height: 2px;
		background-color: ${props => props.theme.borderColorSplit};
		width: ${props => numToCssSize(props.theme.gutter / 2)};
	}
	&::before {
		left: 0;
	}
	&::after {
		right: 0;
	}
`;
const Container$3 = styled.div `
	display: flex;
	width: 100%;
	flex-flow: row wrap;
	align-items: center;
	justify-content: flex-start;
	margin: ${props => numToCssSize(props.theme.gutter / -4)};
	width: calc(100% + ${props => numToCssSize(props.theme.gutter / 2)});
	&.${CONTROLCLASS$2}--align-LEFT {
		justify-content: flex-start;
	}
	&.${CONTROLCLASS$2}--align-CENTER {
		justify-content: center;
	}
	&.${CONTROLCLASS$2}--align-RIGHT {
		justify-content: flex-end;
	}

	.${UIWRAPPERCLASS} {
		padding: ${props => numToCssSize(props.theme.gutter / 4)};
		flex: 0 0 auto;
	}

	.${CONTROLCLASS$b} {
		display: inline-flex;
		width: auto;
		flex: 0 0 auto;
	}

	&.${CONTROLCLASS$2}--type-datetime, &.${CONTROLCLASS$2}--vertical {
		.${UIWRAPPERCLASS} {
			width: 100%;
			flex: 0 0 100%;
		}
		.${CONTROLCLASS$b} {
			width: 100%;
			flex-basis: 100%;
		}
		${Separator} {
			width: 100%;
		}
	}
`;
function DateTimeRange(props) {
    const { separator = __('to', 'wp-eform'), minValue, maxValue, className, id, values, onChanges, vertical = false, controlAlignment = SettingsAppearanceControlAlignmentEnum.LEFT, ...pickerProps } = props;
    // figure out the dateTimeFormat
    let dateTimeFormat;
    if (props.dateTimeFormat) {
        dateTimeFormat = props.dateTimeFormat;
    }
    else {
        dateTimeFormat = getDefaultDateTimeFormatString(props.pickerType);
    }
    const containerClasses = getBemClassName(CONTROLCLASS$2, {
        [`align-${controlAlignment}`]: true,
        [`type-${props.pickerType}`]: true,
        vertical,
    }, className);
    return (jsxs(Container$3, Object.assign({ className: containerClasses, id: id }, { children: [jsx("div", Object.assign({ className: UIWRAPPERCLASS }, { children: jsx(DateTimePicker, Object.assign({ value: values[0], onChange: onChanges[0], minValue: minValue, maxValue: getMinDate(maxValue ?? '', values[1], dateTimeFormat), controlAlignment: controlAlignment }, pickerProps), void 0) }), void 0), separator !== '' ? (jsx("div", Object.assign({ className: UIWRAPPERCLASS }, { children: jsx(Separator, Object.assign({ className: SEPARATORCLASS }, { children: separator }), void 0) }), void 0)) : null, jsx("div", Object.assign({ className: UIWRAPPERCLASS }, { children: jsx(DateTimePicker, Object.assign({ value: values[1], onChange: onChanges[1], minValue: getMaxDate(minValue ?? '', values[0], dateTimeFormat), maxValue: maxValue, controlAlignment: controlAlignment }, pickerProps), void 0) }), void 0)] }), void 0));
}

const CONTROLCLASS$1 = 'wpeform-control-matrix-dropdown';
function MatrixDropdown(props) {
    const { className, rows, columns, value, onChange, fixedLayout = true, highlightOnHover = true, tableType = 'stripped', rowHeadingWidth = '180px', namePrefix, ...selectProps } = props;
    const colWidth = '180px';
    return (jsxs(Table, Object.assign({ className: getBemClassName(CONTROLCLASS$1, undefined, className), fixedLayout: fixedLayout, highlightOnHover: highlightOnHover, type: tableType, isBodyCentered: true }, { children: [jsx("thead", { children: jsxs("tr", { children: [jsx("th", { style: { width: rowHeadingWidth } }, void 0), columns.map(col => (jsx("th", Object.assign({ style: { width: col.width ?? colWidth }, id: `col-${col.id}` }, { children: col.title }), col.id)))] }, void 0) }, void 0), jsx("tbody", { children: rows.map(row => (jsxs("tr", { children: [jsx("th", Object.assign({ style: { width: rowHeadingWidth }, id: `row-${row.id}` }, { children: row.title }), void 0), columns.map(col => (jsx("td", Object.assign({ style: { width: col.width ?? colWidth } }, { children: jsx(Select, Object.assign({}, selectProps, { value: value[row.id][col.id], onChange: newVal => {
                                    onChange(row.id, col.id, newVal);
                                }, name: namePrefix ? `${namePrefix}[${row.id}]` : undefined, ariaLabelledby: `row-${row.id} col-${col.id}` }), void 0) }), col.id)))] }, row.id))) }, void 0), jsx("tfoot", { children: jsxs("tr", { children: [jsx("th", { style: { width: rowHeadingWidth } }, void 0), columns.map(col => (jsx("th", Object.assign({ style: { width: colWidth } }, { children: col.title }), col.id)))] }, void 0) }, void 0)] }), void 0));
}

// List of extensions for validity
const validImageExtensions = [
    'jpg',
    'jpeg',
    'png',
    'apng',
    'webp',
    'gif',
    'tiff',
    'raw',
    'bmp',
    'heif',
    'indd',
    'svg',
];
const validVideoExtensions = [
    'webm',
    'mpg',
    'mp2',
    'mpeg',
    'mpe',
    'mpv',
    'mp4',
    'm4p',
    'm4v',
    'avi',
    'wmv',
    'mov',
    'qt',
    'flv',
    'swf',
    'avchd',
];
const validAudioExtensions = [
    'm4a',
    'pcm',
    'wav',
    'aiff',
    'mp3',
    'aac',
    'ogg',
    'wma',
    'flac',
    'alac',
    'wma',
];
/**
 * Get dailymotion embed URL from user input.
 *
 * @param dirtyUrl URL from user input
 */
function getDailyMotion(dirtyUrl) {
    const dailyMotionRegex = /(?:dailymotion\.com(?:\/video|\/hub)|dai\.ly)\/([0-9a-z]+)(?:[-_0-9a-zA-Z]+#video=([a-z0-9]+))?/g;
    const result = dailyMotionRegex.exec(dirtyUrl);
    return ((result &&
        result[1] &&
        `https://www.dailymotion.com/embed/video/${result[1]}`) ||
        dirtyUrl);
}
/**
 * Get wistia embed URL from user input.
 *
 * @param dirtyUrl URL from user input.
 */
function getWistia(dirtyUrl) {
    const wistiaResults = dirtyUrl.split('/');
    const result = wistiaResults[wistiaResults.length - 1];
    return result ? `https://fast.wistia.net/embed/iframe/${result}` : dirtyUrl;
}
const defaultEmbedUrlParams = {
    includeModestYouTubeBranding: false,
};
/**
 * Parse possible embed URL from user input.
 *
 * @param url URL from user input.
 * @param params Options.
 */
function parseEmbedUrl(url, params = defaultEmbedUrlParams) {
    const result = {
        type: 'invalid',
        cleanUrl: url,
    };
    // Check for possible embed types and clean up the URL if matches
    const vimeo = /vimeo.*\/(\d+)/i.exec(url);
    const youtubeRegex = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
    const matchesYouTube = url.match(youtubeRegex);
    if (vimeo && vimeo[1]) {
        result.type = 'vimeo';
        result.cleanUrl = `https://player.vimeo.com/video/${vimeo[1]}`;
    }
    else if (url.includes('dailymotion') || url.includes('dai.ly')) {
        result.type = 'dailymotion';
        result.cleanUrl = getDailyMotion(url);
    }
    else if (url.includes('wistia')) {
        result.type = 'wistia';
        result.cleanUrl = getWistia(url);
    }
    else if (matchesYouTube && matchesYouTube[2].length === 11) {
        result.type = 'youtube';
        result.cleanUrl = `https://www.youtube.com/embed/${matchesYouTube[2]}${params && params.includeModestYouTubeBranding
            ? '?rel=0&showinfo=0&modestbranding=0&enablejsapi=1'
            : ''}`;
    }
    return result;
}
function parseMediaUrl(url, params = defaultEmbedUrlParams) {
    // First check for YouTube or Vimeo
    const possibleEmbed = parseEmbedUrl(url, params);
    if (possibleEmbed.type !== 'invalid') {
        return {
            filename: ['', ''],
            ...possibleEmbed,
        };
    }
    // Not embed, so let's create the result manually
    const result = {
        filename: ['', ''],
        type: 'invalid',
        cleanUrl: url,
    };
    // get the pathname from the URL
    let parsedUrl;
    try {
        if (/^\/[^/]/.test(url)) {
            parsedUrl = new URL(url, getCurrentOrigin());
        }
        else {
            parsedUrl = new URL(url);
        }
    }
    catch (e) {
        result.cleanUrl = '';
        return result;
    }
    const { pathname } = parsedUrl;
    // get the filename from pathname
    const pathParts = pathname.split('/');
    const filename = pathParts.pop();
    // If there's no filename, then it is an invalid item
    if (!filename) {
        return result;
    }
    // get the parts of filename for extension
    const fileNameParts = filename.split('.');
    // if fileNamParts is not at-least 2, then . doesn't exist, hence not a file
    if (fileNameParts.length < 2) {
        return result;
    }
    let extension = fileNameParts.pop();
    // If there's no extension, then it is invalid
    if (!extension) {
        return result;
    }
    // Now that we have got the extension, let's calculate
    extension = extension.toLowerCase();
    const fileNameWithoutExtension = fileNameParts.join('');
    result.filename = [fileNameWithoutExtension, extension];
    // Now check for types
    if (validImageExtensions.includes(extension)) {
        result.type = 'image';
    }
    else if (validAudioExtensions.includes(extension)) {
        result.type = 'audio';
    }
    else if (validVideoExtensions.includes(extension)) {
        result.type = 'video';
    }
    return result;
}

const CONTROLCLASS = 'wpeform-control-media-selector';
const Container$2 = styled.div `
	display: flex;
	flex-flow: row wrap;
	margin: 0 ${props => numToCssSize(props.theme.gutter * -1)};
`;

const IFRAMECLASS = getBemElement(CONTROLCLASS, 'embed');
const IFrame = styled.iframe `
	border: 0 none;
	display: block;
	width: 100%;
`;
function Embed(props) {
    const { height, src, setLoaded, alt } = props;
    return (jsx(IFrame, { className: IFRAMECLASS, src: src, title: alt, frameBorder: "0", height: height, allow: "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture", allowFullScreen: true, onLoad: setLoaded, loading: "lazy" }, void 0));
}

const IMGCLASS = getBemElement(CONTROLCLASS, 'img');
const LABELCLASS = getBemElement(CONTROLCLASS, 'img-label');
const Img = styled.img `
	display: block;
	object-fit: cover;
	width: 100%;
	border: 0 none;
	cursor: pointer;
	transition: ${props => getMultipleTransitionsWithWillChange(['transform'], props.theme.transitionControl)};
	transform: scale(1) rotate(0deg);
	&:hover {
		transform: scale(1.1) rotate(2deg);
	}
`;
const Label$1 = styled.label `
	display: block;
	cursor: pointer;
`;
function Image(props) {
    const { height, width, setLoaded, src, alt, itemId } = props;
    return (jsx(Label$1, Object.assign({ htmlFor: itemId, className: LABELCLASS }, { children: jsx(Img, { className: IMGCLASS, style: { height: numToCssSize(height) }, height: height, width: width, src: src, alt: alt, onLoad: setLoaded, loading: "lazy" }, void 0) }), void 0));
}

const VIDEOCLASS = getBemElement(CONTROLCLASS, 'video');
const Vid = styled.video `
	display: block;
	width: 100%;
`;
function Video(props) {
    const { height, setLoaded, src, width, alt } = props;
    return (jsx(Vid, { className: VIDEOCLASS, src: src, controls: true, title: alt, width: width, height: height, onLoadedMetadata: setLoaded }, void 0));
}

/*!
 * Music visual for creating a gooey effect.
 *
 * Based on
 * @link https://codepen.io/enjikaka/pen/QbJmRJ
 */
class MusicVisual {
    rafId = null;
    frequencyData = null;
    bars;
    analyser = null;
    context = null;
    source = null;
    canShowSpectrum = false;
    constructor(audioSource, bars) {
        this.bars = bars;
        this.animate = this.animate.bind(this);
        if (typeof window.AudioContext === 'undefined') {
            this.canShowSpectrum = false;
            return;
        }
        if (typeof window.Uint8Array === 'undefined') {
            this.canShowSpectrum = false;
            return;
        }
        this.canShowSpectrum = true;
        const context = new AudioContext();
        const source = context.createMediaElementSource(audioSource);
        const analyser = context.createAnalyser();
        this.context = context;
        this.source = source;
        this.analyser = analyser;
        this.frequencyData = new Uint8Array(analyser.frequencyBinCount);
    }
    start() {
        if (!this.canShowSpectrum) {
            return;
        }
        this.source.connect(this.analyser);
        this.analyser.connect(this.context.destination);
        this.analyser.fftSize = 1024;
        this.animate();
    }
    resetBars() {
        this.bars.forEach(bar => {
            bar.style.transform = 'translateZ(0) translateY(100%)';
        });
    }
    animate() {
        this.analyser.getByteFrequencyData(this.frequencyData);
        let barcc = 0;
        const numberOfBars = this.bars.length;
        for (let increment = -1; increment < numberOfBars * 2; increment += 2) {
            const y = this.frequencyData[increment];
            barcc = barcc + 1;
            if (barcc > numberOfBars) {
                barcc = 0;
            }
            const bar = this.bars[barcc];
            if (bar) {
                const yPercent = roundNumber(((230 - y) / 200) * 100, 2);
                bar.style.transform = `translateZ(0) translateY(${yPercent}%)`;
            }
        }
        this.rafId = window.requestAnimationFrame(this.animate);
    }
    stop() {
        if (!this.canShowSpectrum) {
            return;
        }
        if (this.rafId !== null) {
            window.cancelAnimationFrame(this.rafId);
        }
        this.source.disconnect(this.analyser);
        this.analyser.disconnect(this.context.destination);
        this.resetBars();
        this.context?.close();
    }
}

const AUDIOCLASS = getBemElement(CONTROLCLASS, 'audio');
const CONTAINERCLASS$1 = getBemElement(CONTROLCLASS, 'audio-container');
const SPECTRUMCLASS = getBemElement(CONTROLCLASS, 'spectrum');
const BARCLASS = getBemElement(CONTROLCLASS, 'bar');
const Spectrum = styled.div `
	position: absolute;
	height: auto;
	width: 100%;
	top: 0;
	left: 0;
	bottom: 20px;
	display: flex;
	flex-direction: row;
	align-items: flex-end;
	filter: url('#${props => props.svgId}');
	box-sizing: border-box;
	transform: translateZ(0);
	z-index: 9;
	user-select: none;

	.${BARCLASS} {
		background-color: ${props => props.theme.borderColorSplit};
		flex: 1 1 auto;
		height: 100%;
		transform: translateZ(0) translateY(100%);
		will-change: transform;
		contain: strict;
		overflow: hidden;
	}
`;
const Aud = styled.audio `
	position: absolute;
	left: 0;
	bottom: 0;
	z-index: 10;
	display: block;
	width: 100%;
	outline: none;
	background-color: ${props => props.theme.backgroundShade};
	&::-webkit-media-controls-enclosure {
		border-radius: 0 !important;
		border-top: 1px solid ${props => props.theme.borderColorSplit};
	}
	&::-webkit-media-controls-panel {
		background-color: ${props => props.theme.backgroundShade};
	}
`;
const IconContainer = styled.div `
	position: absolute;
	display: flex;
	z-index: 8;
	top: 0;
	left: 0;
	width: 100%;
	height: auto;
	bottom: 60px;
	font-size: ${props => numToCssSize(props.theme.fz.large7)};
	color: ${props => props.theme.borderColorSplit};
	text-shadow: 4px 4px 0 ${props => props.theme.borderColorLight};
	justify-content: center;
	align-items: center;
	will-change: transform, opacity;
	transform-origin: center center;
`;
const pulse = keyframes `
	0%,
	20%,
	40%,
	80% {
		opacity: 0.75;
		transform: scale(1, 1);
	}
	100%,
	60%,
	30%,
	10% {
		opacity: 1;
		transform: scale(0.8, 0.8);
	}
`;
const Container$1 = styled.div `
	position: absolute;
	top: 0;
	left: 0;
	height: 100%;
	width: 100%;
	background-color: transparent;

	&.${CONTAINERCLASS$1}--playing {
		${IconContainer} {
			animation: ${pulse} 1000ms linear infinite;
		}
	}
`;
function Audio(props) {
    const { setLoaded, src, alt } = props;
    const spectrumRef = useRef(null);
    const audioRef = useRef(null);
    const iconContainerRef = useRef(null);
    useEffect(() => {
        if (!audioRef.current || !spectrumRef.current || window.innerWidth < 760) {
            return () => { };
        }
        const visual = new MusicVisual(audioRef.current, spectrumRef.current.querySelectorAll(`.${BARCLASS}`));
        visual.start();
        return () => {
            visual.stop();
        };
    }, []);
    const svgId = useQuestionId();
    const [playing, setPlaying] = useState(false);
    return (jsxs(Container$1, Object.assign({ className: getBemClassName(CONTAINERCLASS$1, { playing }) }, { children: [jsx(Spectrum, Object.assign({ className: SPECTRUMCLASS, ref: spectrumRef, svgId: svgId }, { children: Array.from({ length: 128 }).map((_, index) => (
                // eslint-disable-next-line react/no-array-index-key
                jsx("div", { className: BARCLASS }, index))) }), void 0), jsx(Aud, { className: AUDIOCLASS, ref: audioRef, src: src, controls: true, title: alt, onLoadedMetadata: setLoaded, onPlay: () => {
                    setPlaying(true);
                }, onPause: () => {
                    setPlaying(false);
                } }, void 0), jsx(IconContainer, Object.assign({ ref: iconContainerRef }, { children: jsx(Icon, { iconClass: "fas fa-music" }, void 0) }), void 0), jsxs("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "800" }, { children: [jsx("defs", {}, void 0), jsxs("filter", Object.assign({ id: svgId }, { children: [jsx("feGaussianBlur", { in: "SourceGraphic", stdDeviation: "10", result: "blur" }, void 0), jsx("feColorMatrix", { in: "blur", mode: "matrix", values: "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9", result: svgId }, void 0), jsx("feComposite", { in: "SourceGraphic", in2: svgId, operator: "atop" }, void 0)] }), void 0)] }), void 0)] }), void 0));
}

const CONTAINERCLASS = getBemElement(CONTROLCLASS, 'card-container');
const BODYCLASS = getBemElement(CONTROLCLASS, 'card-body');
const FOOTERCLASS = getBemElement(CONTROLCLASS, 'card-footer');
const CARDCONTROLCLASS = getBemElement(CONTROLCLASS, 'card-control');
const CARDLABELCLASS = getBemElement(CONTROLCLASS, 'card-label');
const Body = styled.div `
	max-width: 100%;
	margin: 0 auto ${props => numToCssSize(props.theme.gutter / 2)};
	background-color: ${props => props.theme.backgroundShade};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	overflow: hidden;
	position: relative;
`;
const Loader = styled.div `
	position: absolute;
	top: 0;
	left: 0;
	height: 100%;
	width: 100%;
`;
const Footer = styled.label `
	display: flex;
	flex-flow: row nowrap;
	padding: ${props => numToCssSize(props.theme.gutter / 2)};
	border-top: 1px solid ${props => props.theme.borderColorBase};
	border-bottom: 1px solid ${props => props.theme.borderColorBase};
	align-items: center;
	justify-content: flex-start;
	cursor: pointer;
	position: relative;
	&::before,
	&::after {
		content: '';
		width: 0%;
		background-color: ${props => props.theme.primaryColor};
		height: 1px;
		display: block;
		position: absolute;
		left: 50%;
		transform: translateX(-50%);
		transition: ${props => getMultipleTransitionsWithWillChange(['width'], props.theme.transitionBeizer)};
	}
	&::before {
		top: -1px;
	}
	&::after {
		bottom: -1px;
	}

	&:hover {
		&::before,
		&::after {
			width: 100%;
		}
	}
`;
const Control = styled.div `
	flex: 0 0
		${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7))};
	width: ${props => numToCssSize(getNextEvenNumber(props.theme.controlHeightBase * 0.7))};
	margin: 0 ${props => numToCssSize(props.theme.gutter / 2)} 0 0;
`;
const Label = styled.div `
	flex: 1 0 auto;
`;
const Container = styled.div `
	max-width: 100%;
	flex: 0 0 ${props => props.w};
	width: ${props => props.w};
	margin: ${props => numToCssSize(props.theme.gutter / 2)};
	&.${CONTAINERCLASS}--checked {
		${Footer} {
			&::before,
			&::after {
				width: 100%;
			}
		}
	}
`;
function Card(props) {
    const { aspectRatio, src, control, height, label, checked, alt, itemId } = props;
    const width = roundNumber(height * aspectRatio, 0);
    const widthPx = numToCssSize(width);
    const parsedMedia = useMemo(() => parseMediaUrl(src), [src]);
    const [loading, setLoading] = useState(true);
    const setLoaded = () => {
        setLoading(false);
    };
    return (jsxs(Container, Object.assign({ className: getBemClassName(CONTAINERCLASS, {
            checked,
            [`type-${parsedMedia.type}`]: true,
        }), w: widthPx }, { children: [jsxs(Body, Object.assign({ className: BODYCLASS, style: { width: widthPx, height: numToCssSize(height) } }, { children: [loading ? (jsx(Loader, { children: jsx(Skeleton, { height: height, width: "100%", shape: "sharp" }, void 0) }, void 0)) : null, ['dailymotion', 'youtube', 'vimeo', 'wistia'].includes(parsedMedia.type) ? (jsx(Embed, { src: parsedMedia.cleanUrl, height: height, setLoaded: setLoaded, alt: alt }, void 0)) : parsedMedia.type === 'image' ? (jsx(Image, { src: src, alt: alt, height: height, width: width, setLoaded: setLoaded, itemId: itemId }, void 0)) : parsedMedia.type === 'video' ? (jsx(Video, { src: src, alt: alt, height: height, width: width, setLoaded: setLoaded }, void 0)) : parsedMedia.type === 'audio' ? (jsx(Audio, { src: parsedMedia.cleanUrl, alt: alt, setLoaded: setLoaded }, void 0)) : (jsx("p", { children: "Unrecognizable src. Please check" }, void 0))] }), void 0), jsxs(Footer, Object.assign({ className: FOOTERCLASS }, { children: [jsx(Control, Object.assign({ className: CARDCONTROLCLASS }, { children: control }), void 0), jsx(Label, Object.assign({ className: CARDLABELCLASS }, { children: label }), void 0)] }), void 0)] }), void 0));
}

function MediaSelector(props) {
    const { value, items, icon, type, onChange, onBlur, height = 200, className, id, name, disabled = false, } = props;
    return (jsx(Container$2, Object.assign({ className: getBemClassName(CONTROLCLASS, undefined, className) }, { children: items.map(item => {
            const isChecked = value.includes(item.id);
            const itemId = `${id ?? ''}-${item.id}`;
            return (jsx(Card, { height: height, aspectRatio: item.aspectRatio ?? 16 / 9, checked: isChecked, itemId: itemId, control: type === 'single' ? (jsx(Radio, { checked: isChecked, onChange: checked => {
                        if (checked) {
                            onChange([item.id]);
                        }
                    }, disabled: disabled, icon: icon, onBlur: onBlur, name: name, id: itemId }, void 0)) : (jsx(Checkbox, { checked: isChecked, onChange: checked => {
                        const newChecked = [];
                        items.forEach(i => {
                            if (i.id !== item.id && value.includes(i.id)) {
                                newChecked.push(i.id);
                            }
                            else if (i.id === item.id && checked) {
                                newChecked.push(i.id);
                            }
                        });
                        onChange(newChecked);
                    }, disabled: disabled, icon: icon, onBlur: onBlur, name: name, id: itemId }, void 0)), label: item.label, src: item.src }, item.id));
        }) }), void 0));
}

export { AnimatedCircle, ControlButton, CountUp, DataTable, DateTimeRange, GraphSkeleton, HighlightFuzzySearch, MatrixDropdown, MediaSelector, Pulse, Repeatable, Widget };
