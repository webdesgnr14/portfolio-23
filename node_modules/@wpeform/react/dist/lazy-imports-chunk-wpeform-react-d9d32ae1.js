import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { library } from '@fortawesome/fontawesome-svg-core';
import { fab } from '@fortawesome/free-brands-svg-icons';
import { fas } from '@fortawesome/free-solid-svg-icons';
import { far } from '@fortawesome/free-regular-svg-icons';
import * as React from 'react';
import React__default, { useEffect, useMemo, useCallback, useState, useRef, Fragment as Fragment$1 } from 'react';
import { InMemoryCache, ApolloClient, HttpLink, gql, useQuery, useMutation, useLazyQuery, ApolloProvider } from '@apollo/client';
import { J as Exception, _ as __, K as Button, l as GenericSizeEnum, X as numToCssSize, be as useSubmissionFormData, bf as useSubmissionStore, bg as submissionStoreCurrentPageSelector, bh as submissionStoreLastTouchedElementIdSelector, bi as useFormNavActions, bj as useSubmissionStoreApi, bk as getAllConditionallyShownChildrenOfCurrentPage, bl as areElementsErrorFree, ad as IconMessage, a3 as Icon, bm as GridElements, aj as cssReset, j as FormSettingsBackgroundRepeatEnum, i as FormSettingsBackgroundOriginAndClipEnum, h as FormSettingsBackgroundAttachmentEnum, bn as useSlateJsonMentions, bo as useSlateJsonDynamicAnchors, bp as useNodesFromJson, aF as SlateView, bq as getDefaultSlateNodeWithChildren, ab as sprintf, br as SlateViewWithData, bs as getNodesFromJSON, bt as MentionsProvider, bu as submissionStoreElementsSelector, R as RedirectTypeEnum, bv as useScheduledInvoke, bw as areLogicEventsCheckedOut, bx as fsIsPlanOrHigher, x as SubmitTimerEnum, aE as ResponsiveContainer, aq as useQuestionId, by as submissionStoreRemarksSelector, bz as useSubmissionDispatch, aD as Question, aI as Textarea, bA as useSubmissionFormMeta, bB as submissionStoreStructuresSelector, bC as submissionStoreStartTimeSelector, bD as useSubmissionFormRenderMode, bE as useFormElementConditionalMap, bF as getActiveStructuresAfterReset, bG as getActiveElementsAfterReset, e as FormPaginationRestrictionEnum, B as ButtonIconPositionEnum, bH as submissionForceShowErrorsContext, bI as activeErrorElementContext, bJ as formNavActionsContext, aA as Grid, au as Alert, ay as ButtonsGroup, G as GenericAlignmentEnum, bK as getSlateMentionsOnElementsAndScore, bL as DynamicAnchorProvider, bM as useThemeStyleFromFormStyle, bN as SubmissionStore, bO as defaultInitialSubmissionData, bP as submissionFormDataContext, bQ as submissionFormMetaContext, bR as submissionFormRenderModeContext, bS as formElementConditionalMapContext, A as ThemedContainer, b8 as useDebouncedCallback, bT as convertFormData, bU as useFormSubmissionSubmit, y as Shadow, z as FormSkeleton, bV as getCurrentUrl, bW as logger, aH as Slider, bX as produce, bY as validationMessages, aZ as formatNumber, bZ as validateValueInStep, b_ as getFloatValue, E as EventComparisonEnum, c as EventOperationEnum, b$ as isNullOrEmptyString, n as PrefilEnum, c0 as getUrlParameterValue, c1 as decodeJSONRecord, c2 as Node, c3 as getStringValueFromJSON, c4 as wpEFormElementFrontCollection, ax as AnswerPreview, c5 as MemoizedElement, a5 as _x, N as NumberComparisonEnum, az as ControlAddon, a4 as Text, c6 as verifyJsonDataStructureForStorage, b as EventHasEnum, c7 as getLengthComparisonStatus, c8 as getConditionStatusBasedOnOperation, c9 as SlateViewWithoutMentions, ca as SvgGenericCheckboxChecked, cb as SvgGenericCheckboxUnchecked, aR as shuffleArray, cc as areArraysEqual, cd as Collections, b0 as dayjs, ce as parsePossibleDateTimeFormula, cf as parsePossibleMySQLDateTimeString, cg as mysqlFormat, ch as compareDates, ci as getDayjsFromMySQLInput, cj as makeTheme, ck as wpEFormThemes, cl as OverrideDarkModeProvider } from './index-chunk-wpeform-react-daf2eca0.js';
import * as qs from 'query-string';
import styled from 'styled-components';
import { F as FallbackContainer, a as FrontEndErrorBoundary } from './index-chunk-wpeform-react-b4d17b34.js';
import { I as InlineCountDown, e as Timer, A as ActionFeedback, d as Tabs, S as Spinner, M as MathOutput, R as Rating, c as ControlGroup, g as MatrixChoice, i as Sortable, D as DateTimePicker, k as generalDateTimeParseFormat, h as MatrixInput, f as Address, l as addressFieldsInOrder, j as Toggle } from './index-chunk-wpeform-react-081736f4.js';

const apolloCache = new InMemoryCache({
    addTypename: true,
    resultCaching: true,
    // these type policies are for already developed GraphQL Types
    // for new types, AVOID using `id` or `_id` if those do not correspond to
    // some solid PRIMARY KEY from DB.
    typePolicies: {
        FormElementConfigMcqOptionType: {
            keyFields: false,
        },
        CategoryType: {
            keyFields: ['id'],
        },
        FormType: {
            keyFields: ['id'],
        },
        IntegrationCustomDataType: {
            keyFields: false,
        },
        FormPaymentsCouponItemType: {
            keyFields: false,
        },
        FormScoreItemType: {
            keyFields: false,
        },
        FormScoreDesignationType: {
            keyFields: false,
        },
        FormScoreTotalRedirectionItemType: {
            keyFields: false,
        },
        FormScorePercentageRedirectionItemType: {
            keyFields: false,
        },
        FormScoreConditionalRedirectionItemType: {
            keyFields: false,
        },
        ConditionalEventType: {
            keyFields: false,
        },
        FormStructureType: {
            keyFields: false,
        },
        FormElementType: {
            keyFields: false,
        },
        FormElementAppearanceWidthType: {
            keyFields: false,
        },
        FormElementConfigButtonType: {
            keyFields: false,
        },
        ElementScoreConditionType: {
            keyFields: false,
        },
        FormElementConfigMaskRegExpType: {
            keyFields: false,
        },
        FormPoolType: {
            keyFields: false,
        },
        ConditionalType: {
            keyFields: false,
        },
        ConditionalConsequenceType: {
            keyFields: false,
        },
        User: {
            keyFields: ['id'],
        },
        FormLimitationMessageType: {
            keyFields: false,
        },
        FormNodeType: {
            keyFields: ['id'],
        },
        FormMetaPaymentGatewayType: {
            keyFields: false,
        },
        FormIntegrationMailChimpListItemType: {
            keyFields: false,
        },
        SubmissionType: {
            keyFields: ['id'],
        },
        FormSubmissionElementType: {
            keyFields: false,
        },
        SubmissionNodeType: {
            keyFields: ['id'],
        },
        SubmissionMetaOwnerType: {
            keyFields: false,
        },
        FormMetaOwnerType: {
            keyFields: false,
        },
        SubmissionMetaCategoryType: {
            keyFields: false,
        },
        FormMetaCategoryType: {
            keyFields: false,
        },
    },
});
if (typeof window !== 'undefined') {
    window.wpeformApolloCache = apolloCache;
}
let uri = '/graphql';
try {
    if (typeof process.env.WPEFORM_GQL_URI === 'string') {
        uri = process.env.WPEFORM_GQL_URI;
    }
}
catch (e) {
    // do nothing
}
if (typeof WPEFormGraphQLApp !== 'undefined') {
    uri = WPEFormGraphQLApp.gqlUri;
}
const apolloClient = new ApolloClient({
    cache: apolloCache,
    link: new HttpLink({
        uri,
    }),
});

const fragment$c = gql `
	fragment FConfigConditionals on ConditionalType {
		id
		events {
			id
			fieldid
			has
			operation
			operator
			value
			relation
		}
		consequences {
			id
			action
			fieldsToShow
			fieldsToHide
			fieldToSet
			value
			pagesToShow
			pagesToHide
		}
	}
`;

const fragment$b = gql `
	fragment FConfigSettingsTImer on FormSettingsTimerType {
		recordSubmissionTime
		showStopwatch
		submitTimer
		showTimer
		timeLimit
		timerMessage
	}
`;

const fragment$a = gql `
	fragment FConfigSettingsScore on FormSettingsScoreType {
		precision
		scoreLists {
			id
			name
			color
			outcomeName
			outcomeDescription
		}
		designations {
			description
			from
			fromToType
			id
			name
			scoreCategory
			to
		}
	}
`;

const fragment$9 = gql `
	fragment FConfigStyleAppearance on FormStylesAppearanceType {
		containerLayout
		maxWidth
		controlType
		controlAlignment
		controlLayout
	}
`;

const fragment$8 = gql `
	fragment FConfigStylePagination on FormStylesPaginationType {
		# TABS and PROGRESS Bar
		showTabs
		showProgressBar
		progressDecimalPoint
		progressBarPosition
		showProgressLabel
		# SCROLL Behavior
		autoProgress
		autoProgressDelay
		autoScroll
		scrollOffset
		autoSubmit
		blockPreviousNavigation
		paginationRestriction
		# Buttons Panel
		panelEnabled
		alignment
		size
		style
		rounded
		colored
		barlike
		nextLabel
		nextIcon
		nextIconPosition
		prevLabel
		prevIcon
		prevIconPosition
		submitLabel
		submitIcon
		submitIconPosition
		updateLabel
		updateIcon
		updateIconPosition
		showResetButton
		resetLabel
		resetMessage
		resetIcon
		resetIconPosition
		hideWhenNotRelevant
	}
`;

const fragment$7 = gql `
	fragment FConfigStyleCustomBackground on FormStylesCustomBackgroundType {
		backgroundImage
		backgroundClip
		backgroundAttachment
		backgroundOrigin
		backgroundPosition
		backgroundRepeat
		backgroundSize
		enabled
	}
`;

const fragment$6 = gql `
	fragment FConfigStyleTheme on FormStylesThemeType {
		css
		customColorBg
		customColorPrimary
		customColorSecondary
		customColorText
		scheme
		darkMode
	}
`;

const fragment$5 = gql `
	fragment FConfigStyleTypography on FormStylesTypographyType {
		baseFont
		bodyFamily
		bodyFamilyCustom
		headFamily
		headFamilyCustom
		headFontBold
		headFontItalic
	}
`;

const fragment$4 = gql `
	fragment FConfigStyleFormBehavior on FormStylesFormBehaviorType {
		disabledAutoComplete
		subject
		message
		updateSubject
		updateMessage
		kioskMode
		kioskMessage
		kioskTime
		errorSubject
		errorRetryButtonLabel
		errorRetryButtonIcon
		errorRetryButtonIconPosition
	}
`;

const fragment$3 = gql `
	fragment FConfigStyleRedirection on FormStylesRedirectionType {
		type
		url
		delay
		message
		iframeRedirect
		scoreTotalLogic {
			id
			scoreId
			url
			from
			to
		}
		scorePercentageLogic {
			id
			scoreId
			url
			from
			to
		}
		conditionalLogic {
			id
			url
			events {
				fieldid
				has
				id
				operation
				operator
				relation
				value
			}
		}
	}
`;

const fragment$2 = gql `
	fragment FConfigStyleTracking on FormStylesTrackingType {
		urlTracking
		urlTrackId
	}
`;

const fragment$1 = gql `
	fragment FConfigStyles on FormStylesType {
		appearance {
			...FConfigStyleAppearance
		}
		pagination {
			...FConfigStylePagination
		}
		customBackground {
			...FConfigStyleCustomBackground
		}
		theme {
			...FConfigStyleTheme
		}
		typography {
			...FConfigStyleTypography
		}
		formBehavior {
			...FConfigStyleFormBehavior
		}
		redirection {
			...FConfigStyleRedirection
		}
		tracking {
			...FConfigStyleTracking
		}
	}
	${fragment$9}
	${fragment$8}
	${fragment$7}
	${fragment$6}
	${fragment$5}
	${fragment$4}
	${fragment$3}
	${fragment$2}
`;

/**
 * Common Appearance for all elements.
 */
const appearanceFragment = gql `
	fragment FElementAppearance on FormElementAppearanceType {
		title
		subtitle
		description
		overrideControlAppearance
		controlType
		controlAlignment
		controlLayout
		hint
		hintIcon
		hintLabel
		answerDescription
		columnSize
		basicWidth
		widths {
			id
			containerMinWidth
			elementWidth
		}
		initiallyHidden
		className
	}
`;

const configFragment$h = gql `
	fragment FButtonsConfig on FormElementButtonsConfigType {
		attributes {
			open
			popupHeight
			popupWidth
		}
		buttons {
			id
			icon
			iconPosition
			label
			link
		}
		interface {
			alignment
			colored
			size
			style
			rounded
		}
	}
`;
// there are no fragments for submission

const configFragment$g = gql `
	fragment FCheckboxConfig on FormElementCheckboxConfigType {
		interface {
			icon
			columns
			options {
				...FElemInterfaceOptionsConfig
			}
			others
			othersId
			othersPlaceholder
			shuffle
		}
		score {
			...FElemScoreConfig
		}
		attributes {
			...FElemAttributeConfig
		}
		validation {
			required
			filters {
				...FElemValidationFiltersConfig
			}
		}
	}
`;
const submissionFragment$g = gql `
	fragment FCheckboxSubmission on FormElementCheckboxSubmissionElementValueType {
		selected
		other
	}
`;

const configFragment$f = gql `
	fragment FDropdownConfig on FormElementDropdownConfigType {
		interface {
			icon
			placeholder
			showSearch
			searchPlaceholder
			emptySearchResultNotice
			options {
				...FElemInterfaceOptionsConfig
			}
			othersId
			others
			othersPlaceholder
			shuffle
		}
		attributes {
			...FElemAttributeConfig
		}
		score {
			...FElemScoreConfig
		}
		validation {
			filters {
				...FElemValidationFiltersConfig
			}
			required
			selectType
		}
	}
`;
const submissionFragment$f = gql `
	fragment FDropdownSubmission on FormElementDropdownSubmissionElementValueType {
		selected
		other
	}
`;

const configFragment$e = gql `
	fragment FHeadingConfig on FormElementHeadingConfigType {
		interface {
			divider
			icon
			showTop
			size
			tag
		}
	}
`;
// no submission fragment

const configFragment$d = gql `
	fragment FRadioConfig on FormElementRadioConfigType {
		interface {
			columns
			icon
			othersId
			options {
				...FElemInterfaceOptionsConfig
			}
			others
			othersPlaceholder
			shuffle
		}
		attributes {
			...FElemAttributeConfig
		}
		score {
			...FElemScoreConfig
		}
		validation {
			required
		}
	}
`;
const submissionFragment$e = gql `
	fragment FRadioSubmission on FormElementRadioSubmissionElementValueType {
		other
		selected
	}
`;

const configFragment$c = gql `
	fragment FTextConfig on FormElementTextConfigType {
		interface {
			icon
			placeholder
		}
		attributes {
			...FElemAttributeConfig
		}
		score {
			...FElemScoreConfig
		}
		validation {
			filters {
				...FElemValidationFiltersConfig
			}
			masks {
				...FElemValidationMasks
			}
			required
		}
	}
`;
const submissionFragment$d = gql `
	fragment FTextSubmission on FormElementTextSubmissionElementValueType {
		input
	}
`;

const configFragment$b = gql `
	fragment FTextareaConfig on FormElementTextareaConfigType {
		interface {
			icon
			placeholder
		}
		attributes {
			...FElemAttributeConfig
		}
		score {
			...FElemScoreConfig
		}
		validation {
			required
			filters {
				...FElemValidationFiltersConfig
			}
		}
	}
`;
const submissionFragment$c = gql `
	fragment FTextareaSubmission on FormElementTextareaSubmissionElementValueType {
		input
	}
`;

const configFragment$a = gql `
	fragment FToggleConfig on FormElementToggleConfigType {
		interface {
			activeIcon
			activeLabel
			inactiveIcon
			inactiveLabel
		}
		score {
			...FElemScoreConfig
		}
		attributes {
			...FElemAttributeConfig
		}
		validation {
			required
		}
	}
`;
const submissionFragment$b = gql `
	fragment FToggleSubmission on FormElementToggleSubmissionElementValueType {
		selected
	}
`;

const configFragment$9 = gql `
	fragment FSliderConfig on FormElementSliderConfigType {
		score {
			...FElemScoreConfig
		}
		attributes {
			...FElemAttributeConfig
		}
		interface {
			customMarks {
				index
				label
				markId
			}
			max
			min
			precision
			showFreeInput
			showMarks
			step
		}
	}
`;
const submissionFragment$a = gql `
	fragment FSliderSubmission on FormElementSliderSubmissionElementValueType {
		selected
	}
`;

const configFragment$8 = gql `
	fragment FRangeConfig on FormElementRangeConfigType {
		score {
			...FElemScoreConfig
		}
		attributes {
			...FElemAttributeConfig
		}
		interface {
			customMarks {
				index
				label
				markId
			}
			max
			min
			precision
			separator
			showFreeInput
			showMarks
			step
		}
	}
`;
const submissionFragment$9 = gql `
	fragment FRangeSubmission on FormElementRangeSubmissionElementValueType {
		maxSelected
		minSelected
	}
`;

const configFragment$7 = gql `
	fragment FMathcalcConfig on FormElementMathcalcConfigType {
		interface {
			decimalSeparator
			formula
			precision
			prefix
			suffix
			type
			thousandsSeparator
		}
	}
`;
const submissionFragment$8 = gql `
	fragment FMathcalcSubmission on FormElementMathcalcSubmissionElementValueType {
		output
	}
`;

const configFragment$6 = gql `
	fragment FRatingConfig on FormElementRatingConfigType {
		interface {
			compareWith
			customItems {
				icon
				itemId
			}
			customRatingIcon
			feedbackLabel
			feedbackWhen
			ratingMax
			showFeedback
			type
		}
		validation {
			required
		}
		score {
			...FElemScoreConfig
		}
		attributes {
			...FElemAttributeConfig
		}
	}
`;
const submissionFragment$7 = gql `
	fragment FRatingSubmission on FormElementRatingSubmissionElementValueType {
		feedback
		selected
	}
`;

const configFragment$5 = gql `
	fragment FMatrixchoiceConfig on FormElementMatrixchoiceConfigType {
		validation {
			required
		}
		attributes {
			...FElemAttributeConfig
		}
		score {
			...FElemScoreConfig
		}
		interface {
			columns {
				itemId
				label
				num
				width
			}
			rows {
				itemId
				label
				num
				width
			}
			icon
			multiple
			rowHeadingWidth
			tableType
		}
	}
`;
const submissionFragment$6 = gql `
	fragment FMatrixchoiceSubmission on FormElementMatrixchoiceSubmissionElementValueType {
		selected {
			columns
			rowId
		}
	}
`;

const configFragment$4 = gql `
	fragment FSortableConfig on FormElementSortableConfigType {
		attributes {
			...FElemAttributeConfig
		}
		score {
			...FElemScoreConfig
		}
		interface {
			items {
				itemId
				label
			}
			lockVertically
			shuffle
		}
	}
`;
const submissionFragment$5 = gql `
	fragment FSortableSubmission on FormElementSortableSubmissionElementValueType {
		order
	}
`;

const configFragment$3 = gql `
	fragment FDatetimeinputConfig on FormElementDatetimeinputConfigType {
		validation {
			required
			maxValue
			minValue
		}
		attributes {
			...FElemAttributeConfig
		}
		score {
			...FElemScoreConfig
		}
		interface {
			dateTimeSeparator
			format
			icon
			showInputLabels
			timeType
			type
			hideSeconds
		}
	}
`;
const submissionFragment$4 = gql `
	fragment FDatetimeinputSubmission on FormElementDatetimeinputSubmissionElementValueType {
		input
	}
`;

const configFragment$2 = gql `
	fragment FMatrixinputConfig on FormElementMatrixinputConfigType {
		validation {
			required
		}
		attributes {
			...FElemAttributeConfig
		}
		score {
			...FElemScoreConfig
		}
		interface {
			columns {
				itemId
				label
				num
				width
			}
			rows {
				itemId
				label
				num
				width
			}
			icon
			multiline
			rowHeadingWidth
			tableType
		}
	}
`;
const submissionFragment$3 = gql `
	fragment FMatrixinputSubmission on FormElementMatrixinputSubmissionElementValueType {
		input {
			columnId
			rowId
			value
		}
	}
`;

const configFragment$1 = gql `
	fragment FSinglecheckboxConfig on FormElementSinglecheckboxConfigType {
		interface {
			icon
		}
		score {
			...FElemScoreConfig
		}
		attributes {
			...FElemAttributeConfig
		}
		validation {
			required
		}
	}
`;
const submissionFragment$2 = gql `
	fragment FSinglecheckboxSubmission on FormElementSinglecheckboxSubmissionElementValueType {
		selected
	}
`;

const configFragment = gql `
	fragment FAddressConfig on FormElementAddressConfigType {
		validation {
			required
		}
		attributes {
			...FElemAttributeConfig
		}
		interface {
			cityPlaceholder
			countryPlaceholder
			disableIcons
			fieldOne
			fieldOnePlaceholder
			fieldTwo
			fieldTwoPlaceholder
			restrictCountries
			showCity
			showCountry
			showState
			showZip
			statePlaceholder
			zipPlaceholder
		}
	}
`;
const submissionFragment$1 = gql `
	fragment FAddressSubmission on FormElementAddressSubmissionElementValueType {
		city
		country
		fieldOne
		fieldTwo
		state
		zip
	}
`;

const allConfigFragment = gql `
	fragment FAllElementConfig on FormElementConfigType {
		buttons {
			...FButtonsConfig
		}
		checkbox {
			...FCheckboxConfig
		}
		dropdown {
			...FDropdownConfig
		}
		heading {
			...FHeadingConfig
		}
		radio {
			...FRadioConfig
		}
		text {
			...FTextConfig
		}
		textarea {
			...FTextareaConfig
		}
		toggle {
			...FToggleConfig
		}
		slider {
			...FSliderConfig
		}
		range {
			...FRangeConfig
		}
		mathcalc {
			...FMathcalcConfig
		}
		rating {
			...FRatingConfig
		}
		matrixchoice {
			...FMatrixchoiceConfig
		}
		sortable {
			...FSortableConfig
		}
		datetimeinput {
			...FDatetimeinputConfig
		}
		matrixinput {
			...FMatrixinputConfig
		}
		singlecheckbox {
			...FSinglecheckboxConfig
		}
		address {
			...FAddressConfig
		}
	}
	${configFragment$h}
	${configFragment$g}
	${configFragment$f}
	${configFragment$e}
	${configFragment$d}
	${configFragment$c}
	${configFragment$b}
	${configFragment$a}
	${configFragment$9}
	${configFragment$8}
	${configFragment$7}
	${configFragment$6}
	${configFragment$5}
	${configFragment$4}
	${configFragment$3}
	${configFragment$2}
	${configFragment$1}
	${configFragment}
`;

// no fragment for config
const submissionFragment = gql `
	fragment FCaptchaSubmission on FormElementCaptchaSubmissionElementValueType {
		encrypted
		solved
	}
`;

const allSubmissionFragment = gql `
	fragment FAllElementSubmission on FormSubmissionElementValueType {
		captcha {
			...FCaptchaSubmission
		}
		radio {
			...FRadioSubmission
		}
		checkbox {
			...FCheckboxSubmission
		}
		dropdown {
			...FDropdownSubmission
		}
		text {
			...FTextSubmission
		}
		textarea {
			...FTextareaSubmission
		}
		toggle {
			...FToggleSubmission
		}
		slider {
			...FSliderSubmission
		}
		range {
			...FRangeSubmission
		}
		mathcalc {
			...FMathcalcSubmission
		}
		rating {
			...FRatingSubmission
		}
		matrixchoice {
			...FMatrixchoiceSubmission
		}
		sortable {
			...FSortableSubmission
		}
		datetimeinput {
			...FDatetimeinputSubmission
		}
		matrixinput {
			...FMatrixinputSubmission
		}
		singlecheckbox {
			...FSinglecheckboxSubmission
		}
		address {
			...FAddressSubmission
		}
	}
	# Submission Fragments
	${submissionFragment}
	${submissionFragment$e}
	${submissionFragment$g}
	${submissionFragment$f}
	${submissionFragment$d}
	${submissionFragment$c}
	${submissionFragment$b}
	${submissionFragment$a}
	${submissionFragment$9}
	${submissionFragment$8}
	${submissionFragment$7}
	${submissionFragment$6}
	${submissionFragment$5}
	${submissionFragment$4}
	${submissionFragment$3}
	${submissionFragment$2}
	${submissionFragment$1}
`;

const attributesFragment = gql `
	fragment FElemAttributeConfig on FormElementConfigAttributesType {
		defaultValue
		prefilParameter
		prefilType
		readonly
	}
`;

const interfaceOptionsFragment = gql `
	fragment FElemInterfaceOptionsConfig on FormElementConfigMcqOptionType {
		answerDescription
		id
		label
		num
	}
`;

const scoreFragment = gql `
	fragment FElemScoreConfig on FormElementConfigScoreType {
		scoreConditions {
			compareWith
			condition
			id
			operation
			scoreId
			scoreOperation
			scoreValue
		}
	}
`;

const validationFiltersFragment = gql `
	fragment FElemValidationFiltersConfig on FormElementConfigFiltersType {
		type
		minItems
		maxItems
		minString
		maxString
		minNum
		maxNum
	}
`;

const validationMasksFragment = gql `
	fragment FElemValidationMasks on FormElementConfigMasksType {
		alwaysShowMask
		maskPreset
		maskRegExps {
			caseSensitive
			id
			pattern
		}
		maskString
		maskType
		placeholder
	}
`;

const fragment = gql `
	fragment FStructure on FormStructureType {
		id
		config {
			title
			subtitle
			icon
			timer
			initiallyHidden
		}
		children
	}
`;

const formForSubmissionFragment = gql `
	fragment FFormForSubmission on FormType {
		limitations {
			id
			message
			dynamicAnchors
			mentions
		}
		notices {
			id
			message
			dynamicAnchors
			mentions
		}
		elements {
			appearance {
				...FElementAppearance
			}
			children
			id
			type
			config {
				...FAllElementConfig
			}
			extras
		}
		conditionals {
			...FConfigConditionals
		}
		id
		name
		pools {
			id
			name
			children
		}
		settings {
			timer {
				...FConfigSettingsTImer
			}
			score {
				...FConfigSettingsScore
			}
		}
		structures {
			...FStructure
		}
		styles {
			...FConfigStyles
		}
	}
	# Conditionals fragments
	${fragment$c}
	# Settings Fragments
	${fragment$b}
	${fragment$a}
	# Style Fragments
	${fragment$1}
	# Elements Fragments
	${appearanceFragment}
	${allConfigFragment}
	# Element generic fragments
	${attributesFragment}
	${interfaceOptionsFragment}
	${scoreFragment}
	${validationFiltersFragment}
	${validationMasksFragment}
	# Structure Fragments
	${fragment}
`;
// Things are in alphabetic order for consistency with GraphQL Explorer
// So when adding something new here, make sure to have follow the order!
const FORM_FOR_CREATE_SUBMISSION = gql `
	query FormForSubmission($id: ID!, $increaseViewCount: Boolean) {
		form(id: $id, increaseViewCount: $increaseViewCount) {
			...FFormForSubmission
		}
		# Query for available elements
		formMeta {
			elements {
				type
				defaultDataValue {
					...FAllElementSubmission
				}
			}
		}
	}
	# Form for submission fragment
	${formForSubmissionFragment}
	# Submission Fragments
	${allSubmissionFragment}
`;

const submissionDataFragment = gql `
	fragment FSubmissionData on SubmissionType {
		id
		token
		fName
		lName
		email
		phone
		score
		maxScore
		scoreData {
			scoreId
			has
			obtained
			outof
		}
		paymentData
		submissionLink
	}
`;
const NEW_SUBMISSION_MUTATION = gql `
	mutation CreateSubmission(
		$formId: ID!
		$urlTrack: String
		$referer: String
		$elements: [FormSubmissionElementInput!]!
		$time: Int
	) {
		createSubmission(
			data: {
				formId: $formId
				urlTrack: $urlTrack
				referer: $referer
				elements: $elements
				time: $time
			}
		) {
			...FSubmissionData
		}
	}
	${submissionDataFragment}
`;

styled.div `
	margin: ${props => numToCssSize(props.theme.gutter)}
		${props => numToCssSize(props.theme.gutter / -2)};
`;
function GenericApolloError(props) {
    const { children, themeStyle, error, retry, title, hideReload = false, retryLabel, widthOverride, ssr = false, type = '500', } = props;
    return (jsx(FallbackContainer, Object.assign({ themeStyle: themeStyle, widthOverride: widthOverride, ssr: ssr }, { children: jsx(Exception, { type: type, title: title, description: jsxs(Fragment, { children: [children, error ? (jsxs(Fragment, { children: [jsx("p", { children: __('More information on the error can be found below.', 'wp-eform') }, void 0), jsx("p", { children: error.message }, void 0)] }, void 0)) : null] }, void 0), footer: !hideReload || retry ? (jsxs(Fragment, { children: [!hideReload ? (jsx(Button, Object.assign({ style: "3d", size: GenericSizeEnum.SMALL, onClick: () => {
                            window.location.reload();
                        } }, { children: __('RELOAD PAGE', 'wp-eform') }), void 0)) : null, retry ? (jsx(Button, Object.assign({ style: "3d", size: GenericSizeEnum.SMALL, onClick: retry, colorful: false }, { children: retryLabel ?? __('RETRY WITHOUT RELOAD', 'wp-eform') }), void 0)) : null] }, void 0)) : null }, void 0) }), void 0));
}

function getBgRepeat(repeat) {
    if (repeat === FormSettingsBackgroundRepeatEnum.REPEAT_BOTH) {
        return 'repeat';
    }
    if (repeat === FormSettingsBackgroundRepeatEnum.REPEAT_NONE) {
        return 'no-repeat';
    }
    if (repeat === FormSettingsBackgroundRepeatEnum.REPEAT_X) {
        return 'repeat-x';
    }
    if (repeat === FormSettingsBackgroundRepeatEnum.REPEAT_Y) {
        return 'repeat-y';
    }
    return 'no-repeat';
}
function getBgBox(box) {
    if (box === FormSettingsBackgroundOriginAndClipEnum.BORDER_BOX) {
        return 'border-box';
    }
    if (box === FormSettingsBackgroundOriginAndClipEnum.CONTENT_BOX) {
        return 'content-box';
    }
    if (box === FormSettingsBackgroundOriginAndClipEnum.PADDING_BOX) {
        return 'padding-box';
    }
    return 'border-box';
}
function getBgAttachment(attachment) {
    if (attachment === FormSettingsBackgroundAttachmentEnum.FIXED) {
        return 'fixed';
    }
    if (attachment === FormSettingsBackgroundAttachmentEnum.LOCAL) {
        return 'local';
    }
    return 'scroll';
}
const PageBgContainer = styled.div `
	${cssReset};
	background-image: ${props => props.bg?.backgroundImage ? `url("${props.bg.backgroundImage}")` : 'none'};
	background-size: ${props => props.bg?.backgroundSize ?? 'auto'};
	background-position: ${props => props.bg?.backgroundPosition ?? '0% 0%'};
	background-repeat: ${props => getBgRepeat(props.bg?.backgroundRepeat)};
	background-origin: ${props => getBgBox(props.bg?.backgroundOrigin)};
	background-clip: ${props => getBgBox(props.bg?.backgroundClip)};
	background-attachment: ${props => getBgAttachment(props.bg?.backgroundAttachment)};
`;
function Page() {
    const formData = useSubmissionFormData();
    const currentPage = useSubmissionStore(submissionStoreCurrentPageSelector);
    const structure = formData.structures.find(st => st.id === currentPage);
    const lastTouchedElementId = useSubmissionStore(submissionStoreLastTouchedElementIdSelector);
    const formNavActions = useFormNavActions();
    const storeApi = useSubmissionStoreApi();
    let children;
    useEffect(() => {
        if (!lastTouchedElementId) {
            return () => { };
        }
        if (formData.styles?.pagination?.autoProgress) {
            let activeProcess = true;
            const timeoutId = setTimeout(() => {
                if (!activeProcess) {
                    return;
                }
                if (formNavActions.canNext) {
                    const submissionElements = storeApi.getState().elements;
                    const visibleChildren = getAllConditionallyShownChildrenOfCurrentPage(structure, formData.elements, submissionElements);
                    const [areChildrenErrorFree] = areElementsErrorFree(submissionElements, visibleChildren);
                    if (areChildrenErrorFree) {
                        formNavActions.goNext();
                    }
                }
                else if (formData.styles?.pagination?.autoSubmit &&
                    formNavActions.canSubmit) {
                    formNavActions.submit();
                }
            }, formData.styles.pagination.autoProgressDelay ?? 100);
            return () => {
                activeProcess = false;
                clearTimeout(timeoutId);
            };
        }
        return () => { };
    }, [lastTouchedElementId, formData, storeApi, formNavActions, structure]);
    if (!structure) {
        children = (jsx(IconMessage, Object.assign({ icon: jsx(Icon, { iconClass: "fas fa-envelope-open" }, void 0) }, { children: __('This page does not exist. Kindly navigate away from it.', 'wp-eform') }), void 0));
    }
    else {
        const elements = structure.children;
        children = (jsx(GridElements, { elements: elements, emptyMessage: __('This page is empty.', 'wp-eform') }, void 0));
    }
    return (jsx(PageBgContainer, Object.assign({ bg: formData.styles?.customBackground?.enabled
            ? formData.styles.customBackground
            : undefined, className: "wpeform-form-page" }, { children: children }), void 0));
}

const defaultParsedMessage = {
    message: __('Some error has occured.', 'wp-eform'),
    dynamicAnchors: null,
    mentions: null,
    id: 'unknown',
};
function SlateViewForLimitationMessage(props) {
    const { limitationMessage } = props;
    const excludeMentionsCharacters = useMemo(() => {
        return [];
    }, []);
    const parsedMentions = useSlateJsonMentions(limitationMessage.mentions);
    const parsedDynamicAnchorTags = useSlateJsonDynamicAnchors(limitationMessage.dynamicAnchors);
    const nodes = useNodesFromJson(limitationMessage.message);
    return (jsx(SlateView, { mode: "multiline", nodes: nodes
            ? nodes
            : getDefaultSlateNodeWithChildren(sprintf(__('There has been some error related to %s.', 'wp-eform'), limitationMessage.id ?? 'unknown')), excludeMentionsCharacters: excludeMentionsCharacters, additionalMentions: parsedMentions, additionalDynamicAnchorTags: parsedDynamicAnchorTags }, void 0));
}

function useFormElementTitleMentions() {
    const formData = useSubmissionFormData();
    const elements = formData.elements;
    return useCallback((elementId) => {
        if (elements[elementId]) {
            return (jsx("strong", { children: jsx(SlateViewWithData, { currentElementId: null, nodes: getNodesFromJSON(elements[elementId].appearance?.title), mode: "singleline" }, void 0) }, void 0));
        }
        return null;
    }, [elements]);
}
function SlateViewForError(props) {
    const { messageJson } = props;
    const parsedMessage = useMemo(() => {
        try {
            const pm = JSON.parse(messageJson ?? '');
            if (typeof pm === 'object' &&
                typeof pm.dynamicAnchors !== 'undefined' &&
                typeof pm.mentions !== 'undefined' &&
                typeof pm.message !== 'undefined') {
                return pm;
            }
            return defaultParsedMessage;
        }
        catch (e) {
            return defaultParsedMessage;
        }
    }, [messageJson]);
    const mentionsProvider = useFormElementTitleMentions();
    return (jsx(MentionsProvider, Object.assign({ mentions: mentionsProvider }, { children: jsx(SlateViewForLimitationMessage, { limitationMessage: parsedMessage }, void 0) }), void 0));
}

/**
 * Expose `isUrl`.
 */

var isUrl_1 = isUrl;

/**
 * RegExps.
 * A URL must match #1 and then at least one of #2/#3.
 * Use two levels of REs to avoid REDOS.
 */

var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;

var localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/;
var nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;

/**
 * Loosely validate a URL `string`.
 *
 * @param {String} string
 * @return {Boolean}
 */

function isUrl(string){
  if (typeof string !== 'string') {
    return false;
  }

  var match = string.match(protocolAndDomainRE);
  if (!match) {
    return false;
  }

  var everythingAfterProtocol = match[1];
  if (!everythingAfterProtocol) {
    return false;
  }

  if (localhostDomainRE.test(everythingAfterProtocol) ||
      nonLocalhostDomainRE.test(everythingAfterProtocol)) {
    return true;
  }

  return false;
}

var isUrl$1 = isUrl_1;

function getScoreBasedRedirectionUrl(config, scoreData, type) {
    if (!scoreData) {
        return '';
    }
    const scoreDataRecord = scoreData.reduce((acc, cur) => {
        acc[cur.scoreId] = cur;
        return acc;
    }, {});
    const scoresList = type === 'percentage'
        ? config.scorePercentageLogic
        : config.scoreTotalLogic;
    let redirectionUrl = '';
    scoresList.forEach(sc => {
        // bail early if scoreId is not present or scoreDataRecord has no reference to it
        if (!sc.scoreId ||
            !scoreDataRecord[sc.scoreId] ||
            !scoreDataRecord[sc.scoreId].has) {
            return;
        }
        // now check if the condition satisfies
        const currentScoreData = scoreDataRecord[sc.scoreId];
        const compareValue = type === 'percentage'
            ? (currentScoreData.obtained / currentScoreData.outof) * 100
            : currentScoreData.obtained;
        if (compareValue <= sc.to && compareValue >= sc.from) {
            redirectionUrl = sc.url;
        }
    });
    return redirectionUrl;
}
function getConditionBasedRedirectionUrl(conditions, elements, elementsData) {
    let redirectionUrl = '';
    conditions.forEach(cond => {
        if (areLogicEventsCheckedOut(cond.events, elements, elementsData)) {
            redirectionUrl = cond.url;
        }
    });
    return redirectionUrl;
}
function Redirect(props) {
    const { config, submissionLink, scoreData } = props;
    let redirectUrl = config.url;
    const elements = useSubmissionStore(submissionStoreElementsSelector);
    const formData = useSubmissionFormData();
    if (config.type === RedirectTypeEnum.FLAT) {
        redirectUrl = config.url;
    }
    else if (config.type === RedirectTypeEnum.PORTAL) {
        redirectUrl = WPEFormGraphQLApp.userPortal;
    }
    else if (config.type === RedirectTypeEnum.SUBMISSION) {
        redirectUrl = submissionLink ?? config.url;
    }
    else if (config.type === RedirectTypeEnum.CONDITIONAL) {
        redirectUrl = getConditionBasedRedirectionUrl(config.conditionalLogic, elements, formData.elements);
    }
    else if (config.type === RedirectTypeEnum.SCOREPERCENTAGE) {
        redirectUrl = getScoreBasedRedirectionUrl(config, scoreData, 'percentage');
    }
    else if (config.type === RedirectTypeEnum.SCORETOTAL) {
        redirectUrl = getScoreBasedRedirectionUrl(config, scoreData, 'total');
    }
    // fallback to base URL, if the redirectUrl is empty
    // this is intentional from score and condition based functions
    if (redirectUrl === '') {
        redirectUrl = config.url;
    }
    // Now check if the ultimate URL is valid
    const isUrlValid = isUrl$1(redirectUrl);
    const redirectTo = useCallback(() => {
        if (config.iframeRedirect && window.top !== window.self) {
            window.top.location.href = redirectUrl;
        }
        else {
            window.location.href = redirectUrl;
        }
    }, [config.iframeRedirect, redirectUrl]);
    useScheduledInvoke(redirectTo, config.delay, !isUrlValid);
    const additionalAnchors = useMemo(() => ({ '%REDIRECT_LINK%': redirectUrl }), [redirectUrl]);
    return isUrlValid ? (jsx(SlateViewWithData, { mode: "multiline", nodes: getNodesFromJSON(config.message), currentElementId: null, additionalMentions: {
            '::redirectDelay::': jsx(InlineCountDown, { time: config.delay }, void 0),
        }, additionalAnchors: additionalAnchors }, void 0)) : (jsx("p", { children: sprintf(__('ERROR: The URL %s is invalid and cannot redirect. Please contact the site administrator for help.', 'wp-eform'), redirectUrl) }, void 0));
}

function ResetForm(props) {
    const { reset, delay, message } = props;
    // actually reset the form
    useScheduledInvoke(reset, delay);
    return (jsx(SlateViewWithData, { mode: "singleline", nodes: getNodesFromJSON(message), currentElementId: null, additionalMentions: {
            '::kioskResetTime::': jsx(InlineCountDown, { time: delay }, void 0),
        } }, void 0));
}

function FormTimer(props) {
    const { timerConfig, currentPageConfig, goNext, canSubmit, submit, submitting, width, containerLayout, } = props;
    const message = useNodesFromJson(timerConfig?.timerMessage);
    const onDone = useCallback(() => {
        {
            // FS:PREMIUM-ONLY-START
            if (fsIsPlanOrHigher('starter')) {
                // don't do anything if already submitting
                if (submitting) {
                    return;
                }
                // if this is an overall timer, then just submit
                if (timerConfig?.submitTimer === SubmitTimerEnum.OVERALL) {
                    submit(true);
                    return;
                }
                // it is not, so it is page specific, hence if we are on the last page,
                // then submit, else proceed to the next page
                if (canSubmit) {
                    submit(true);
                }
                else {
                    goNext(true);
                }
            }
            // FS:PREMIUM-ONLY-END
        }
    }, [canSubmit, goNext, submit, timerConfig, submitting]);
    // if timerConfig or currentPageConfig is empty, then bail
    if (!timerConfig || !currentPageConfig) {
        return null;
    }
    // now figure out the timer, depending on the config
    if (timerConfig.submitTimer === SubmitTimerEnum.NONE) {
        return null;
    }
    let time;
    let key;
    if (timerConfig.submitTimer === SubmitTimerEnum.OVERALL) {
        time = timerConfig.timeLimit;
        key = 'overall';
    }
    else {
        time = currentPageConfig.config.timer;
        key = currentPageConfig.id;
    }
    // if time is 0 or not defined, then we don't need a timer
    if (!time || time < 0) {
        return null;
    }
    // determine whether to show UI
    const showUI = timerConfig.showTimer && !submitting && fsIsPlanOrHigher('starter');
    return (jsxs(Fragment, { children: [showUI ? jsx(Timer.Placeholder, {}, void 0) : null, jsx(ResponsiveContainer.Portal, { children: jsx(Timer.Portal, { children: jsx(Timer, { showUI: showUI, time: time, message: message ? (jsx(SlateViewWithData, { nodes: message, currentElementId: null, mode: "singleline" }, void 0)) : undefined, onDone: onDone, width: width, containerLayout: containerLayout }, key) }, void 0) }, void 0)] }, void 0));
}

const Container = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter)};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	background-color: ${props => props.theme.backgroundShade};
	margin: 0 0 ${props => numToCssSize(props.theme.gutter)} 0;
`;
function Remarks() {
    const submissionId = useQuestionId();
    const remarks = useSubmissionStore(submissionStoreRemarksSelector);
    const dispatch = useSubmissionDispatch();
    const updateRemarks = useCallback((newVal) => {
        dispatch({
            type: 'SET_REMARKS',
            payload: {
                remarks: newVal,
            },
        });
    }, [dispatch]);
    return (jsx(Container, { children: jsx(Question, Object.assign({ title: __('Administrator Remarks', 'wp-eform'), subtitle: __('this will show up in submission summary.', 'wp-eform'), id: `${submissionId}-remarks` }, { children: jsx(Textarea, { value: remarks, onChange: updateRemarks }, void 0) }), void 0) }, void 0));
}

function Form$1(props) {
    const { activePage, onActivePageChange, onSubmit, submitting, submitted, submittedState, submissionError, onReset, onErrorRetry, limitations, mutationData, notices, initialData, } = props;
    const dispatch = useSubmissionDispatch();
    const storeApi = useSubmissionStoreApi();
    const formMeta = useSubmissionFormMeta();
    const formData = useSubmissionFormData();
    const currentPage = useSubmissionStore(submissionStoreCurrentPageSelector);
    const submissionStructures = useSubmissionStore(submissionStoreStructuresSelector);
    const startTime = useSubmissionStore(submissionStoreStartTimeSelector);
    const [forceShowErrors, setForceShowErrors] = useState(false);
    const [activeErrorElement, setActiveErrorElement] = useState(null);
    const mode = useSubmissionFormRenderMode();
    const conditionalsMap = useFormElementConditionalMap();
    // Sync current elements with that of our submission store
    // this is useful if at sometime (like in live preview mode) the elements
    // from the submissionFormData changes.
    useEffect(() => {
        // reset active error elements and force show too
        setActiveErrorElement(null);
        setForceShowErrors(false);
        dispatch({
            type: 'SET_ELEMENTS_AND_STARTTIME',
            payload: {
                structures: getActiveStructuresAfterReset(formData),
                elements: getActiveElementsAfterReset(formData, formMeta, true, initialData),
                formData,
                formMeta,
                conditionalsMap,
                fullReset: mode === 'preview' || mode === 'listview',
            },
        });
    }, [dispatch, formMeta, formData, conditionalsMap, initialData, mode]);
    // calculate tabs based on structure
    const tabs = useMemo(() => {
        return formData.structures
            .filter(st => {
            // take into consideration conditionally hidden tabs
            // if we are in preview mode, then always return true, i.e, show the tab
            if (mode === 'preview') {
                return true;
            }
            const submissionStructure = submissionStructures[st.id];
            if (!submissionStructure) {
                return true;
            }
            return !submissionStructure.conditionallyHidden;
        })
            .map(st => ({
            id: st.id,
            title: st.config.title,
            subtitle: st.config.subtitle,
            icon: st.config.icon || undefined,
        }));
    }, [formData.structures, mode, submissionStructures]);
    // Make sure the currentPage is valid
    useEffect(() => {
        const currentTab = tabs.find(t => t.id === currentPage);
        if (!currentTab && tabs.length) {
            dispatch({
                type: 'SET_CURRENT_PAGE',
                payload: tabs[0].id,
            });
        }
    }, [tabs, currentPage, dispatch]);
    // before tab navigation, figure out if timer is active from the settings
    const isTimerActive = (mode === 'newsubmission' || mode === 'useredit') &&
        formData.settings?.timer?.submitTimer !== SubmitTimerEnum.NONE;
    // we also need current page config for passing to FormTimer component
    const currentPageConfig = useMemo(() => formData.structures.find(st => st.id === currentPage), [currentPage, formData.structures]);
    // tab navigation
    // first get the current page index
    const currentPageIndex = tabs.findIndex(t => t.id === currentPage);
    // also the next page Id and previous Id for references
    const previousPageId = currentPageIndex === 0
        ? null
        : tabs[currentPageIndex - 1]
            ? tabs[currentPageIndex - 1].id
            : null;
    const nextPageId = tabs[currentPageIndex + 1]
        ? tabs[currentPageIndex + 1].id
        : currentPage;
    const changeTab = useCallback((newPage, timerChange = false) => {
        const moveToNextPage = () => {
            dispatch({ type: 'SET_CURRENT_PAGE', payload: newPage });
            if (onActivePageChange) {
                onActivePageChange(newPage);
            }
        };
        // if there is no restriction in tab navigation, then do it freely
        // or if we are in form preview mode
        if (mode === 'preview' ||
            formData.styles?.pagination?.paginationRestriction ===
                FormPaginationRestrictionEnum.NONE) {
            moveToNextPage();
            return;
        }
        // If timer is active, and trying to go to next tab, then allow without
        // checking for errors
        if (isTimerActive && newPage === nextPageId && timerChange) {
            moveToNextPage();
            setForceShowErrors(false);
            setActiveErrorElement(null);
            return;
        }
        // for reference, get the currently visible children
        const submissionElements = storeApi.getState().elements;
        const visibleChildren = getAllConditionallyShownChildrenOfCurrentPage(currentPageConfig, formData.elements, submissionElements);
        const [areChildrenErrorFree, firstErrorElement] = areElementsErrorFree(submissionElements, visibleChildren);
        // now get the next page index
        const nextPageIndex = tabs.findIndex(t => t.id === newPage);
        // if we are navigating back
        if (nextPageIndex < currentPageIndex) {
            // if timer is active, then can never go back
            if (isTimerActive) {
                return;
            }
            // if we are blocking previous page
            if (formData.styles?.pagination?.blockPreviousNavigation) {
                return;
            }
            // now check with pagination restriction
            if (formData.styles?.pagination?.paginationRestriction ===
                FormPaginationRestrictionEnum.ONLY_WHEN_ALL_VALID) {
                // if children are not error free, then show them all
                if (!areChildrenErrorFree) {
                    setForceShowErrors(true);
                    setActiveErrorElement(firstErrorElement);
                    return;
                }
            }
            // otherwise, system says, we can freely navigate to previous pages
            setForceShowErrors(false);
            setActiveErrorElement(null);
            dispatch({ type: 'SET_CURRENT_PAGE', payload: newPage });
            if (onActivePageChange) {
                onActivePageChange(newPage);
            }
            // that's it
            return;
        }
        // we are here so we are going to the next page
        // if all the children in current page are error free, then move away
        if (areChildrenErrorFree) {
            setForceShowErrors(false);
            setActiveErrorElement(null);
            // if we are navigating forward
            // we cannot navigate more than one page, so set the nextPage properly
            dispatch({ type: 'SET_CURRENT_PAGE', payload: nextPageId });
            if (onActivePageChange) {
                onActivePageChange(nextPageId);
            }
            return;
        }
        // otherwise, show all errors on the current page and scroll to the first
        setForceShowErrors(true);
        setActiveErrorElement(firstErrorElement);
    }, [
        onActivePageChange,
        mode,
        currentPageConfig,
        currentPageIndex,
        dispatch,
        formData,
        storeApi,
        tabs,
        nextPageId,
        isTimerActive,
    ]);
    // keep the activePage from parent in sync if provided
    useEffect(() => {
        if (activePage && activePage !== currentPage) {
            dispatch({ type: 'SET_CURRENT_PAGE', payload: activePage });
        }
    }, [dispatch, activePage, currentPage]);
    const canPrevious = !isTimerActive &&
        !!previousPageId &&
        !formData.styles?.pagination?.blockPreviousNavigation &&
        !submitting;
    const goPrevious = useCallback(() => {
        if (previousPageId) {
            changeTab(previousPageId);
        }
    }, [previousPageId, changeTab]);
    const canNext = nextPageId !== currentPage && !submitting;
    const goNext = useCallback((timerChange = false) => {
        changeTab(nextPageId, timerChange);
    }, [changeTab, nextPageId]);
    const canSubmit = nextPageId === currentPage && !submitting;
    const submit = useCallback((timerSubmit = false) => {
        // just submit if doing from timer
        if (isTimerActive && timerSubmit) {
            onSubmit(storeApi);
            return;
        }
        // for reference, get the currently visible children
        const submissionElements = storeApi.getState().elements;
        const visibleChildren = getAllConditionallyShownChildrenOfCurrentPage(currentPageConfig, formData.elements, submissionElements);
        const [areChildrenErrorFree, firstErrorElement] = areElementsErrorFree(submissionElements, visibleChildren);
        if (!areChildrenErrorFree) {
            setForceShowErrors(true);
            setActiveErrorElement(firstErrorElement);
            return;
        }
        // call from the parent, parent will handle submitting the form through
        // it's state.
        onSubmit(storeApi);
    }, [currentPageConfig, formData, storeApi, onSubmit, isTimerActive]);
    const canReset = (!submitting || (submitting && submitted)) && !isTimerActive;
    const reset = useCallback(() => {
        // reset elements
        dispatch({
            type: 'SET_ELEMENTS_AND_STARTTIME',
            payload: {
                structures: getActiveStructuresAfterReset(formData),
                elements: getActiveElementsAfterReset(formData, formMeta, true),
                formData,
                formMeta,
                conditionalsMap,
                fullReset: true,
            },
        });
        // reset active error elements and force show too
        setActiveErrorElement(null);
        setForceShowErrors(false);
        // reset current page
        const newPageId = tabs[0].id;
        dispatch({ type: 'SET_CURRENT_PAGE', payload: newPageId });
        if (onActivePageChange) {
            onActivePageChange(newPageId);
        }
        // call the one from the parent
        if (onReset) {
            onReset();
        }
    }, [
        dispatch,
        formData,
        formMeta,
        onActivePageChange,
        tabs,
        onReset,
        conditionalsMap,
    ]);
    const consensualReset = useCallback(() => {
        // eslint-disable-next-line no-alert
        const conscent = window.confirm(formData.styles?.pagination?.resetMessage ||
            __('This will reset the form. Action cannot be undone, are you sure?', 'wp-eform'));
        if (conscent) {
            reset();
        }
    }, [reset, formData]);
    const formNavActions = useMemo(() => ({
        canNext,
        canPrevious,
        canSubmit,
        goNext,
        goPrevious,
        submit,
        canReset,
        reset: consensualReset,
        submitting,
        submitted,
        submittedState,
    }), [
        canNext,
        canPrevious,
        canSubmit,
        goNext,
        goPrevious,
        submit,
        canReset,
        consensualReset,
        submitting,
        submitted,
        submittedState,
    ]);
    const buttonStyle = formData.styles?.pagination?.barlike
        ? 'flat'
        : formData.styles?.pagination?.style ?? 'flat';
    const buttonSize = formData.styles?.pagination?.size ?? GenericSizeEnum.DEFAULT;
    const colorful = formData.styles?.pagination?.colored ?? false;
    const rounded = formData.styles?.pagination?.rounded;
    let previousButton = (jsx(Button, Object.assign({ style: buttonStyle, size: buttonSize, colorful: colorful, icon: formData.styles?.pagination?.prevIcon, iconPosition: formData.styles?.pagination?.prevIconPosition ===
            ButtonIconPositionEnum.BEFORE
            ? 'before'
            : 'after', onClick: goPrevious, rounded: rounded, disabled: !canPrevious }, { children: formData.styles?.pagination?.prevLabel }), void 0));
    const submitMode = mode === 'newsubmission' || mode === 'preview' || mode === 'listview'
        ? 'new'
        : 'update';
    const submitIconPosition = submitMode === 'new'
        ? formData.styles?.pagination?.submitIconPosition
        : formData.styles?.pagination?.updateIconPosition;
    let submitButton = (jsx(Button, Object.assign({ style: buttonStyle, size: buttonSize, colorful: colorful, icon: submitMode === 'new'
            ? formData.styles?.pagination?.submitIcon
            : formData.styles?.pagination?.updateIcon, iconPosition: submitIconPosition === ButtonIconPositionEnum.BEFORE
            ? 'before'
            : 'after', onClick: () => {
            submit();
        }, rounded: rounded, disabled: !canSubmit, loading: submitting, loadingDone: submitted, loadedState: submittedState === 'success' ? 'success' : 'error' }, { children: submitMode === 'new'
            ? formData.styles?.pagination?.submitLabel
            : formData.styles?.pagination?.updateLabel }), void 0));
    let nextButton = (jsx(Button, Object.assign({ style: buttonStyle, size: buttonSize, colorful: colorful, icon: formData.styles?.pagination?.nextIcon, iconPosition: formData.styles?.pagination?.nextIconPosition ===
            ButtonIconPositionEnum.BEFORE
            ? 'before'
            : 'after', onClick: () => {
            goNext();
        }, rounded: rounded, disabled: !canNext }, { children: formData.styles?.pagination?.nextLabel }), void 0));
    let resetButton = formData.styles?.pagination
        ?.showResetButton ? (jsx(Button, Object.assign({ style: buttonStyle, size: buttonSize, colorful: colorful, icon: formData.styles?.pagination?.resetIcon, iconPosition: formData.styles?.pagination?.resetIconPosition ===
            ButtonIconPositionEnum.BEFORE
            ? 'before'
            : 'after', onClick: consensualReset, rounded: rounded, disabled: !canReset }, { children: formData.styles?.pagination?.resetLabel }), void 0)) : null;
    // hide the buttons if config says so
    if (formData.styles?.pagination?.hideWhenNotRelevant) {
        if (!canPrevious) {
            previousButton = null;
        }
        if (canNext) {
            // We don't check against canSubmit explicitly because it should
            // always be shown on last page, even if submitting, for the feedback
            submitButton = null;
        }
        else {
            nextButton = null;
        }
        if (!canReset) {
            resetButton = null;
        }
    }
    // if form has only one page, then always hide the next and previous buttons
    if (formData.structures.length === 1) {
        nextButton = null;
        previousButton = null;
    }
    // calculate the reset/redirect in actionfeedback
    let footer = null;
    if (submitting &&
        submitted &&
        submittedState === 'success' &&
        // reset and redirection would work only on newsubmission mode
        mode === 'newsubmission') {
        // if there is a redirection then we process it beforehand
        // a redirection would supress reset
        if (formData.styles?.redirection?.type !== RedirectTypeEnum.NONE) {
            footer = (jsx(Redirect, { config: formData.styles.redirection, submissionLink: mutationData?.submissionLink, scoreData: mutationData?.scoreData }, void 0));
        }
        else if (formData.styles?.formBehavior?.kioskMode === true) {
            footer = (jsx(ResetForm, { reset: reset, delay: formData.styles.formBehavior.kioskTime, message: formData.styles.formBehavior.kioskMessage }, void 0));
        }
    }
    return (jsx(Fragment, { children: submitting && submitted ? (jsx(ActionFeedback, Object.assign({ type: submittedState === 'success' ? 'success' : 'error', title: submittedState === 'success' ? (jsx(SlateViewWithData, { mode: "singleline", nodes: getNodesFromJSON(mode === 'useredit'
                    ? formData.styles?.formBehavior?.updateSubject
                    : mode === 'adminedit'
                        ? __('The submission has been updated.', 'wp-eform')
                        : formData.styles?.formBehavior?.subject), currentElementId: null }, void 0)) : (jsx(SlateViewWithData, { mode: "singleline", nodes: getNodesFromJSON(formData.styles?.formBehavior?.errorSubject ??
                    __('Oops, we have encountered an error!', 'wp-eform')), currentElementId: null }, void 0)), footer: footer }, { children: submittedState === 'success' ? (jsx(SlateViewWithData, { currentElementId: null, mode: "multiline", nodes: getNodesFromJSON(mode === 'useredit'
                    ? formData.styles?.formBehavior?.updateMessage
                    : mode === 'adminedit'
                        ? __('We have also sent an email to the user about this update.', 'wp-eform')
                        : formData.styles?.formBehavior?.message) }, void 0)) : (jsxs(Fragment, { children: [submissionError?.graphQLErrors[0]?.extensions?.category ===
                        'submissionValidationLogic' ? (jsx(SlateViewForError, { messageJson: submissionError?.graphQLErrors[0]?.message ?? '' }, void 0)) : (submissionError?.message), onErrorRetry ? (jsx("p", { children: jsx(Button, Object.assign({ size: buttonSize, style: buttonStyle, colorful: colorful, icon: formData.styles?.formBehavior?.errorRetryButtonIcon ??
                                'fas fa-sync-alt', iconPosition: formData.styles?.formBehavior
                                ?.errorRetryButtonIconPosition ===
                                ButtonIconPositionEnum.AFTER
                                ? 'after'
                                : 'before', onClick: onErrorRetry, rounded: rounded }, { children: formData.styles?.formBehavior?.errorRetryButtonLabel ??
                                __('RETRY', 'wp-eform') }), void 0) }, void 0)) : null] }, void 0)) }), void 0)) : (jsx(submissionForceShowErrorsContext.Provider, Object.assign({ value: forceShowErrors }, { children: jsx(activeErrorElementContext.Provider, Object.assign({ value: activeErrorElement }, { children: jsx(formNavActionsContext.Provider, Object.assign({ value: formNavActions }, { children: limitations &&
                        limitations.length > 0 &&
                        mode === 'newsubmission' ? (limitations.map(limitation => (jsx(Grid.Bottom, { children: jsx(Alert, Object.assign({ type: "error", icon: "fas fa-times", dismissable: false }, { children: jsx(SlateViewForLimitationMessage, { limitationMessage: limitation }, void 0) }), void 0) }, limitation.id)))) : (jsxs(Fragment, { children: [mode === 'adminedit' ? jsx(Remarks, {}, void 0) : null, notices && notices.length && mode === 'newsubmission'
                                ? notices.map(notice => (jsx(Grid.Bottom, { children: jsx(Alert, Object.assign({ type: "regular", icon: "fas fa-exclamation", dismissable: true }, { children: jsx(SlateViewForLimitationMessage, { limitationMessage: notice }, void 0) }), void 0) }, notice.id)))
                                : null, jsxs("form", Object.assign({ method: "post", action: "", autoComplete: formData.styles?.formBehavior?.disabledAutoComplete
                                    ? 'off'
                                    : 'on', onSubmit: e => {
                                    e.preventDefault();
                                    // do nothing, we would only accept submit by clicking
                                    // the submit button.
                                } }, { children: [jsx(Tabs, Object.assign({ showTabs: formData.styles?.pagination?.showTabs, currentTab: currentPage, onTabChange: changeTab, showProgressBar: formData.styles?.pagination?.showProgressBar, showProgressLabel: formData.styles?.pagination?.showProgressLabel, forceProgress: submitting ? 100 : undefined, progressBarPosition: formData.styles?.pagination?.progressBarPosition, progressBarPrecision: formData.styles?.pagination?.progressDecimalPoint, scrollOnTabChange: formData.styles?.pagination?.autoScroll, tabScrollOffset: formData.styles?.pagination?.scrollOffset !== undefined
                                            ? formData.styles.pagination.scrollOffset * -1
                                            : -100, tabs: tabs, stopwatchStartTime: formData.settings?.timer?.recordSubmissionTime &&
                                            formData.settings.timer.showStopwatch
                                            ? startTime
                                            : undefined, footer: formData.styles?.pagination?.panelEnabled ? (jsxs(ButtonsGroup, Object.assign({ align: formData.styles?.pagination?.alignment ??
                                                GenericAlignmentEnum.RIGHT, type: formData.styles?.pagination?.barlike
                                                ? 'navbar'
                                                : 'regular', colorful: colorful, hasGutterOnregular: true }, { children: [previousButton, submitButton, nextButton, resetButton] }), void 0)) : null }, { children: jsx(Page, {}, void 0) }), void 0), mode === 'newsubmission' || mode === 'useredit' ? (jsx(FormTimer, { timerConfig: formData.settings?.timer, currentPageConfig: currentPageConfig, goNext: goNext, submit: submit, canSubmit: canSubmit, width: formData.styles?.appearance?.maxWidth, containerLayout: formData.styles?.appearance?.containerLayout, submitting: submitting }, void 0)) : null] }), void 0)] }, void 0)) }), void 0) }), void 0) }), void 0)) }, void 0));
}

function useFormSubmissionDataMentions(mutationData) {
    const elementsSubmissionData = useSubmissionStore(submissionStoreElementsSelector);
    const formData = useSubmissionFormData();
    const elementsConfig = formData.elements;
    const scoreData = formData.settings?.score;
    const primitives = useMemo(() => {
        if (mutationData) {
            return {
                '::fName::': mutationData.fName,
                '::lName::': mutationData.lName,
                '::email::': mutationData.email,
                '::phone::': mutationData.phone,
                '::submissionId::': mutationData.token,
                '::formName::': formData.name ?? '',
            };
        }
        return null;
    }, [mutationData, formData.name]);
    return useCallback((elementId) => {
        return getSlateMentionsOnElementsAndScore(elementId, elementsSubmissionData, elementsConfig, primitives, scoreData, mutationData?.scoreData);
    }, [
        elementsSubmissionData,
        elementsConfig,
        mutationData,
        scoreData,
        primitives,
    ]);
}
function SlateDataProvider(props) {
    const { children, mutationData } = props;
    const mentions = useFormSubmissionDataMentions(mutationData);
    const dynamicAnchors = useMemo(() => {
        const anchors = {};
        anchors['%FORM_LINK%'] = window.location.href;
        if (mutationData?.submissionLink) {
            anchors['%SUBMISSION_LINK%'] = mutationData.submissionLink;
        }
        // TODO: Add %REDIRECT_LINK% from logic
        return anchors;
    }, [mutationData]);
    return (jsx(MentionsProvider, Object.assign({ mentions: mentions }, { children: jsx(DynamicAnchorProvider, Object.assign({ dynamicAnchors: dynamicAnchors }, { children: children }), void 0) }), void 0));
}

function FormSubmission(props) {
    const { formData, formMeta, mode, initialData, activePage, onActivePageChange, mutationData, formHeader = null, ...formProps } = props;
    const styles = formData.styles;
    const themeStyle = useThemeStyleFromFormStyle(styles);
    const elementConditionalMap = useMemo(() => {
        const elmCondMap = {};
        formData.conditionals.forEach(cd => {
            cd.events.forEach(cdEvent => {
                if (!elmCondMap[cdEvent.fieldid]) {
                    elmCondMap[cdEvent.fieldid] = [];
                }
                // dedup insert
                if (!elmCondMap[cdEvent.fieldid].includes(cd.id)) {
                    elmCondMap[cdEvent.fieldid].push(cd.id);
                }
            });
        });
        return elmCondMap;
    }, [formData]);
    return (jsx(SubmissionStore, Object.assign({ initialData: initialData ?? {
            ...defaultInitialSubmissionData,
            currentPage: activePage ??
                (formData.structures && formData.structures.length
                    ? formData.structures[0].id
                    : ''),
            startTime: Date.now(),
        } }, { children: jsx(submissionFormDataContext.Provider, Object.assign({ value: formData }, { children: jsx(submissionFormMetaContext.Provider, Object.assign({ value: formMeta }, { children: jsx(submissionFormRenderModeContext.Provider, Object.assign({ value: mode }, { children: jsx(formElementConditionalMapContext.Provider, Object.assign({ value: elementConditionalMap }, { children: jsx(SlateDataProvider, Object.assign({ mutationData: mutationData }, { children: jsxs(ThemedContainer, Object.assign({ themeStyle: themeStyle, mode: mode !== 'preview' ? 'live' : 'preview' }, { children: [formHeader, jsx(Form$1, Object.assign({ activePage: activePage, onActivePageChange: onActivePageChange }, formProps, { mutationData: mutationData, initialData: initialData }), void 0)] }), void 0) }), void 0) }), void 0) }), void 0) }), void 0) }), void 0) }), void 0));
}

function NetworkForm(props) {
    const { id, panels = 2, controls = 3, themeStyle, mode = 'newsubmission', inShadow = false, cssHandles = [], ssr = false, increaseViewCount = false, } = props;
    // remove the from_admin from URL
    useEffect(() => {
        const currentUrl = getCurrentUrl();
        if (currentUrl.includes('from_admin=true')) {
            const newUrl = currentUrl
                .replace('?from_admin=true', '')
                .replace('from_admin=true', '');
            window.history.replaceState(null, document.title, newUrl);
        }
    }, []);
    const { data, loading, error, refetch } = useQuery(FORM_FOR_CREATE_SUBMISSION, {
        fetchPolicy: 'cache-first',
        variables: {
            id,
            increaseViewCount,
        },
    });
    // We need a mechanism to refresh the form on a particular window message
    // event. This can come from a preview window when the original form has
    // been changed.
    const debouncedUpdate = useDebouncedCallback((formId, formRefetch) => {
        formRefetch({ id: formId });
    }, 500);
    // Reload form data on window message
    useEffect(() => {
        const handler = (event) => {
            if (event.data && event.data === 'wpeform:: refresh form') {
                logger.l('refreshing form');
                debouncedUpdate(id, refetch);
            }
        };
        window.addEventListener('message', handler);
        return () => {
            window.removeEventListener('message', handler);
        };
    }, [id, debouncedUpdate, refetch]);
    const [submitForm, mutationResult] = useMutation(NEW_SUBMISSION_MUTATION, {
        fetchPolicy: 'no-cache',
    });
    // calculate the urlTrack if needed
    const urlTrack = useMemo(() => {
        let val = null;
        {
            // FS:PREMIUM-ONLY-START
            if (fsIsPlanOrHigher('starter')) {
                try {
                    if (data?.form.styles?.tracking?.urlTracking) {
                        const urlKey = data.form.styles.tracking.urlTrackId;
                        const getParams = qs.parse(window.location.search);
                        if (getParams[urlKey]) {
                            const possibleValue = getParams[urlKey];
                            if (typeof possibleValue === 'string') {
                                val = possibleValue;
                            }
                        }
                    }
                    return val;
                }
                catch {
                    return null;
                }
            }
            // FS:PREMIUM-ONLY-END
        }
        return null;
    }, [data]);
    // submit callback
    const callback = useCallback((elements, time) => {
        return submitForm({
            variables: {
                formId: id,
                elements,
                referer: window.location.href,
                time,
                urlTrack,
            },
        });
    }, [id, submitForm, urlTrack]);
    const formData = useMemo(() => {
        if (data) {
            return convertFormData(data);
        }
        return null;
    }, [data]);
    const { submitting, submitted, reset, submit, submittedState } = useFormSubmissionSubmit(callback, formData, mode !== 'preview' && mode !== 'listview');
    const loadingUi = (jsx(Shadow, Object.assign({ inShadow: inShadow, cssHandles: cssHandles }, { children: jsx(FallbackContainer, Object.assign({ themeStyle: themeStyle, ssr: ssr }, { children: mode === 'listview' || mode === 'preview' ? (jsx(Spinner, {}, void 0)) : (jsx(FormSkeleton, { panels: panels, controls: controls }, void 0)) }), void 0) }), void 0));
    if (loading) {
        return loadingUi;
    }
    if (error) {
        return (jsx(Shadow, Object.assign({ inShadow: inShadow, cssHandles: cssHandles }, { children: jsx(GenericApolloError, Object.assign({ ssr: ssr, themeStyle: themeStyle, retry: () => {
                    refetch({
                        id,
                    });
                }, error: error, title: __('A server side error has occured', 'wp-eform') }, { children: jsx("p", { children: __('There was an error trying to fetch form data from the server. Try refreshing the page to see if that resolves it.', 'wp-eform') }, void 0) }), void 0) }), void 0));
    }
    return (jsx(Shadow, Object.assign({ inShadow: inShadow, cssHandles: cssHandles }, { children: jsx(FrontEndErrorBoundary, Object.assign({ themeStyle: themeStyle }, { children: jsx(FormSubmission, { formData: formData, formMeta: data.formMeta, mode: mode, submitting: submitting, submitted: submitted, submittedState: submittedState, onReset: reset, onSubmit: submit, submissionError: mutationResult && mutationResult.error
                    ? mutationResult.error
                    : undefined, mutationData: mutationResult.data?.createSubmission ?? undefined, limitations: data?.form.limitations, notices: data?.form.notices, 
                // For now, onRetry is same as the reset
                onErrorRetry: reset }, void 0) }), void 0) }), void 0));
}

const range = {
    id: 'range',
    hasSubmission: true,
    neededPlan: 'starter',
    FormUi({ elementData, setElementTouched, submissionData, updateSubmissionData, controlType, hasError, }) {
        const config = elementData.config.range;
        let marks;
        if (config?.interface?.showMarks) {
            marks = true;
            if (config.interface.customMarks.length) {
                marks = config.interface.customMarks.map(m => ({
                    index: m.index,
                    label: m.label ?? '',
                }));
            }
        }
        // FS:PREMIUM-ONLY-START
        if (fsIsPlanOrHigher('starter')) {
            return (jsx(Slider, { max: config?.interface?.max ?? 10, min: config?.interface?.min ?? 0, step: config?.interface?.step ?? 1, precision: config?.interface?.precision ?? 2, type: "range", onChange: newVal => {
                    updateSubmissionData(produce(submissionData, draftState => {
                        const minSelected = Math.min(...newVal);
                        const maxSelected = Math.max(...newVal);
                        draftState.value.range.minSelected = minSelected;
                        draftState.value.range.maxSelected = maxSelected;
                    }));
                }, value: [
                    submissionData.value.range.minSelected,
                    submissionData.value.range.maxSelected,
                ], controlType: controlType, disabled: config?.attributes.readonly, marks: marks, hasError: hasError, className: elementData.appearance?.className, onBlur: () => {
                    setElementTouched(true);
                }, showFreeInput: config?.interface?.showFreeInput }, void 0));
        }
        // FS:PREMIUM-ONLY-END
        return jsx("p", { children: "Not implemented in current plan" }, void 0);
    },
    getErrors(elementData, submissionDataValue) {
        const errors = [];
        const selectedMin = submissionDataValue.range.minSelected;
        const selectedMax = submissionDataValue.range.maxSelected;
        const config = elementData.config.range.interface;
        if (!config) {
            return errors;
        }
        if (selectedMin > selectedMax) {
            errors.push(validationMessages.rangeInvariant
                .replaceAll('{min}', selectedMin.toString())
                .replaceAll('{max}', selectedMax.toString()));
        }
        if (config.min && (selectedMin < config.min || selectedMax < config.min)) {
            errors.push(validationMessages.sliderMinUnderFlow.replaceAll('{min}', formatNumber(config.min, 2)));
        }
        if (config.max && (selectedMin > config.max || selectedMax > config.max)) {
            errors.push(validationMessages.sliderMaxOverFlow.replaceAll('{max}', formatNumber(config.max, 2)));
        }
        if (!validateValueInStep(selectedMin, config.step, config.min, config.precision)) {
            errors.push(validationMessages.rangeStepOverFlow
                .replaceAll('{value}', formatNumber(selectedMin, config.precision))
                .replaceAll('{step}', formatNumber(config.step, 2)));
        }
        if (!validateValueInStep(selectedMax, config.step, config.min, config.precision)) {
            errors.push(validationMessages.rangeStepOverFlow
                .replaceAll('{value}', formatNumber(selectedMax, config.precision))
                .replaceAll('{step}', formatNumber(config.step, 2)));
        }
        return errors;
    },
    isQuestion: true,
    isRequired(elementData) {
        return false;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        const explodedValue = newValue.split('/');
        if (explodedValue.length !== 2) {
            return;
        }
        const numberValueMin = getFloatValue(explodedValue[0], elementData.config.range?.interface?.min);
        const numberValueMax = getFloatValue(explodedValue[1], numberValueMin);
        mutableSubmissionDataValue.range.minSelected = numberValueMin;
        mutableSubmissionDataValue.range.maxSelected = numberValueMax;
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue) {
        let conditionStatus = false;
        const compareWith = getFloatValue(value, Number.NaN);
        if (Number.isNaN(compareWith)) {
            logger.l(`%c ERROR %c conditional operation on range assumes numeric value. '${value}' given.`, logger.style.error, logger.style.reset);
            return false;
        }
        const selectedMin = submissionDataValue.range.minSelected;
        const selectedMax = submissionDataValue.range.maxSelected;
        if (comparison === EventComparisonEnum.EQUALS_TO) {
            conditionStatus =
                selectedMin === compareWith || selectedMax === compareWith;
        }
        else if (comparison === EventComparisonEnum.GREATER_THAN) {
            conditionStatus = selectedMax > compareWith;
        }
        else if (comparison === EventComparisonEnum.LESS_THAN) {
            conditionStatus = selectedMin < compareWith;
        }
        return operation === EventOperationEnum.IS
            ? conditionStatus
            : !conditionStatus;
    },
    getDisplayValue(elementData, submissionDataValue) {
        const selectedMin = submissionDataValue.range.minSelected;
        const selectedMax = submissionDataValue.range.maxSelected;
        return `${formatNumber(selectedMin, elementData.config.range?.interface?.precision ?? 2)}${elementData.config.range?.interface?.separator ?? '-'}${formatNumber(selectedMax, elementData.config.range?.interface?.precision ?? 2)}`;
    },
    getNumericValue(elementData, submissionDataValue) {
        const selectedMin = getFloatValue(submissionDataValue.range.minSelected);
        const selectedMax = getFloatValue(submissionDataValue.range.maxSelected);
        return (selectedMin + selectedMax) / 2;
    },
    getAnswerValue(elementData, submissionDataValue) {
        const selectedMin = submissionDataValue.range.minSelected;
        const selectedMax = submissionDataValue.range.maxSelected;
        return `${formatNumber(selectedMin, elementData.config.range?.interface?.precision ?? 2)}${elementData.config.range?.interface?.separator ?? '/'}${formatNumber(selectedMax, elementData.config.range?.interface?.precision ?? 2)}`;
    },
    getPresetValue(elementData, defaultValue) {
        const allowedMinValue = elementData.config.range?.interface?.min ?? 0;
        const newDefaultValue = produce(defaultValue, draftValue => {
            // If it has a set default value
            let presetValue = '';
            if (!isNullOrEmptyString(elementData.config.range?.attributes.defaultValue)) {
                presetValue = elementData.config.range?.attributes.defaultValue ?? '';
            }
            // override if URL query parameter is used
            if (elementData.config.range?.attributes.prefilType === PrefilEnum.URL) {
                const urlValue = getUrlParameterValue(window.location.search, elementData.config.range.attributes.prefilParameter);
                if (typeof urlValue === 'string') {
                    presetValue = urlValue;
                }
            }
            // set based on presetValue
            if (presetValue) {
                const parsedValue = presetValue.split('/');
                if (parsedValue.length === 2) {
                    const minVal = getFloatValue(parsedValue[0], allowedMinValue);
                    draftValue.range.minSelected = minVal;
                    draftValue.range.maxSelected = getFloatValue(parsedValue[1], minVal);
                }
            }
            // override if meta based query is used
            if (elementData.config.range?.attributes.prefilType === PrefilEnum.META) {
                const decodedExtra = decodeJSONRecord(elementData.extras);
                if (decodedExtra && decodedExtra.metaValue) {
                    // metavalue would be an object with min and max
                    const metaValue = decodedExtra.metaValue;
                    if (typeof metaValue === 'object') {
                        draftValue.range.minSelected =
                            metaValue.minSelected ?? allowedMinValue;
                        draftValue.range.maxSelected = metaValue.maxSelected ?? 0;
                    }
                }
            }
            // override to allowed min and max value
            if (draftValue.range.minSelected < allowedMinValue) {
                draftValue.range.minSelected = allowedMinValue;
            }
            if (draftValue.range.maxSelected < draftValue.range.minSelected) {
                draftValue.range.maxSelected = draftValue.range.minSelected;
            }
            if (draftValue.range.minSelected === draftValue.range.maxSelected) {
                draftValue.range.maxSelected =
                    draftValue.range.minSelected +
                        (elementData.config.range?.interface?.step ?? 1);
            }
        });
        return newDefaultValue;
    },
};

var INUMBER = 'INUMBER';
var IOP1 = 'IOP1';
var IOP2 = 'IOP2';
var IOP3 = 'IOP3';
var IVAR = 'IVAR';
var IVARNAME = 'IVARNAME';
var IFUNCALL = 'IFUNCALL';
var IFUNDEF = 'IFUNDEF';
var IEXPR = 'IEXPR';
var IEXPREVAL = 'IEXPREVAL';
var IMEMBER = 'IMEMBER';
var IENDSTATEMENT = 'IENDSTATEMENT';
var IARRAY = 'IARRAY';

function Instruction(type, value) {
  this.type = type;
  this.value = (value !== undefined && value !== null) ? value : 0;
}

Instruction.prototype.toString = function () {
  switch (this.type) {
    case INUMBER:
    case IOP1:
    case IOP2:
    case IOP3:
    case IVAR:
    case IVARNAME:
    case IENDSTATEMENT:
      return this.value;
    case IFUNCALL:
      return 'CALL ' + this.value;
    case IFUNDEF:
      return 'DEF ' + this.value;
    case IARRAY:
      return 'ARRAY ' + this.value;
    case IMEMBER:
      return '.' + this.value;
    default:
      return 'Invalid Instruction';
  }
};

function unaryInstruction(value) {
  return new Instruction(IOP1, value);
}

function binaryInstruction(value) {
  return new Instruction(IOP2, value);
}

function ternaryInstruction(value) {
  return new Instruction(IOP3, value);
}

function simplify(tokens, unaryOps, binaryOps, ternaryOps, values) {
  var nstack = [];
  var newexpression = [];
  var n1, n2, n3;
  var f;
  for (var i = 0; i < tokens.length; i++) {
    var item = tokens[i];
    var type = item.type;
    if (type === INUMBER || type === IVARNAME) {
      if (Array.isArray(item.value)) {
        nstack.push.apply(nstack, simplify(item.value.map(function (x) {
          return new Instruction(INUMBER, x);
        }).concat(new Instruction(IARRAY, item.value.length)), unaryOps, binaryOps, ternaryOps, values));
      } else {
        nstack.push(item);
      }
    } else if (type === IVAR && values.hasOwnProperty(item.value)) {
      item = new Instruction(INUMBER, values[item.value]);
      nstack.push(item);
    } else if (type === IOP2 && nstack.length > 1) {
      n2 = nstack.pop();
      n1 = nstack.pop();
      f = binaryOps[item.value];
      item = new Instruction(INUMBER, f(n1.value, n2.value));
      nstack.push(item);
    } else if (type === IOP3 && nstack.length > 2) {
      n3 = nstack.pop();
      n2 = nstack.pop();
      n1 = nstack.pop();
      if (item.value === '?') {
        nstack.push(n1.value ? n2.value : n3.value);
      } else {
        f = ternaryOps[item.value];
        item = new Instruction(INUMBER, f(n1.value, n2.value, n3.value));
        nstack.push(item);
      }
    } else if (type === IOP1 && nstack.length > 0) {
      n1 = nstack.pop();
      f = unaryOps[item.value];
      item = new Instruction(INUMBER, f(n1.value));
      nstack.push(item);
    } else if (type === IEXPR) {
      while (nstack.length > 0) {
        newexpression.push(nstack.shift());
      }
      newexpression.push(new Instruction(IEXPR, simplify(item.value, unaryOps, binaryOps, ternaryOps, values)));
    } else if (type === IMEMBER && nstack.length > 0) {
      n1 = nstack.pop();
      nstack.push(new Instruction(INUMBER, n1.value[item.value]));
    } /* else if (type === IARRAY && nstack.length >= item.value) {
      var length = item.value;
      while (length-- > 0) {
        newexpression.push(nstack.pop());
      }
      newexpression.push(new Instruction(IARRAY, item.value));
    } */ else {
      while (nstack.length > 0) {
        newexpression.push(nstack.shift());
      }
      newexpression.push(item);
    }
  }
  while (nstack.length > 0) {
    newexpression.push(nstack.shift());
  }
  return newexpression;
}

function substitute(tokens, variable, expr) {
  var newexpression = [];
  for (var i = 0; i < tokens.length; i++) {
    var item = tokens[i];
    var type = item.type;
    if (type === IVAR && item.value === variable) {
      for (var j = 0; j < expr.tokens.length; j++) {
        var expritem = expr.tokens[j];
        var replitem;
        if (expritem.type === IOP1) {
          replitem = unaryInstruction(expritem.value);
        } else if (expritem.type === IOP2) {
          replitem = binaryInstruction(expritem.value);
        } else if (expritem.type === IOP3) {
          replitem = ternaryInstruction(expritem.value);
        } else {
          replitem = new Instruction(expritem.type, expritem.value);
        }
        newexpression.push(replitem);
      }
    } else if (type === IEXPR) {
      newexpression.push(new Instruction(IEXPR, substitute(item.value, variable, expr)));
    } else {
      newexpression.push(item);
    }
  }
  return newexpression;
}

function evaluate(tokens, expr, values) {
  var nstack = [];
  var n1, n2, n3;
  var f, args, argCount;

  if (isExpressionEvaluator(tokens)) {
    return resolveExpression(tokens, values);
  }

  var numTokens = tokens.length;

  for (var i = 0; i < numTokens; i++) {
    var item = tokens[i];
    var type = item.type;
    if (type === INUMBER || type === IVARNAME) {
      nstack.push(item.value);
    } else if (type === IOP2) {
      n2 = nstack.pop();
      n1 = nstack.pop();
      if (item.value === 'and') {
        nstack.push(n1 ? !!evaluate(n2, expr, values) : false);
      } else if (item.value === 'or') {
        nstack.push(n1 ? true : !!evaluate(n2, expr, values));
      } else if (item.value === '=') {
        f = expr.binaryOps[item.value];
        nstack.push(f(n1, evaluate(n2, expr, values), values));
      } else {
        f = expr.binaryOps[item.value];
        nstack.push(f(resolveExpression(n1, values), resolveExpression(n2, values)));
      }
    } else if (type === IOP3) {
      n3 = nstack.pop();
      n2 = nstack.pop();
      n1 = nstack.pop();
      if (item.value === '?') {
        nstack.push(evaluate(n1 ? n2 : n3, expr, values));
      } else {
        f = expr.ternaryOps[item.value];
        nstack.push(f(resolveExpression(n1, values), resolveExpression(n2, values), resolveExpression(n3, values)));
      }
    } else if (type === IVAR) {
      if (item.value in expr.functions) {
        nstack.push(expr.functions[item.value]);
      } else if (item.value in expr.unaryOps && expr.parser.isOperatorEnabled(item.value)) {
        nstack.push(expr.unaryOps[item.value]);
      } else {
        var v = values[item.value];
        if (v !== undefined) {
          nstack.push(v);
        } else {
          throw new Error('undefined variable: ' + item.value);
        }
      }
    } else if (type === IOP1) {
      n1 = nstack.pop();
      f = expr.unaryOps[item.value];
      nstack.push(f(resolveExpression(n1, values)));
    } else if (type === IFUNCALL) {
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(resolveExpression(nstack.pop(), values));
      }
      f = nstack.pop();
      if (f.apply && f.call) {
        nstack.push(f.apply(undefined, args));
      } else {
        throw new Error(f + ' is not a function');
      }
    } else if (type === IFUNDEF) {
      // Create closure to keep references to arguments and expression
      nstack.push((function () {
        var n2 = nstack.pop();
        var args = [];
        var argCount = item.value;
        while (argCount-- > 0) {
          args.unshift(nstack.pop());
        }
        var n1 = nstack.pop();
        var f = function () {
          var scope = Object.assign({}, values);
          for (var i = 0, len = args.length; i < len; i++) {
            scope[args[i]] = arguments[i];
          }
          return evaluate(n2, expr, scope);
        };
        // f.name = n1
        Object.defineProperty(f, 'name', {
          value: n1,
          writable: false
        });
        values[n1] = f;
        return f;
      })());
    } else if (type === IEXPR) {
      nstack.push(createExpressionEvaluator(item, expr));
    } else if (type === IEXPREVAL) {
      nstack.push(item);
    } else if (type === IMEMBER) {
      n1 = nstack.pop();
      nstack.push(n1[item.value]);
    } else if (type === IENDSTATEMENT) {
      nstack.pop();
    } else if (type === IARRAY) {
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(nstack.pop());
      }
      nstack.push(args);
    } else {
      throw new Error('invalid Expression');
    }
  }
  if (nstack.length > 1) {
    throw new Error('invalid Expression (parity)');
  }
  // Explicitly return zero to avoid test issues caused by -0
  return nstack[0] === 0 ? 0 : resolveExpression(nstack[0], values);
}

function createExpressionEvaluator(token, expr, values) {
  if (isExpressionEvaluator(token)) return token;
  return {
    type: IEXPREVAL,
    value: function (scope) {
      return evaluate(token.value, expr, scope);
    }
  };
}

function isExpressionEvaluator(n) {
  return n && n.type === IEXPREVAL;
}

function resolveExpression(n, values) {
  return isExpressionEvaluator(n) ? n.value(values) : n;
}

function expressionToString(tokens, toJS) {
  var nstack = [];
  var n1, n2, n3;
  var f, args, argCount;
  for (var i = 0; i < tokens.length; i++) {
    var item = tokens[i];
    var type = item.type;
    if (type === INUMBER) {
      if (typeof item.value === 'number' && item.value < 0) {
        nstack.push('(' + item.value + ')');
      } else if (Array.isArray(item.value)) {
        nstack.push('[' + item.value.map(escapeValue).join(', ') + ']');
      } else {
        nstack.push(escapeValue(item.value));
      }
    } else if (type === IOP2) {
      n2 = nstack.pop();
      n1 = nstack.pop();
      f = item.value;
      if (toJS) {
        if (f === '^') {
          nstack.push('Math.pow(' + n1 + ', ' + n2 + ')');
        } else if (f === 'and') {
          nstack.push('(!!' + n1 + ' && !!' + n2 + ')');
        } else if (f === 'or') {
          nstack.push('(!!' + n1 + ' || !!' + n2 + ')');
        } else if (f === '||') {
          nstack.push('(function(a,b){ return Array.isArray(a) && Array.isArray(b) ? a.concat(b) : String(a) + String(b); }((' + n1 + '),(' + n2 + ')))');
        } else if (f === '==') {
          nstack.push('(' + n1 + ' === ' + n2 + ')');
        } else if (f === '!=') {
          nstack.push('(' + n1 + ' !== ' + n2 + ')');
        } else if (f === '[') {
          nstack.push(n1 + '[(' + n2 + ') | 0]');
        } else {
          nstack.push('(' + n1 + ' ' + f + ' ' + n2 + ')');
        }
      } else {
        if (f === '[') {
          nstack.push(n1 + '[' + n2 + ']');
        } else {
          nstack.push('(' + n1 + ' ' + f + ' ' + n2 + ')');
        }
      }
    } else if (type === IOP3) {
      n3 = nstack.pop();
      n2 = nstack.pop();
      n1 = nstack.pop();
      f = item.value;
      if (f === '?') {
        nstack.push('(' + n1 + ' ? ' + n2 + ' : ' + n3 + ')');
      } else {
        throw new Error('invalid Expression');
      }
    } else if (type === IVAR || type === IVARNAME) {
      nstack.push(item.value);
    } else if (type === IOP1) {
      n1 = nstack.pop();
      f = item.value;
      if (f === '-' || f === '+') {
        nstack.push('(' + f + n1 + ')');
      } else if (toJS) {
        if (f === 'not') {
          nstack.push('(' + '!' + n1 + ')');
        } else if (f === '!') {
          nstack.push('fac(' + n1 + ')');
        } else {
          nstack.push(f + '(' + n1 + ')');
        }
      } else if (f === '!') {
        nstack.push('(' + n1 + '!)');
      } else {
        nstack.push('(' + f + ' ' + n1 + ')');
      }
    } else if (type === IFUNCALL) {
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(nstack.pop());
      }
      f = nstack.pop();
      nstack.push(f + '(' + args.join(', ') + ')');
    } else if (type === IFUNDEF) {
      n2 = nstack.pop();
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(nstack.pop());
      }
      n1 = nstack.pop();
      if (toJS) {
        nstack.push('(' + n1 + ' = function(' + args.join(', ') + ') { return ' + n2 + ' })');
      } else {
        nstack.push('(' + n1 + '(' + args.join(', ') + ') = ' + n2 + ')');
      }
    } else if (type === IMEMBER) {
      n1 = nstack.pop();
      nstack.push(n1 + '.' + item.value);
    } else if (type === IARRAY) {
      argCount = item.value;
      args = [];
      while (argCount-- > 0) {
        args.unshift(nstack.pop());
      }
      nstack.push('[' + args.join(', ') + ']');
    } else if (type === IEXPR) {
      nstack.push('(' + expressionToString(item.value, toJS) + ')');
    } else if (type === IENDSTATEMENT) ; else {
      throw new Error('invalid Expression');
    }
  }
  if (nstack.length > 1) {
    if (toJS) {
      nstack = [ nstack.join(',') ];
    } else {
      nstack = [ nstack.join(';') ];
    }
  }
  return String(nstack[0]);
}

function escapeValue(v) {
  if (typeof v === 'string') {
    return JSON.stringify(v).replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
  }
  return v;
}

function contains(array, obj) {
  for (var i = 0; i < array.length; i++) {
    if (array[i] === obj) {
      return true;
    }
  }
  return false;
}

function getSymbols(tokens, symbols, options) {
  options = options || {};
  var withMembers = !!options.withMembers;
  var prevVar = null;

  for (var i = 0; i < tokens.length; i++) {
    var item = tokens[i];
    if (item.type === IVAR || item.type === IVARNAME) {
      if (!withMembers && !contains(symbols, item.value)) {
        symbols.push(item.value);
      } else if (prevVar !== null) {
        if (!contains(symbols, prevVar)) {
          symbols.push(prevVar);
        }
        prevVar = item.value;
      } else {
        prevVar = item.value;
      }
    } else if (item.type === IMEMBER && withMembers && prevVar !== null) {
      prevVar += '.' + item.value;
    } else if (item.type === IEXPR) {
      getSymbols(item.value, symbols, options);
    } else if (prevVar !== null) {
      if (!contains(symbols, prevVar)) {
        symbols.push(prevVar);
      }
      prevVar = null;
    }
  }

  if (prevVar !== null && !contains(symbols, prevVar)) {
    symbols.push(prevVar);
  }
}

function Expression(tokens, parser) {
  this.tokens = tokens;
  this.parser = parser;
  this.unaryOps = parser.unaryOps;
  this.binaryOps = parser.binaryOps;
  this.ternaryOps = parser.ternaryOps;
  this.functions = parser.functions;
}

Expression.prototype.simplify = function (values) {
  values = values || {};
  return new Expression(simplify(this.tokens, this.unaryOps, this.binaryOps, this.ternaryOps, values), this.parser);
};

Expression.prototype.substitute = function (variable, expr) {
  if (!(expr instanceof Expression)) {
    expr = this.parser.parse(String(expr));
  }

  return new Expression(substitute(this.tokens, variable, expr), this.parser);
};

Expression.prototype.evaluate = function (values) {
  values = values || {};
  return evaluate(this.tokens, this, values);
};

Expression.prototype.toString = function () {
  return expressionToString(this.tokens, false);
};

Expression.prototype.symbols = function (options) {
  options = options || {};
  var vars = [];
  getSymbols(this.tokens, vars, options);
  return vars;
};

Expression.prototype.variables = function (options) {
  options = options || {};
  var vars = [];
  getSymbols(this.tokens, vars, options);
  var functions = this.functions;
  return vars.filter(function (name) {
    return !(name in functions);
  });
};

Expression.prototype.toJSFunction = function (param, variables) {
  var expr = this;
  var f = new Function(param, 'with(this.functions) with (this.ternaryOps) with (this.binaryOps) with (this.unaryOps) { return ' + expressionToString(this.simplify(variables).tokens, true) + '; }'); // eslint-disable-line no-new-func
  return function () {
    return f.apply(expr, arguments);
  };
};

var TEOF = 'TEOF';
var TOP = 'TOP';
var TNUMBER = 'TNUMBER';
var TSTRING = 'TSTRING';
var TPAREN = 'TPAREN';
var TBRACKET = 'TBRACKET';
var TCOMMA = 'TCOMMA';
var TNAME = 'TNAME';
var TSEMICOLON = 'TSEMICOLON';

function Token(type, value, index) {
  this.type = type;
  this.value = value;
  this.index = index;
}

Token.prototype.toString = function () {
  return this.type + ': ' + this.value;
};

function TokenStream(parser, expression) {
  this.pos = 0;
  this.current = null;
  this.unaryOps = parser.unaryOps;
  this.binaryOps = parser.binaryOps;
  this.ternaryOps = parser.ternaryOps;
  this.consts = parser.consts;
  this.expression = expression;
  this.savedPosition = 0;
  this.savedCurrent = null;
  this.options = parser.options;
  this.parser = parser;
}

TokenStream.prototype.newToken = function (type, value, pos) {
  return new Token(type, value, pos != null ? pos : this.pos);
};

TokenStream.prototype.save = function () {
  this.savedPosition = this.pos;
  this.savedCurrent = this.current;
};

TokenStream.prototype.restore = function () {
  this.pos = this.savedPosition;
  this.current = this.savedCurrent;
};

TokenStream.prototype.next = function () {
  if (this.pos >= this.expression.length) {
    return this.newToken(TEOF, 'EOF');
  }

  if (this.isWhitespace() || this.isComment()) {
    return this.next();
  } else if (this.isRadixInteger() ||
      this.isNumber() ||
      this.isOperator() ||
      this.isString() ||
      this.isParen() ||
      this.isBracket() ||
      this.isComma() ||
      this.isSemicolon() ||
      this.isNamedOp() ||
      this.isConst() ||
      this.isName()) {
    return this.current;
  } else {
    this.parseError('Unknown character "' + this.expression.charAt(this.pos) + '"');
  }
};

TokenStream.prototype.isString = function () {
  var r = false;
  var startPos = this.pos;
  var quote = this.expression.charAt(startPos);

  if (quote === '\'' || quote === '"') {
    var index = this.expression.indexOf(quote, startPos + 1);
    while (index >= 0 && this.pos < this.expression.length) {
      this.pos = index + 1;
      if (this.expression.charAt(index - 1) !== '\\') {
        var rawString = this.expression.substring(startPos + 1, index);
        this.current = this.newToken(TSTRING, this.unescape(rawString), startPos);
        r = true;
        break;
      }
      index = this.expression.indexOf(quote, index + 1);
    }
  }
  return r;
};

TokenStream.prototype.isParen = function () {
  var c = this.expression.charAt(this.pos);
  if (c === '(' || c === ')') {
    this.current = this.newToken(TPAREN, c);
    this.pos++;
    return true;
  }
  return false;
};

TokenStream.prototype.isBracket = function () {
  var c = this.expression.charAt(this.pos);
  if ((c === '[' || c === ']') && this.isOperatorEnabled('[')) {
    this.current = this.newToken(TBRACKET, c);
    this.pos++;
    return true;
  }
  return false;
};

TokenStream.prototype.isComma = function () {
  var c = this.expression.charAt(this.pos);
  if (c === ',') {
    this.current = this.newToken(TCOMMA, ',');
    this.pos++;
    return true;
  }
  return false;
};

TokenStream.prototype.isSemicolon = function () {
  var c = this.expression.charAt(this.pos);
  if (c === ';') {
    this.current = this.newToken(TSEMICOLON, ';');
    this.pos++;
    return true;
  }
  return false;
};

TokenStream.prototype.isConst = function () {
  var startPos = this.pos;
  var i = startPos;
  for (; i < this.expression.length; i++) {
    var c = this.expression.charAt(i);
    if (c.toUpperCase() === c.toLowerCase()) {
      if (i === this.pos || (c !== '_' && c !== '.' && (c < '0' || c > '9'))) {
        break;
      }
    }
  }
  if (i > startPos) {
    var str = this.expression.substring(startPos, i);
    if (str in this.consts) {
      this.current = this.newToken(TNUMBER, this.consts[str]);
      this.pos += str.length;
      return true;
    }
  }
  return false;
};

TokenStream.prototype.isNamedOp = function () {
  var startPos = this.pos;
  var i = startPos;
  for (; i < this.expression.length; i++) {
    var c = this.expression.charAt(i);
    if (c.toUpperCase() === c.toLowerCase()) {
      if (i === this.pos || (c !== '_' && (c < '0' || c > '9'))) {
        break;
      }
    }
  }
  if (i > startPos) {
    var str = this.expression.substring(startPos, i);
    if (this.isOperatorEnabled(str) && (str in this.binaryOps || str in this.unaryOps || str in this.ternaryOps)) {
      this.current = this.newToken(TOP, str);
      this.pos += str.length;
      return true;
    }
  }
  return false;
};

TokenStream.prototype.isName = function () {
  var startPos = this.pos;
  var i = startPos;
  var hasLetter = false;
  for (; i < this.expression.length; i++) {
    var c = this.expression.charAt(i);
    if (c.toUpperCase() === c.toLowerCase()) {
      if (i === this.pos && (c === '$' || c === '_')) {
        if (c === '_') {
          hasLetter = true;
        }
        continue;
      } else if (i === this.pos || !hasLetter || (c !== '_' && (c < '0' || c > '9'))) {
        break;
      }
    } else {
      hasLetter = true;
    }
  }
  if (hasLetter) {
    var str = this.expression.substring(startPos, i);
    this.current = this.newToken(TNAME, str);
    this.pos += str.length;
    return true;
  }
  return false;
};

TokenStream.prototype.isWhitespace = function () {
  var r = false;
  var c = this.expression.charAt(this.pos);
  while (c === ' ' || c === '\t' || c === '\n' || c === '\r') {
    r = true;
    this.pos++;
    if (this.pos >= this.expression.length) {
      break;
    }
    c = this.expression.charAt(this.pos);
  }
  return r;
};

var codePointPattern = /^[0-9a-f]{4}$/i;

TokenStream.prototype.unescape = function (v) {
  var index = v.indexOf('\\');
  if (index < 0) {
    return v;
  }

  var buffer = v.substring(0, index);
  while (index >= 0) {
    var c = v.charAt(++index);
    switch (c) {
      case '\'':
        buffer += '\'';
        break;
      case '"':
        buffer += '"';
        break;
      case '\\':
        buffer += '\\';
        break;
      case '/':
        buffer += '/';
        break;
      case 'b':
        buffer += '\b';
        break;
      case 'f':
        buffer += '\f';
        break;
      case 'n':
        buffer += '\n';
        break;
      case 'r':
        buffer += '\r';
        break;
      case 't':
        buffer += '\t';
        break;
      case 'u':
        // interpret the following 4 characters as the hex of the unicode code point
        var codePoint = v.substring(index + 1, index + 5);
        if (!codePointPattern.test(codePoint)) {
          this.parseError('Illegal escape sequence: \\u' + codePoint);
        }
        buffer += String.fromCharCode(parseInt(codePoint, 16));
        index += 4;
        break;
      default:
        throw this.parseError('Illegal escape sequence: "\\' + c + '"');
    }
    ++index;
    var backslash = v.indexOf('\\', index);
    buffer += v.substring(index, backslash < 0 ? v.length : backslash);
    index = backslash;
  }

  return buffer;
};

TokenStream.prototype.isComment = function () {
  var c = this.expression.charAt(this.pos);
  if (c === '/' && this.expression.charAt(this.pos + 1) === '*') {
    this.pos = this.expression.indexOf('*/', this.pos) + 2;
    if (this.pos === 1) {
      this.pos = this.expression.length;
    }
    return true;
  }
  return false;
};

TokenStream.prototype.isRadixInteger = function () {
  var pos = this.pos;

  if (pos >= this.expression.length - 2 || this.expression.charAt(pos) !== '0') {
    return false;
  }
  ++pos;

  var radix;
  var validDigit;
  if (this.expression.charAt(pos) === 'x') {
    radix = 16;
    validDigit = /^[0-9a-f]$/i;
    ++pos;
  } else if (this.expression.charAt(pos) === 'b') {
    radix = 2;
    validDigit = /^[01]$/i;
    ++pos;
  } else {
    return false;
  }

  var valid = false;
  var startPos = pos;

  while (pos < this.expression.length) {
    var c = this.expression.charAt(pos);
    if (validDigit.test(c)) {
      pos++;
      valid = true;
    } else {
      break;
    }
  }

  if (valid) {
    this.current = this.newToken(TNUMBER, parseInt(this.expression.substring(startPos, pos), radix));
    this.pos = pos;
  }
  return valid;
};

TokenStream.prototype.isNumber = function () {
  var valid = false;
  var pos = this.pos;
  var startPos = pos;
  var resetPos = pos;
  var foundDot = false;
  var foundDigits = false;
  var c;

  while (pos < this.expression.length) {
    c = this.expression.charAt(pos);
    if ((c >= '0' && c <= '9') || (!foundDot && c === '.')) {
      if (c === '.') {
        foundDot = true;
      } else {
        foundDigits = true;
      }
      pos++;
      valid = foundDigits;
    } else {
      break;
    }
  }

  if (valid) {
    resetPos = pos;
  }

  if (c === 'e' || c === 'E') {
    pos++;
    var acceptSign = true;
    var validExponent = false;
    while (pos < this.expression.length) {
      c = this.expression.charAt(pos);
      if (acceptSign && (c === '+' || c === '-')) {
        acceptSign = false;
      } else if (c >= '0' && c <= '9') {
        validExponent = true;
        acceptSign = false;
      } else {
        break;
      }
      pos++;
    }

    if (!validExponent) {
      pos = resetPos;
    }
  }

  if (valid) {
    this.current = this.newToken(TNUMBER, parseFloat(this.expression.substring(startPos, pos)));
    this.pos = pos;
  } else {
    this.pos = resetPos;
  }
  return valid;
};

TokenStream.prototype.isOperator = function () {
  var startPos = this.pos;
  var c = this.expression.charAt(this.pos);

  if (c === '+' || c === '-' || c === '*' || c === '/' || c === '%' || c === '^' || c === '?' || c === ':' || c === '.') {
    this.current = this.newToken(TOP, c);
  } else if (c === '' || c === '') {
    this.current = this.newToken(TOP, '*');
  } else if (c === '>') {
    if (this.expression.charAt(this.pos + 1) === '=') {
      this.current = this.newToken(TOP, '>=');
      this.pos++;
    } else {
      this.current = this.newToken(TOP, '>');
    }
  } else if (c === '<') {
    if (this.expression.charAt(this.pos + 1) === '=') {
      this.current = this.newToken(TOP, '<=');
      this.pos++;
    } else {
      this.current = this.newToken(TOP, '<');
    }
  } else if (c === '|') {
    if (this.expression.charAt(this.pos + 1) === '|') {
      this.current = this.newToken(TOP, '||');
      this.pos++;
    } else {
      return false;
    }
  } else if (c === '=') {
    if (this.expression.charAt(this.pos + 1) === '=') {
      this.current = this.newToken(TOP, '==');
      this.pos++;
    } else {
      this.current = this.newToken(TOP, c);
    }
  } else if (c === '!') {
    if (this.expression.charAt(this.pos + 1) === '=') {
      this.current = this.newToken(TOP, '!=');
      this.pos++;
    } else {
      this.current = this.newToken(TOP, c);
    }
  } else {
    return false;
  }
  this.pos++;

  if (this.isOperatorEnabled(this.current.value)) {
    return true;
  } else {
    this.pos = startPos;
    return false;
  }
};

TokenStream.prototype.isOperatorEnabled = function (op) {
  return this.parser.isOperatorEnabled(op);
};

TokenStream.prototype.getCoordinates = function () {
  var line = 0;
  var column;
  var newline = -1;
  do {
    line++;
    column = this.pos - newline;
    newline = this.expression.indexOf('\n', newline + 1);
  } while (newline >= 0 && newline < this.pos);

  return {
    line: line,
    column: column
  };
};

TokenStream.prototype.parseError = function (msg) {
  var coords = this.getCoordinates();
  throw new Error('parse error [' + coords.line + ':' + coords.column + ']: ' + msg);
};

function ParserState(parser, tokenStream, options) {
  this.parser = parser;
  this.tokens = tokenStream;
  this.current = null;
  this.nextToken = null;
  this.next();
  this.savedCurrent = null;
  this.savedNextToken = null;
  this.allowMemberAccess = options.allowMemberAccess !== false;
}

ParserState.prototype.next = function () {
  this.current = this.nextToken;
  return (this.nextToken = this.tokens.next());
};

ParserState.prototype.tokenMatches = function (token, value) {
  if (typeof value === 'undefined') {
    return true;
  } else if (Array.isArray(value)) {
    return contains(value, token.value);
  } else if (typeof value === 'function') {
    return value(token);
  } else {
    return token.value === value;
  }
};

ParserState.prototype.save = function () {
  this.savedCurrent = this.current;
  this.savedNextToken = this.nextToken;
  this.tokens.save();
};

ParserState.prototype.restore = function () {
  this.tokens.restore();
  this.current = this.savedCurrent;
  this.nextToken = this.savedNextToken;
};

ParserState.prototype.accept = function (type, value) {
  if (this.nextToken.type === type && this.tokenMatches(this.nextToken, value)) {
    this.next();
    return true;
  }
  return false;
};

ParserState.prototype.expect = function (type, value) {
  if (!this.accept(type, value)) {
    var coords = this.tokens.getCoordinates();
    throw new Error('parse error [' + coords.line + ':' + coords.column + ']: Expected ' + (value || type));
  }
};

ParserState.prototype.parseAtom = function (instr) {
  var unaryOps = this.tokens.unaryOps;
  function isPrefixOperator(token) {
    return token.value in unaryOps;
  }

  if (this.accept(TNAME) || this.accept(TOP, isPrefixOperator)) {
    instr.push(new Instruction(IVAR, this.current.value));
  } else if (this.accept(TNUMBER)) {
    instr.push(new Instruction(INUMBER, this.current.value));
  } else if (this.accept(TSTRING)) {
    instr.push(new Instruction(INUMBER, this.current.value));
  } else if (this.accept(TPAREN, '(')) {
    this.parseExpression(instr);
    this.expect(TPAREN, ')');
  } else if (this.accept(TBRACKET, '[')) {
    if (this.accept(TBRACKET, ']')) {
      instr.push(new Instruction(IARRAY, 0));
    } else {
      var argCount = this.parseArrayList(instr);
      instr.push(new Instruction(IARRAY, argCount));
    }
  } else {
    throw new Error('unexpected ' + this.nextToken);
  }
};

ParserState.prototype.parseExpression = function (instr) {
  var exprInstr = [];
  if (this.parseUntilEndStatement(instr, exprInstr)) {
    return;
  }
  this.parseVariableAssignmentExpression(exprInstr);
  if (this.parseUntilEndStatement(instr, exprInstr)) {
    return;
  }
  this.pushExpression(instr, exprInstr);
};

ParserState.prototype.pushExpression = function (instr, exprInstr) {
  for (var i = 0, len = exprInstr.length; i < len; i++) {
    instr.push(exprInstr[i]);
  }
};

ParserState.prototype.parseUntilEndStatement = function (instr, exprInstr) {
  if (!this.accept(TSEMICOLON)) return false;
  if (this.nextToken && this.nextToken.type !== TEOF && !(this.nextToken.type === TPAREN && this.nextToken.value === ')')) {
    exprInstr.push(new Instruction(IENDSTATEMENT));
  }
  if (this.nextToken.type !== TEOF) {
    this.parseExpression(exprInstr);
  }
  instr.push(new Instruction(IEXPR, exprInstr));
  return true;
};

ParserState.prototype.parseArrayList = function (instr) {
  var argCount = 0;

  while (!this.accept(TBRACKET, ']')) {
    this.parseExpression(instr);
    ++argCount;
    while (this.accept(TCOMMA)) {
      this.parseExpression(instr);
      ++argCount;
    }
  }

  return argCount;
};

ParserState.prototype.parseVariableAssignmentExpression = function (instr) {
  this.parseConditionalExpression(instr);
  while (this.accept(TOP, '=')) {
    var varName = instr.pop();
    var varValue = [];
    var lastInstrIndex = instr.length - 1;
    if (varName.type === IFUNCALL) {
      if (!this.tokens.isOperatorEnabled('()=')) {
        throw new Error('function definition is not permitted');
      }
      for (var i = 0, len = varName.value + 1; i < len; i++) {
        var index = lastInstrIndex - i;
        if (instr[index].type === IVAR) {
          instr[index] = new Instruction(IVARNAME, instr[index].value);
        }
      }
      this.parseVariableAssignmentExpression(varValue);
      instr.push(new Instruction(IEXPR, varValue));
      instr.push(new Instruction(IFUNDEF, varName.value));
      continue;
    }
    if (varName.type !== IVAR && varName.type !== IMEMBER) {
      throw new Error('expected variable for assignment');
    }
    this.parseVariableAssignmentExpression(varValue);
    instr.push(new Instruction(IVARNAME, varName.value));
    instr.push(new Instruction(IEXPR, varValue));
    instr.push(binaryInstruction('='));
  }
};

ParserState.prototype.parseConditionalExpression = function (instr) {
  this.parseOrExpression(instr);
  while (this.accept(TOP, '?')) {
    var trueBranch = [];
    var falseBranch = [];
    this.parseConditionalExpression(trueBranch);
    this.expect(TOP, ':');
    this.parseConditionalExpression(falseBranch);
    instr.push(new Instruction(IEXPR, trueBranch));
    instr.push(new Instruction(IEXPR, falseBranch));
    instr.push(ternaryInstruction('?'));
  }
};

ParserState.prototype.parseOrExpression = function (instr) {
  this.parseAndExpression(instr);
  while (this.accept(TOP, 'or')) {
    var falseBranch = [];
    this.parseAndExpression(falseBranch);
    instr.push(new Instruction(IEXPR, falseBranch));
    instr.push(binaryInstruction('or'));
  }
};

ParserState.prototype.parseAndExpression = function (instr) {
  this.parseComparison(instr);
  while (this.accept(TOP, 'and')) {
    var trueBranch = [];
    this.parseComparison(trueBranch);
    instr.push(new Instruction(IEXPR, trueBranch));
    instr.push(binaryInstruction('and'));
  }
};

var COMPARISON_OPERATORS = ['==', '!=', '<', '<=', '>=', '>', 'in'];

ParserState.prototype.parseComparison = function (instr) {
  this.parseAddSub(instr);
  while (this.accept(TOP, COMPARISON_OPERATORS)) {
    var op = this.current;
    this.parseAddSub(instr);
    instr.push(binaryInstruction(op.value));
  }
};

var ADD_SUB_OPERATORS = ['+', '-', '||'];

ParserState.prototype.parseAddSub = function (instr) {
  this.parseTerm(instr);
  while (this.accept(TOP, ADD_SUB_OPERATORS)) {
    var op = this.current;
    this.parseTerm(instr);
    instr.push(binaryInstruction(op.value));
  }
};

var TERM_OPERATORS = ['*', '/', '%'];

ParserState.prototype.parseTerm = function (instr) {
  this.parseFactor(instr);
  while (this.accept(TOP, TERM_OPERATORS)) {
    var op = this.current;
    this.parseFactor(instr);
    instr.push(binaryInstruction(op.value));
  }
};

ParserState.prototype.parseFactor = function (instr) {
  var unaryOps = this.tokens.unaryOps;
  function isPrefixOperator(token) {
    return token.value in unaryOps;
  }

  this.save();
  if (this.accept(TOP, isPrefixOperator)) {
    if (this.current.value !== '-' && this.current.value !== '+') {
      if (this.nextToken.type === TPAREN && this.nextToken.value === '(') {
        this.restore();
        this.parseExponential(instr);
        return;
      } else if (this.nextToken.type === TSEMICOLON || this.nextToken.type === TCOMMA || this.nextToken.type === TEOF || (this.nextToken.type === TPAREN && this.nextToken.value === ')')) {
        this.restore();
        this.parseAtom(instr);
        return;
      }
    }

    var op = this.current;
    this.parseFactor(instr);
    instr.push(unaryInstruction(op.value));
  } else {
    this.parseExponential(instr);
  }
};

ParserState.prototype.parseExponential = function (instr) {
  this.parsePostfixExpression(instr);
  while (this.accept(TOP, '^')) {
    this.parseFactor(instr);
    instr.push(binaryInstruction('^'));
  }
};

ParserState.prototype.parsePostfixExpression = function (instr) {
  this.parseFunctionCall(instr);
  while (this.accept(TOP, '!')) {
    instr.push(unaryInstruction('!'));
  }
};

ParserState.prototype.parseFunctionCall = function (instr) {
  var unaryOps = this.tokens.unaryOps;
  function isPrefixOperator(token) {
    return token.value in unaryOps;
  }

  if (this.accept(TOP, isPrefixOperator)) {
    var op = this.current;
    this.parseAtom(instr);
    instr.push(unaryInstruction(op.value));
  } else {
    this.parseMemberExpression(instr);
    while (this.accept(TPAREN, '(')) {
      if (this.accept(TPAREN, ')')) {
        instr.push(new Instruction(IFUNCALL, 0));
      } else {
        var argCount = this.parseArgumentList(instr);
        instr.push(new Instruction(IFUNCALL, argCount));
      }
    }
  }
};

ParserState.prototype.parseArgumentList = function (instr) {
  var argCount = 0;

  while (!this.accept(TPAREN, ')')) {
    this.parseExpression(instr);
    ++argCount;
    while (this.accept(TCOMMA)) {
      this.parseExpression(instr);
      ++argCount;
    }
  }

  return argCount;
};

ParserState.prototype.parseMemberExpression = function (instr) {
  this.parseAtom(instr);
  while (this.accept(TOP, '.') || this.accept(TBRACKET, '[')) {
    var op = this.current;

    if (op.value === '.') {
      if (!this.allowMemberAccess) {
        throw new Error('unexpected ".", member access is not permitted');
      }

      this.expect(TNAME);
      instr.push(new Instruction(IMEMBER, this.current.value));
    } else if (op.value === '[') {
      if (!this.tokens.isOperatorEnabled('[')) {
        throw new Error('unexpected "[]", arrays are disabled');
      }

      this.parseExpression(instr);
      this.expect(TBRACKET, ']');
      instr.push(binaryInstruction('['));
    } else {
      throw new Error('unexpected symbol: ' + op.value);
    }
  }
};

function add(a, b) {
  return Number(a) + Number(b);
}

function sub(a, b) {
  return a - b;
}

function mul(a, b) {
  return a * b;
}

function div(a, b) {
  return a / b;
}

function mod(a, b) {
  return a % b;
}

function concat(a, b) {
  if (Array.isArray(a) && Array.isArray(b)) {
    return a.concat(b);
  }
  return '' + a + b;
}

function equal(a, b) {
  return a === b;
}

function notEqual(a, b) {
  return a !== b;
}

function greaterThan(a, b) {
  return a > b;
}

function lessThan(a, b) {
  return a < b;
}

function greaterThanEqual(a, b) {
  return a >= b;
}

function lessThanEqual(a, b) {
  return a <= b;
}

function andOperator(a, b) {
  return Boolean(a && b);
}

function orOperator(a, b) {
  return Boolean(a || b);
}

function inOperator(a, b) {
  return contains(b, a);
}

function sinh(a) {
  return ((Math.exp(a) - Math.exp(-a)) / 2);
}

function cosh(a) {
  return ((Math.exp(a) + Math.exp(-a)) / 2);
}

function tanh(a) {
  if (a === Infinity) return 1;
  if (a === -Infinity) return -1;
  return (Math.exp(a) - Math.exp(-a)) / (Math.exp(a) + Math.exp(-a));
}

function asinh(a) {
  if (a === -Infinity) return a;
  return Math.log(a + Math.sqrt((a * a) + 1));
}

function acosh(a) {
  return Math.log(a + Math.sqrt((a * a) - 1));
}

function atanh(a) {
  return (Math.log((1 + a) / (1 - a)) / 2);
}

function log10(a) {
  return Math.log(a) * Math.LOG10E;
}

function neg(a) {
  return -a;
}

function not(a) {
  return !a;
}

function trunc(a) {
  return a < 0 ? Math.ceil(a) : Math.floor(a);
}

function random(a) {
  return Math.random() * (a || 1);
}

function factorial(a) { // a!
  return gamma(a + 1);
}

function isInteger(value) {
  return isFinite(value) && (value === Math.round(value));
}

var GAMMA_G = 4.7421875;
var GAMMA_P = [
  0.99999999999999709182,
  57.156235665862923517, -59.597960355475491248,
  14.136097974741747174, -0.49191381609762019978,
  0.33994649984811888699e-4,
  0.46523628927048575665e-4, -0.98374475304879564677e-4,
  0.15808870322491248884e-3, -0.21026444172410488319e-3,
  0.21743961811521264320e-3, -0.16431810653676389022e-3,
  0.84418223983852743293e-4, -0.26190838401581408670e-4,
  0.36899182659531622704e-5
];

// Gamma function from math.js
function gamma(n) {
  var t, x;

  if (isInteger(n)) {
    if (n <= 0) {
      return isFinite(n) ? Infinity : NaN;
    }

    if (n > 171) {
      return Infinity; // Will overflow
    }

    var value = n - 2;
    var res = n - 1;
    while (value > 1) {
      res *= value;
      value--;
    }

    if (res === 0) {
      res = 1; // 0! is per definition 1
    }

    return res;
  }

  if (n < 0.5) {
    return Math.PI / (Math.sin(Math.PI * n) * gamma(1 - n));
  }

  if (n >= 171.35) {
    return Infinity; // will overflow
  }

  if (n > 85.0) { // Extended Stirling Approx
    var twoN = n * n;
    var threeN = twoN * n;
    var fourN = threeN * n;
    var fiveN = fourN * n;
    return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
      (1 + (1 / (12 * n)) + (1 / (288 * twoN)) - (139 / (51840 * threeN)) -
      (571 / (2488320 * fourN)) + (163879 / (209018880 * fiveN)) +
      (5246819 / (75246796800 * fiveN * n)));
  }

  --n;
  x = GAMMA_P[0];
  for (var i = 1; i < GAMMA_P.length; ++i) {
    x += GAMMA_P[i] / (n + i);
  }

  t = n + GAMMA_G + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
}

function stringOrArrayLength(s) {
  if (Array.isArray(s)) {
    return s.length;
  }
  return String(s).length;
}

function hypot() {
  var sum = 0;
  var larg = 0;
  for (var i = 0; i < arguments.length; i++) {
    var arg = Math.abs(arguments[i]);
    var div;
    if (larg < arg) {
      div = larg / arg;
      sum = (sum * div * div) + 1;
      larg = arg;
    } else if (arg > 0) {
      div = arg / larg;
      sum += div * div;
    } else {
      sum += arg;
    }
  }
  return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
}

function condition(cond, yep, nope) {
  return cond ? yep : nope;
}

/**
* Decimal adjustment of a number.
* From @escopecz.
*
* @param {Number} value The number.
* @param {Integer} exp  The exponent (the 10 logarithm of the adjustment base).
* @return {Number} The adjusted value.
*/
function roundTo(value, exp) {
  // If the exp is undefined or zero...
  if (typeof exp === 'undefined' || +exp === 0) {
    return Math.round(value);
  }
  value = +value;
  exp = -(+exp);
  // If the value is not a number or the exp is not an integer...
  if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
    return NaN;
  }
  // Shift
  value = value.toString().split('e');
  value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
  // Shift back
  value = value.toString().split('e');
  return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
}

function setVar(name, value, variables) {
  if (variables) variables[name] = value;
  return value;
}

function arrayIndex(array, index) {
  return array[index | 0];
}

function max(array) {
  if (arguments.length === 1 && Array.isArray(array)) {
    return Math.max.apply(Math, array);
  } else {
    return Math.max.apply(Math, arguments);
  }
}

function min(array) {
  if (arguments.length === 1 && Array.isArray(array)) {
    return Math.min.apply(Math, array);
  } else {
    return Math.min.apply(Math, arguments);
  }
}

function arrayMap(f, a) {
  if (typeof f !== 'function') {
    throw new Error('First argument to map is not a function');
  }
  if (!Array.isArray(a)) {
    throw new Error('Second argument to map is not an array');
  }
  return a.map(function (x, i) {
    return f(x, i);
  });
}

function arrayFold(f, init, a) {
  if (typeof f !== 'function') {
    throw new Error('First argument to fold is not a function');
  }
  if (!Array.isArray(a)) {
    throw new Error('Second argument to fold is not an array');
  }
  return a.reduce(function (acc, x, i) {
    return f(acc, x, i);
  }, init);
}

function arrayFilter(f, a) {
  if (typeof f !== 'function') {
    throw new Error('First argument to filter is not a function');
  }
  if (!Array.isArray(a)) {
    throw new Error('Second argument to filter is not an array');
  }
  return a.filter(function (x, i) {
    return f(x, i);
  });
}

function stringOrArrayIndexOf(target, s) {
  if (!(Array.isArray(s) || typeof s === 'string')) {
    throw new Error('Second argument to indexOf is not a string or array');
  }

  return s.indexOf(target);
}

function arrayJoin(sep, a) {
  if (!Array.isArray(a)) {
    throw new Error('Second argument to join is not an array');
  }

  return a.join(sep);
}

function sign(x) {
  return ((x > 0) - (x < 0)) || +x;
}

var ONE_THIRD = 1/3;
function cbrt(x) {
  return x < 0 ? -Math.pow(-x, ONE_THIRD) : Math.pow(x, ONE_THIRD);
}

function expm1(x) {
  return Math.exp(x) - 1;
}

function log1p(x) {
  return Math.log(1 + x);
}

function log2(x) {
  return Math.log(x) / Math.LN2;
}

function Parser(options) {
  this.options = options || {};
  this.unaryOps = {
    sin: Math.sin,
    cos: Math.cos,
    tan: Math.tan,
    asin: Math.asin,
    acos: Math.acos,
    atan: Math.atan,
    sinh: Math.sinh || sinh,
    cosh: Math.cosh || cosh,
    tanh: Math.tanh || tanh,
    asinh: Math.asinh || asinh,
    acosh: Math.acosh || acosh,
    atanh: Math.atanh || atanh,
    sqrt: Math.sqrt,
    cbrt: Math.cbrt || cbrt,
    log: Math.log,
    log2: Math.log2 || log2,
    ln: Math.log,
    lg: Math.log10 || log10,
    log10: Math.log10 || log10,
    expm1: Math.expm1 || expm1,
    log1p: Math.log1p || log1p,
    abs: Math.abs,
    ceil: Math.ceil,
    floor: Math.floor,
    round: Math.round,
    trunc: Math.trunc || trunc,
    '-': neg,
    '+': Number,
    exp: Math.exp,
    not: not,
    length: stringOrArrayLength,
    '!': factorial,
    sign: Math.sign || sign
  };

  this.binaryOps = {
    '+': add,
    '-': sub,
    '*': mul,
    '/': div,
    '%': mod,
    '^': Math.pow,
    '||': concat,
    '==': equal,
    '!=': notEqual,
    '>': greaterThan,
    '<': lessThan,
    '>=': greaterThanEqual,
    '<=': lessThanEqual,
    and: andOperator,
    or: orOperator,
    'in': inOperator,
    '=': setVar,
    '[': arrayIndex
  };

  this.ternaryOps = {
    '?': condition
  };

  this.functions = {
    random: random,
    fac: factorial,
    min: min,
    max: max,
    hypot: Math.hypot || hypot,
    pyt: Math.hypot || hypot, // backward compat
    pow: Math.pow,
    atan2: Math.atan2,
    'if': condition,
    gamma: gamma,
    roundTo: roundTo,
    map: arrayMap,
    fold: arrayFold,
    filter: arrayFilter,
    indexOf: stringOrArrayIndexOf,
    join: arrayJoin
  };

  this.consts = {
    E: Math.E,
    PI: Math.PI,
    'true': true,
    'false': false
  };
}

Parser.prototype.parse = function (expr) {
  var instr = [];
  var parserState = new ParserState(
    this,
    new TokenStream(this, expr),
    { allowMemberAccess: this.options.allowMemberAccess }
  );

  parserState.parseExpression(instr);
  parserState.expect(TEOF, 'EOF');

  return new Expression(instr, this);
};

Parser.prototype.evaluate = function (expr, variables) {
  return this.parse(expr).evaluate(variables);
};

var sharedParser = new Parser();

Parser.parse = function (expr) {
  return sharedParser.parse(expr);
};

Parser.evaluate = function (expr, variables) {
  return sharedParser.parse(expr).evaluate(variables);
};

var optionNameMap = {
  '+': 'add',
  '-': 'subtract',
  '*': 'multiply',
  '/': 'divide',
  '%': 'remainder',
  '^': 'power',
  '!': 'factorial',
  '<': 'comparison',
  '>': 'comparison',
  '<=': 'comparison',
  '>=': 'comparison',
  '==': 'comparison',
  '!=': 'comparison',
  '||': 'concatenate',
  'and': 'logical',
  'or': 'logical',
  'not': 'logical',
  '?': 'conditional',
  ':': 'conditional',
  '=': 'assignment',
  '[': 'array',
  '()=': 'fndef'
};

function getOptionName(op) {
  return optionNameMap.hasOwnProperty(op) ? optionNameMap[op] : op;
}

Parser.prototype.isOperatorEnabled = function (op) {
  var optionName = getOptionName(op);
  var operators = this.options.operators || {};

  return !(optionName in operators) || !!operators[optionName];
};

/**
 * Unique string Id generator class.
 *
 * Adopted from
 * @link https://stackoverflow.com/a/12504061/2754557
 *
 * @usage
 * const ids = new StringIdGenerator();
 *
 *	ids.next(); // 'a'
 *	ids.next(); // 'b'
 *	ids.next(); // 'c'
 *
 *	// ...
 *	ids.next(); // 'z'
 *	ids.next(); // 'A'
 *	ids.next(); // 'B'
 *
 *	// ...
 *	ids.next(); // 'Z'
 *	ids.next(); // 'aa'
 *	ids.next(); // 'ab'
 *	ids.next(); // 'ac'
 */
class StringIdGenerator {
    chars;
    nextId;
    constructor(chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') {
        this.chars = chars;
        this.nextId = [0];
    }
    next() {
        const r = [];
        // eslint-disable-next-line no-restricted-syntax
        for (const char of this.nextId) {
            r.unshift(this.chars[char]);
        }
        this.increment();
        return r.join('');
    }
    increment() {
        for (let i = 0; i < this.nextId.length; i++) {
            // eslint-disable-next-line no-plusplus
            const val = ++this.nextId[i];
            if (val >= this.chars.length) {
                this.nextId[i] = 0;
            }
            else {
                return;
            }
        }
        this.nextId.push(0);
    }
    *[Symbol.iterator]() {
        while (true) {
            yield this.next();
        }
    }
}

function getFormulaValueFromNodes(nodes, 
/**
 * Record of [variableId]: elementId
 */
variableToElementRecord, idGenerator) {
    return nodes
        .map(n => {
        if (n.type === 'mentions') {
            const elementId = n.character;
            if (!elementId) {
                return '';
            }
            let variableId;
            // check if element already exists in the variable map
            Object.keys(variableToElementRecord).forEach(key => {
                if (variableToElementRecord[key] === elementId) {
                    variableId = key;
                }
            });
            if (!variableId) {
                variableId = idGenerator.next();
                variableToElementRecord[variableId] = elementId;
            }
            return variableId;
        }
        if (n.children?.length) {
            return getFormulaValueFromNodes(n.children, variableToElementRecord, idGenerator);
        }
        return Node.string(n);
    })
        .join('');
}
function useMathCalc(issuerId, formulaJson) {
    const nodes = useNodesFromJson(formulaJson);
    const elementsSubmissionData = useSubmissionStore(submissionStoreElementsSelector);
    const formData = useSubmissionFormData();
    const elementsConfig = formData.elements;
    const evaluatedResult = useMemo(() => {
        // figureout the formula string
        let formulaString = '';
        const variableToElemMap = {};
        const idGenerator = new StringIdGenerator();
        if (nodes) {
            formulaString = getFormulaValueFromNodes(nodes, variableToElemMap, idGenerator);
        }
        // clean the formula string with known characters only
        // on android slate input seems to catch some weird characters like
        const knownRegExp = /[^A-Za-z 0-9 .,?""!@#$%^&*()\-_=+;:<>/\\|}{[\]`~]*/g;
        formulaString = formulaString.replace(knownRegExp, '');
        // figure out issuer title for better logging
        const issuerTitle = elementsConfig[issuerId]
            ? getStringValueFromJSON(elementsConfig[issuerId].appearance?.title ?? issuerId)
            : issuerId;
        try {
            // now try to parse and evaluate it
            const parser = new Parser();
            const expression = parser.parse(formulaString);
            // iterate over all variables and find out their numeric value
            const evaluatedValue = {};
            Object.keys(variableToElemMap).forEach(varId => {
                // set an initial value
                evaluatedValue[varId] = 0;
                // now actually try to fetch the numeric value from the element
                const elmId = variableToElemMap[varId];
                // if elmId is invalid, then bail
                if (!elmId) {
                    logger.e(`${issuerTitle} :: Invalid element Id "${elmId}" in formula.`);
                    return;
                }
                // if issuer id and elm id is same
                if (elmId === issuerId) {
                    logger.e(`${issuerTitle} :: Math element cannot reference itself in the formula.`);
                    return;
                }
                // get element data and submission data
                const elementData = elementsConfig[elmId];
                const elmSubmissionData = elementsSubmissionData[elmId];
                // if at-least one of them is invalid, then bail
                if (!elementData || !elmSubmissionData) {
                    logger.e(`${issuerTitle} :: Insufficient data for element Id "${elmId}" in formula.`);
                    return;
                }
                // figure out element title for better logging
                const elmTitle = getStringValueFromJSON(elementData.appearance?.title ?? elmId);
                const elmDef = wpEFormElementFrontCollection.hasItem(elementData.type)
                    ? wpEFormElementFrontCollection.getItem(elementData.type)
                    : null;
                // if is not defined, then bail
                if (!elmDef) {
                    logger.e(`${issuerTitle} :: Element not supported for "${elmTitle}" in formula.`);
                    return;
                }
                if (!elmDef.getNumericValue) {
                    logger.e(`${issuerTitle} :: Element does not have numeric value for "${elmTitle}" in formula.`);
                    return;
                }
                // all checks out, now set the value
                evaluatedValue[varId] = elmDef.getNumericValue(elementData, elmSubmissionData.value);
            });
            const result = expression.evaluate(evaluatedValue);
            return result;
        }
        catch (e) {
            logger.e(`${issuerTitle} :: ${e?.message}`);
            return 0;
        }
    }, [elementsConfig, elementsSubmissionData, issuerId, nodes]);
    return evaluatedResult;
}

const mathcalc = {
    id: 'mathcalc',
    hasSubmission: true,
    neededPlan: 'starter',
    FormUi({ elementData, updateSubmissionData, submissionData, presentation }) {
        const evaluatedResult = useMathCalc(elementData.id, elementData.config.mathcalc?.interface?.formula ?? '');
        useEffect(() => {
            const toUpdate = Number.isFinite(evaluatedResult) ? evaluatedResult : 0;
            if (submissionData.value.mathcalc?.output !== toUpdate) {
                updateSubmissionData(produce(submissionData, draftValue => {
                    draftValue.value.mathcalc.output = toUpdate;
                }));
            }
        }, [evaluatedResult, updateSubmissionData, submissionData]);
        const titleNodes = useNodesFromJson(elementData.appearance?.title);
        const prefixNodes = useNodesFromJson(elementData.config.mathcalc?.interface?.prefix);
        const suffixNodes = useNodesFromJson(elementData.config.mathcalc?.interface?.suffix);
        return (jsx(MathOutput, { value: submissionData.value.mathcalc.output, appearance: elementData.config.mathcalc?.interface?.type, label: titleNodes && presentation === 'regular' ? (jsx(SlateViewWithData, { nodes: titleNodes, currentElementId: elementData.id }, void 0)) : null, className: elementData.appearance?.className, decimalSeparator: elementData.config.mathcalc?.interface?.decimalSeparator, precision: elementData.config.mathcalc?.interface?.precision, prefix: prefixNodes ? (jsx(SlateViewWithData, { nodes: prefixNodes, currentElementId: elementData.id }, void 0)) : undefined, suffix: suffixNodes ? (jsx(SlateViewWithData, { nodes: suffixNodes, currentElementId: elementData.id }, void 0)) : undefined, thousandsSeparator: elementData.config.mathcalc?.interface?.thousandsSeparator }, void 0));
    },
    getErrors(elementData, submissionDataValue) {
        return [];
    },
    isQuestion: false,
    isRequired(elementData) {
        return false;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        const numValue = getFloatValue(newValue);
        mutableSubmissionDataValue.mathcalc.output = numValue;
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue) {
        let conditionStatus = false;
        const compareWith = getFloatValue(value, Number.NaN);
        if (Number.isNaN(compareWith)) {
            logger.l(`%c ERROR %c conditional operation on mathcalc assumes numeric value. ${value} given.`, logger.style.error, logger.style.reset);
            return false;
        }
        const selected = submissionDataValue.mathcalc.output;
        if (comparison === EventComparisonEnum.EQUALS_TO) {
            conditionStatus = selected === compareWith;
        }
        else if (comparison === EventComparisonEnum.GREATER_THAN) {
            conditionStatus = selected > compareWith;
        }
        else if (comparison === EventComparisonEnum.LESS_THAN) {
            conditionStatus = selected < compareWith;
        }
        return operation === EventOperationEnum.IS
            ? conditionStatus
            : !conditionStatus;
    },
    getDisplayValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.mathcalc.output;
        return formatNumber(selected, elementData.config.mathcalc?.interface?.precision ?? 2);
    },
    getNumericValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.mathcalc.output;
        return getFloatValue(selected);
    },
    getAnswerValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.mathcalc.output;
        const prefixNodes = getNodesFromJSON(elementData.config.mathcalc?.interface?.prefix);
        const suffixNodes = getNodesFromJSON(elementData.config.mathcalc?.interface?.suffix);
        const formattedOutput = formatNumber(selected, elementData.config.mathcalc?.interface?.precision ?? 2);
        return (jsxs(AnswerPreview.Generic, { children: [jsx(SlateViewWithData, { nodes: prefixNodes, currentElementId: elementData.id }, void 0), formattedOutput, jsx(SlateViewWithData, { nodes: suffixNodes, currentElementId: elementData.id }, void 0)] }, void 0));
    },
    getPresetValue(elementData, defaultValue) {
        const newDefaultValue = produce(defaultValue, draftValue => {
            draftValue.mathcalc.output = 0;
        });
        return newDefaultValue;
    },
};

const mathcalcgroup = {
    id: 'mathcalcgroup',
    hasSubmission: false,
    FormUi({ elementData }) {
        if (elementData.children.length < 1) {
            return (jsx(IconMessage, Object.assign({ icon: jsx(Icon, { iconClass: "fas fa-envelope-open" }, void 0) }, { children: __('This math group is empty.', 'wp-eform') }), void 0));
        }
        return (jsx(MathOutput.Group, { children: elementData.children.map(elmId => (jsx(MemoizedElement, { elmId: elmId, hasGutter: false }, elmId))) }, void 0));
    },
    neededPlan: 'starter',
    getErrors() {
        return [];
    },
    isQuestion: false,
    isRequired() {
        return false;
    },
    setValue() { },
};

function getIsFeedbackVisible(selected, elementData) {
    const isFeedbackEnabled = elementData.config.rating?.interface?.showFeedback;
    if (!isFeedbackEnabled) {
        return false;
    }
    const compareWith = elementData.config.rating.interface.compareWith;
    const feedbackWhen = elementData.config.rating.interface.feedbackWhen;
    let isFeedbackVisible = false;
    switch (feedbackWhen) {
        case NumberComparisonEnum.EQUALS_TO:
            isFeedbackVisible = selected === compareWith;
            break;
        case NumberComparisonEnum.GREATER_THAN:
            isFeedbackVisible = selected > compareWith;
            break;
        case NumberComparisonEnum.LESS_THAN:
            isFeedbackVisible = selected < compareWith;
            break;
        default:
            isFeedbackVisible = false;
    }
    return isFeedbackVisible;
}
function getMaxValue(elementData) {
    // max value is 5 for emojis
    let maxValue = 5;
    if (['star', 'circle', 'customRating'].includes(elementData.config.rating.interface.type)) {
        // for star, circle, and customRating, max value is given by ratingMax
        maxValue = elementData.config.rating.interface.ratingMax;
    }
    else if (elementData.config.rating.interface.type === 'custom') {
        // for custom it is the total number of items in customItems
        maxValue = elementData.config.rating.interface.customItems.length;
    }
    return maxValue;
}
function FeedbackInput(props) {
    const { id, elementData, submissionData, updateSubmissionData } = props;
    const feedbackValue = submissionData.value.rating?.feedback ?? '';
    const isFeedbackVisible = getIsFeedbackVisible(submissionData.value.rating.selected, elementData);
    const placeholderNodes = useNodesFromJson(elementData.config.rating?.interface?.feedbackLabel);
    return (jsx(ControlAddon, Object.assign({ visible: isFeedbackVisible }, { children: jsx(Text, { id: `feedback-${id}`, value: feedbackValue, onChange: newVal => {
                updateSubmissionData(produce(submissionData, draftValue => {
                    draftValue.value.rating.feedback = newVal;
                }));
            }, prefix: jsx(Icon, { iconClass: "fas fa-pen-nib" }, void 0), hasError: isFeedbackVisible &&
                elementData.config.rating?.validation?.required &&
                feedbackValue === '', placeholder: placeholderNodes ? (jsx(SlateViewWithData, { nodes: placeholderNodes, currentElementId: elementData.id }, void 0)) : (__('enter your feedback here', 'wp-eform')) }, void 0) }), void 0));
}
const smileyItems = [
    {
        id: 'angry',
        icon: 'fas fa-angry',
    },
    {
        id: 'frown',
        icon: 'fas fa-frown',
    },
    {
        id: 'meh',
        icon: 'fas fa-meh',
    },
    {
        id: 'smile',
        icon: 'fas fa-smile',
    },
    {
        id: 'grin-hearts',
        icon: 'fas fa-grin-hearts',
    },
];
const rating = {
    id: 'rating',
    hasSubmission: true,
    neededPlan: 'starter',
    FormUi({ elementData, setElementTouched, submissionData, updateSubmissionData, hasError, controlAlignment, id, }) {
        const type = elementData.config.rating.interface.type;
        const ratingMax = elementData.config.rating.interface.ratingMax;
        const customItems = elementData.config.rating.interface.customItems;
        const customRatingIcon = elementData.config.rating.interface.customRatingIcon;
        const ratingItems = useMemo(() => {
            let items;
            let icon = 'fas fa-star';
            switch (type) {
                default:
                case 'star':
                case 'circle':
                case 'customRating':
                    if (type === 'circle') {
                        icon = 'fas fa-dot-circle';
                    }
                    else if (type === 'customRating') {
                        icon = customRatingIcon;
                    }
                    items = Array.from({ length: ratingMax }).map((_, index) => ({
                        id: `index-${index}`,
                        icon,
                    }));
                    break;
                case 'emoji':
                    items = smileyItems;
                    break;
                case 'custom':
                    items = customItems.map(ci => ({ icon: ci.icon, id: ci.itemId }));
                    break;
            }
            return items;
        }, [customItems, customRatingIcon, ratingMax, type]);
        const selected = submissionData.value.rating.selected;
        const isFeedbackRequired = elementData.config.rating?.interface?.showFeedback;
        return (jsxs(Fragment, { children: [jsx(Rating, { items: ratingItems, onChange: newVal => {
                        updateSubmissionData(produce(submissionData, draftValue => {
                            draftValue.value.rating.selected = newVal + 1;
                        }));
                        setElementTouched(true);
                    }, value: selected - 1, controlAlignment: controlAlignment, disabled: elementData.config.rating?.attributes.readonly, className: elementData.appearance?.className, hasError: hasError, id: id, name: id }, void 0), isFeedbackRequired ? (jsx(FeedbackInput, { elementData: elementData, id: id, submissionData: submissionData, updateSubmissionData: updateSubmissionData }, void 0)) : null] }, void 0));
    },
    getErrors(elementData, submissionDataValue) {
        const errors = [];
        const selected = submissionDataValue.rating.selected;
        const max = getMaxValue(elementData);
        const required = !!elementData.config.rating?.validation?.required;
        // if required
        if (required && selected < 1) {
            errors.push(validationMessages.requiredRating);
        }
        // if invalid
        if (selected > max) {
            errors.push(validationMessages.ratingInvariant);
        }
        const isFeedbackVisible = getIsFeedbackVisible(selected, elementData);
        if (required &&
            isFeedbackVisible &&
            !submissionDataValue.rating?.feedback) {
            errors.push(validationMessages.requiredRatingFeedback);
        }
        return errors;
    },
    isQuestion: true,
    isRequired(elementData) {
        return !!elementData.config.rating?.validation?.required;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        const numberValue = getFloatValue(newValue);
        mutableSubmissionDataValue.rating.selected = numberValue;
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue) {
        let conditionStatus = false;
        const compareWith = getFloatValue(value, Number.NaN);
        if (Number.isNaN(compareWith)) {
            logger.e(`conditional operation on rating assumes numeric value. ${value} given.`);
            return false;
        }
        const selected = submissionDataValue.rating.selected;
        if (comparison === EventComparisonEnum.EQUALS_TO) {
            conditionStatus = selected === compareWith;
        }
        else if (comparison === EventComparisonEnum.GREATER_THAN) {
            conditionStatus = selected > compareWith;
        }
        else if (comparison === EventComparisonEnum.LESS_THAN) {
            conditionStatus = selected < compareWith;
        }
        return operation === EventOperationEnum.IS
            ? conditionStatus
            : !conditionStatus;
    },
    getDisplayValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.rating.selected;
        return formatNumber(selected, 0);
    },
    getAnswerValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.rating.selected;
        const isFeedbackVisible = getIsFeedbackVisible(selected, elementData);
        return (jsxs(AnswerPreview.Generic, { children: [jsxs("p", { children: [formatNumber(selected, 0), _x(' / ', 'rating-separator', 'wp-eform'), formatNumber(getMaxValue(elementData), 0)] }, void 0), isFeedbackVisible ? (jsxs(Fragment, { children: [jsx(AnswerPreview.Separator, {}, void 0), jsx(AnswerPreview.UserInput, { children: submissionDataValue.rating.feedback }, void 0)] }, void 0)) : null] }, void 0));
    },
    getNumericValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.rating.selected;
        return selected ?? 0;
    },
    getPresetValue(elementData, defaultValue) {
        const newDefaultValue = produce(defaultValue, draftValue => {
            // If it has a set default value
            if (!isNullOrEmptyString(elementData.config.rating?.attributes.defaultValue)) {
                draftValue.rating.selected = getFloatValue(elementData.config.rating?.attributes.defaultValue);
            }
            // override if URL query parameter is used
            if (elementData.config.rating?.attributes.prefilType === PrefilEnum.URL) {
                draftValue.rating.selected = getFloatValue(getUrlParameterValue(window.location.search, elementData.config.rating.attributes.prefilParameter));
            }
            // override if meta based query is used
            if (elementData.config.rating?.attributes.prefilType === PrefilEnum.META) {
                const decodedExtra = decodeJSONRecord(elementData.extras);
                if (decodedExtra && decodedExtra.metaValue) {
                    // metavalue would be a number
                    const metaValue = decodedExtra.metaValue;
                    if (typeof metaValue === 'number') {
                        draftValue.rating.selected = metaValue;
                    }
                }
            }
            // override to allowed min value
            if (draftValue.rating.selected < 0) {
                draftValue.rating.selected = 0;
            }
        });
        return newDefaultValue;
    },
};

const ratinggroup = {
    id: 'ratinggroup',
    hasSubmission: false,
    FormUi({ elementData }) {
        if (elementData.children.length < 1) {
            return (jsx(IconMessage, Object.assign({ icon: jsx(Icon, { iconClass: "fas fa-envelope-open" }, void 0) }, { children: __('This group is empty.', 'wp-eform') }), void 0));
        }
        return (jsx(ControlGroup, Object.assign({ alignment: elementData.appearance?.controlAlignment, layout: elementData.appearance?.controlLayout }, { children: elementData.children.map(elmId => (jsx(MemoizedElement, { elmId: elmId, hasGutter: false, overrideRender: (title, question, required, containerProps) => (jsxs(ControlGroup.Item, Object.assign({}, containerProps, { children: [jsxs(ControlGroup.Heading, { children: [title, required ? jsx(Question.Asterisk, {}, void 0) : null] }, void 0), jsx(ControlGroup.Control, { children: question }, void 0)] }), void 0)) }, elmId))) }), void 0));
    },
    neededPlan: 'starter',
    getErrors() {
        return [];
    },
    isQuestion: false,
    isRequired() {
        return false;
    },
    setValue() { },
    noGutter: true,
};

const rangegroup = {
    id: 'rangegroup',
    hasSubmission: false,
    FormUi({ elementData }) {
        if (elementData.children.length < 1) {
            return (jsx(IconMessage, Object.assign({ icon: jsx(Icon, { iconClass: "fas fa-envelope-open" }, void 0) }, { children: __('This group is empty.', 'wp-eform') }), void 0));
        }
        return (jsx(ControlGroup, Object.assign({ alignment: elementData.appearance?.controlAlignment, layout: elementData.appearance?.controlLayout }, { children: elementData.children.map(elmId => (jsx(MemoizedElement, { elmId: elmId, hasGutter: false, overrideRender: (title, question, required, containerProps) => (jsxs(ControlGroup.Item, Object.assign({}, containerProps, { children: [jsxs(ControlGroup.Heading, { children: [title, required ? jsx(Question.Asterisk, {}, void 0) : null] }, void 0), jsx(ControlGroup.Control, { children: question }, void 0)] }), void 0)) }, elmId))) }), void 0));
    },
    neededPlan: 'starter',
    getErrors() {
        return [];
    },
    isQuestion: false,
    isRequired() {
        return false;
    },
    setValue() { },
    noGutter: true,
};

const slidergroup = {
    id: 'slidergroup',
    hasSubmission: false,
    FormUi({ elementData }) {
        if (elementData.children.length < 1) {
            return (jsx(IconMessage, Object.assign({ icon: jsx(Icon, { iconClass: "fas fa-envelope-open" }, void 0) }, { children: __('This slider group is empty.', 'wp-eform') }), void 0));
        }
        return (jsx(ControlGroup, Object.assign({ alignment: elementData.appearance?.controlAlignment, layout: elementData.appearance?.controlLayout }, { children: elementData.children.map(elmId => (jsx(MemoizedElement, { elmId: elmId, hasGutter: false, overrideRender: (title, question, required, containerProps) => (jsxs(ControlGroup.Item, Object.assign({}, containerProps, { children: [jsxs(ControlGroup.Heading, { children: [title, required ? jsx(Question.Asterisk, {}, void 0) : null] }, void 0), jsx(ControlGroup.Control, { children: question }, void 0)] }), void 0)) }, elmId))) }), void 0));
    },
    getErrors() {
        return [];
    },
    isQuestion: false,
    isRequired() {
        return false;
    },
    setValue() { },
    noGutter: true,
};

const stackedgroup = {
    id: 'stackedgroup',
    hasSubmission: false,
    FormUi({ elementData }) {
        if (elementData.children.length < 1) {
            return (jsx(IconMessage, Object.assign({ icon: jsx(Icon, { iconClass: "fas fa-envelope-open" }, void 0) }, { children: __('This group is empty.', 'wp-eform') }), void 0));
        }
        return (jsx(ControlGroup, Object.assign({ alignment: elementData.appearance?.controlAlignment, layout: elementData.appearance?.controlLayout }, { children: elementData.children.map(elmId => (jsx(MemoizedElement, { elmId: elmId, hasGutter: false, overrideRender: (title, question, required, containerProps) => (jsxs(ControlGroup.Item, Object.assign({}, containerProps, { children: [jsxs(ControlGroup.Heading, { children: [title, required ? jsx(Question.Asterisk, {}, void 0) : null] }, void 0), jsx(ControlGroup.Control, { children: question }, void 0)] }), void 0)), presentation: "stacked" }, elmId))) }), void 0));
    },
    neededPlan: 'starter',
    getErrors() {
        return [];
    },
    isQuestion: false,
    isRequired() {
        return false;
    },
    setValue() { },
    noGutter: true,
};

var _g;

function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }

function SvgGenericRadioChecked(props) {
  return /*#__PURE__*/React.createElement("svg", _extends$1({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, props), _g || (_g = /*#__PURE__*/React.createElement("g", {
    fillRule: "evenodd"
  }, /*#__PURE__*/React.createElement("path", {
    d: "M32 0c17.673 0 32 14.327 32 32 0 17.673-14.327 32-32 32C14.327 64 0 49.673 0 32 0 14.327 14.327 0 32 0zm0 6C17.64 6 6 17.64 6 32s11.64 26 26 26 26-11.64 26-26S46.36 6 32 6z"
  }), /*#__PURE__*/React.createElement("path", {
    d: "M25.714 47.143c.476 0 .905-.19 1.286-.572l24.571-24.428c.381-.286.572-.667.572-1.143s-.19-.905-.572-1.286l-3.142-3.143c-.381-.38-.81-.571-1.286-.571s-.857.19-1.143.571l-20.286 20-8.428-8.714A2.09 2.09 0 0016 27.43c-.476 0-.857.142-1.143.428l-3.286 3.286A1.358 1.358 0 0011 32.286c0 .476.19.904.571 1.285l13 13c.286.381.667.572 1.143.572z"
  }))));
}

var _path;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function SvgGenericRadioUnchecked(props) {
  return /*#__PURE__*/React.createElement("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 64 64"
  }, props), _path || (_path = /*#__PURE__*/React.createElement("path", {
    fillRule: "evenodd",
    d: "M32 0c17.673 0 32 14.327 32 32 0 17.673-14.327 32-32 32C14.327 64 0 49.673 0 32 0 14.327 14.327 0 32 0zm0 6C17.64 6 6 17.64 6 32s11.64 26 26 26 26-11.64 26-26S46.36 6 32 6z"
  })));
}

function getParsedJsonValue$3(value, config) {
    const matrixValue = [];
    const whiteListedColumns = config.interface?.columns.map(col => col.itemId) ?? [];
    let parsedJson;
    try {
        parsedJson = JSON.parse(typeof value === 'string' ? value : '');
        // verify the parsedJson datastructure
        if (verifyJsonDataStructureForStorage(parsedJson, 'matrixchoicevalue') &&
            Array.isArray(parsedJson.data)) {
            config.interface?.rows.forEach(row => {
                const rowDataInJson = parsedJson.data.find(sr => sr.rowId === row.itemId);
                let columns = rowDataInJson?.columns.filter(col => whiteListedColumns.includes(col)) ?? [];
                if (config.interface?.multiple === false) {
                    columns = columns.length ? [columns[0]] : columns;
                }
                matrixValue.push({
                    rowId: row.itemId,
                    columns,
                });
            });
        }
    }
    catch (e) {
        // do nothing and be happy with the default value
    }
    return matrixValue;
}

const matrixchoice = {
    id: 'matrixchoice',
    hasSubmission: true,
    FormUi({ elementData, id, setElementTouched, submissionData, updateSubmissionData, }) {
        // FS:PREMIUM-ONLY-START
        const columns = useMemo(() => {
            return (elementData.config.matrixchoice?.interface?.columns.map(col => ({
                id: col.itemId,
                title: (jsx(SlateViewWithData, { nodes: getNodesFromJSON(col.label), mode: "singleline", currentElementId: elementData.id }, void 0)),
                width: col.width,
            })) ?? []);
        }, [elementData.id, elementData.config.matrixchoice?.interface?.columns]);
        const rows = useMemo(() => {
            return (elementData.config.matrixchoice?.interface?.rows.map(row => ({
                id: row.itemId,
                title: (jsx(SlateViewWithData, { nodes: getNodesFromJSON(row.label), mode: "singleline", currentElementId: elementData.id }, void 0)),
            })) ?? []);
        }, [elementData.id, elementData.config.matrixchoice?.interface?.rows]);
        if (fsIsPlanOrHigher('starter')) {
            return (jsx(MatrixChoice, { value: submissionData.value.matrixchoice?.selected ?? [], columns: columns, rows: rows, className: elementData.appearance?.className, disabled: elementData.config.matrixchoice?.attributes.readonly, fixedLayout: false, onChange: (rowId, newColumns) => {
                    const newSubmissionData = produce(submissionData, draftValue => {
                        const rowToChange = draftValue.value.matrixchoice.selected.find(rv => rv.rowId === rowId);
                        if (rowToChange) {
                            rowToChange.columns = newColumns;
                        }
                        else {
                            draftValue.value.matrixchoice.selected.push({
                                rowId,
                                columns: newColumns,
                            });
                        }
                    });
                    updateSubmissionData(newSubmissionData);
                }, icon: elementData.config.matrixchoice?.interface?.icon, highlightOnHover: true, multiple: elementData.config.matrixchoice?.interface?.multiple, namePrefix: id, onBlur: () => {
                    setElementTouched(true);
                }, rowHeadingWidth: elementData.config.matrixchoice?.interface?.rowHeadingWidth, tableType: elementData.config.matrixchoice?.interface?.tableType === 'stripped'
                    ? 'stripped'
                    : 'regular' }, void 0));
        }
        // FS:PREMIUM-ONLY-END
        return jsx("p", { children: "Not implemented in current plan" }, void 0);
    },
    getErrors(elementData, submissionDataValue) {
        const isRequired = !!elementData.config.matrixchoice?.validation?.required;
        const allColumns = elementData.config.matrixchoice?.interface?.columns.map(c => c.itemId) ??
            [];
        const selected = submissionDataValue.matrixchoice?.selected ?? [];
        const errors = [];
        if (!isRequired) {
            return errors;
        }
        // it is required, so at-least one value per row is required
        const isValid = elementData.config.matrixchoice?.interface?.rows.every(r => {
            const selectedRowData = selected.find(s => s.rowId === r.itemId);
            if (!selectedRowData) {
                return false;
            }
            return selectedRowData.columns.some(colId => allColumns.includes(colId));
        });
        if (!isValid) {
            errors.push(validationMessages.requiredMatrixChoice);
        }
        return errors;
    },
    isQuestion: true,
    isRequired(elementData) {
        return !!elementData.config.matrixchoice?.validation?.required;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        const parsedValue = getParsedJsonValue$3(newValue, elementData.config.matrixchoice);
        mutableSubmissionDataValue.matrixchoice.selected = parsedValue;
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue, elementData) {
        let conditionStatus = false;
        if (has === EventHasEnum.LENGTH) {
            // length based conditional logic
            const selectedLength = submissionDataValue.matrixchoice?.selected.reduce((acc, rowSelected) => {
                return acc + rowSelected.columns.length;
            }, 0) ?? 0;
            conditionStatus = getLengthComparisonStatus(value, selectedLength, comparison);
        }
        else {
            const parsedValue = getParsedJsonValue$3(value, elementData.config.matrixchoice);
            if (submissionDataValue.matrixchoice?.selected.length === 0) {
                conditionStatus = parsedValue.length === 0 ? true : false;
            }
            else {
                conditionStatus = parsedValue.every(rowInParsed => {
                    const rowSelected = submissionDataValue.matrixchoice?.selected.find(pv => pv.rowId === rowInParsed.rowId);
                    if (!rowSelected) {
                        return rowInParsed.columns.length === 0 ? true : false;
                    }
                    const selectedColumns = rowSelected.columns;
                    const columnsInParsed = rowInParsed.columns;
                    const areColumnsSelected = columnsInParsed.every(colId => selectedColumns.includes(colId));
                    if (comparison === EventComparisonEnum.EQUALS_TO) {
                        return (selectedColumns.length === columnsInParsed.length &&
                            areColumnsSelected);
                    }
                    return (selectedColumns.length >= columnsInParsed.length &&
                        areColumnsSelected);
                });
            }
        }
        return getConditionStatusBasedOnOperation(operation, conditionStatus);
    },
    getDisplayValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.matrixchoice?.selected;
        const rowsLabelMap = {};
        const columnsLabelMap = {};
        elementData.config.matrixchoice?.interface?.rows.forEach(row => {
            rowsLabelMap[row.itemId] = (jsx(SlateViewWithoutMentions, { nodes: getNodesFromJSON(row.label), mode: "singleline" }, void 0));
        });
        elementData.config.matrixchoice?.interface?.columns.forEach(column => {
            columnsLabelMap[column.itemId] = (jsx(SlateViewWithoutMentions, { nodes: getNodesFromJSON(column.label), mode: "singleline" }, void 0));
        });
        return (jsx(Fragment, { children: selected?.map((rowSelected, rowIndex) => (jsxs(React__default.Fragment, { children: [jsxs("strong", { children: [rowsLabelMap[rowSelected.rowId] ?? __('Unknown Row', 'wp-eform'), _x(': ', 'matrixchoice-dislay-heading-separator', 'wp-eform')] }, void 0), rowSelected.columns.map((column, colIndex) => (jsxs(React__default.Fragment, { children: [columnsLabelMap[column] ?? __('Unknown column', 'wp-eform'), colIndex !== rowSelected.columns.length - 1
                                ? _x(', ', 'matrixchoice-column-separator', 'wp-eform')
                                : ''] }, column))), rowIndex !== selected.length - 1
                        ? _x(' | ', 'matrixchoice-row-separator', 'wp-eform')
                        : ''] }, rowSelected.rowId))) }, void 0));
    },
    getNumericValue(elementData, submissionDataValue) {
        const columnsNumMap = {};
        elementData.config.matrixchoice?.interface?.columns.forEach(column => {
            columnsNumMap[column.itemId] = column.num ?? 0;
        });
        return (submissionDataValue.matrixchoice?.selected.reduce((acc, rowSelected) => {
            return (rowSelected.columns.reduce((colAcc, col) => {
                return colAcc + (columnsNumMap[col] ?? 0);
            }, 0) ?? 0);
        }, 0) ?? 0);
    },
    getAnswerValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.matrixchoice?.selected ?? [];
        const checkedIcon = (jsx(Icon, { children: elementData.config.matrixchoice?.interface?.multiple ? (jsx(SvgGenericCheckboxChecked, {}, void 0)) : (jsx(SvgGenericRadioChecked, {}, void 0)) }, void 0));
        const uncheckedIcon = (jsx(Icon, { children: elementData.config.matrixchoice?.interface?.multiple ? (jsx(SvgGenericCheckboxUnchecked, {}, void 0)) : (jsx(SvgGenericRadioUnchecked, {}, void 0)) }, void 0));
        return (jsx(AnswerPreview.Generic, { children: elementData.config.matrixchoice?.interface?.rows.map(row => {
                const rowSelected = selected.find(r => r.rowId === row.itemId);
                return (jsxs(React__default.Fragment, { children: [jsx("h4", { children: jsx(SlateViewWithData, { nodes: getNodesFromJSON(row.label), currentElementId: elementData.id, mode: "singleline" }, void 0) }, void 0), jsx("ul", { children: elementData.config.matrixchoice?.interface?.columns.map(column => (jsxs("li", { children: [rowSelected?.columns.includes(column.itemId)
                                        ? checkedIcon
                                        : uncheckedIcon, ' ', jsx(SlateViewWithData, { nodes: getNodesFromJSON(column.label), currentElementId: elementData.id, mode: "singleline" }, void 0)] }, column.itemId))) }, void 0)] }, row.itemId));
            }) }, void 0));
    },
    getPresetValue(elementData, defaultValue) {
        const defaultData = [];
        elementData.config.matrixchoice?.interface?.rows.forEach(row => {
            defaultData.push({
                rowId: row.itemId,
                columns: [],
            });
        });
        const newDefaultValue = produce(defaultValue, draftValue => {
            // assign the default data
            draftValue.matrixchoice.selected = defaultData;
            // If it has a set default value
            if (!isNullOrEmptyString(elementData.config.matrixchoice?.attributes.defaultValue)) {
                draftValue.matrixchoice.selected = getParsedJsonValue$3(elementData.config.matrixchoice?.attributes.defaultValue, elementData.config.matrixchoice);
            }
        });
        return newDefaultValue;
    },
};

function getParsedJsonValue$2(value, config) {
    let order = config.interface?.items.map(item => item.itemId) ?? [];
    let parsedJson;
    try {
        parsedJson = JSON.parse(typeof value === 'string' ? value : '');
        // verify the parsedJson datastructure
        if (verifyJsonDataStructureForStorage(parsedJson, 'sortablevalue') &&
            Array.isArray(parsedJson.data)) {
            // now make sure the parsed data is valid
            if (order.length === parsedJson.data.length &&
                order.every(item => parsedJson.data.includes(item))) {
                order = parsedJson.data;
            }
        }
    }
    catch (e) {
        // do nothing
    }
    return order;
}

const sortable = {
    id: 'sortable',
    hasSubmission: true,
    FormUi({ elementData, setElementTouched, submissionData, updateSubmissionData, }) {
        const items = useMemo(() => {
            return (elementData.config.sortable?.interface?.items.map(item => ({
                id: item.itemId,
                label: (jsx(SlateViewWithData, { nodes: getNodesFromJSON(item.label), mode: "singleline", currentElementId: elementData.id }, void 0)),
            })) ?? []);
        }, [elementData]);
        // FS:PREMIUM-ONLY-START
        if (fsIsPlanOrHigher('starter')) {
            return (jsx(Sortable, { items: items, currentOrder: submissionData.value.sortable.order, updateOrder: newOrder => {
                    updateSubmissionData(produce(submissionData, draftValue => {
                        draftValue.value.sortable.order = newOrder;
                    }));
                    setElementTouched(true);
                }, className: elementData.appearance?.className, lockVertically: elementData.config.sortable?.interface?.lockVertically }, void 0));
        }
        // FS:PREMIUM-ONLY-END
        return jsx("p", { children: "Not implemented in current plan" }, void 0);
    },
    getErrors(elementData, submissionDataValue) {
        // there can never be any error in sortable element
        return [];
    },
    isQuestion: true,
    isRequired(elementData) {
        return false;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        const parsedValue = getParsedJsonValue$2(newValue, elementData.config.sortable);
        mutableSubmissionDataValue.sortable.order = parsedValue;
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue, elementData) {
        let conditionStatus = false;
        const parsedValue = getParsedJsonValue$2(value, elementData.config.sortable);
        conditionStatus = parsedValue.every((itemId, index) => submissionDataValue.sortable?.order[index] &&
            submissionDataValue.sortable.order[index] === itemId);
        return getConditionStatusBasedOnOperation(operation, conditionStatus);
    },
    getDisplayValue(elementData, submissionDataValue) {
        const itemsLabelMap = {};
        elementData.config.sortable?.interface?.items.forEach(item => {
            itemsLabelMap[item.itemId] = (jsx(SlateViewWithoutMentions, { nodes: getNodesFromJSON(item.label), mode: "singleline" }, void 0));
        });
        const order = submissionDataValue.sortable?.order ?? [];
        return (jsx(Fragment, { children: order.map((itemId, itemIndex) => (jsxs(React__default.Fragment, { children: [itemsLabelMap[itemId] ?? itemId, itemIndex !== order.length - 1
                        ? _x(', ', 'sortable-item-separator', 'wp-eform')
                        : ''] }, itemId))) }, void 0));
    },
    getAnswerValue(elementData, submissionDataValue) {
        const itemsLabelMap = {};
        elementData.config.sortable?.interface?.items.forEach(item => {
            itemsLabelMap[item.itemId] = (jsx(SlateViewWithData, { currentElementId: elementData.id, nodes: getNodesFromJSON(item.label), mode: "singleline" }, void 0));
        });
        const order = submissionDataValue.sortable?.order ?? [];
        return (jsx(AnswerPreview.Generic, { children: jsx("ol", { children: order.map(itemId => (jsx("li", { children: itemsLabelMap[itemId] ?? itemId }, itemId))) }, void 0) }, void 0));
    },
    getPresetValue(elementData, defaultValue) {
        const defaultOrder = elementData.config.sortable?.interface?.items.map(item => item.itemId) ??
            [];
        const newOrder = produce(defaultValue, draftValue => {
            // first add the default order
            if (elementData.config.sortable?.interface?.shuffle) {
                const shuffledOrder = [...defaultOrder];
                shuffleArray(shuffledOrder);
                draftValue.sortable.order = shuffledOrder;
            }
            else {
                draftValue.sortable.order = defaultOrder;
            }
            if (!isNullOrEmptyString(elementData.config.sortable?.attributes.defaultValue)) {
                const givenOrder = getParsedJsonValue$2(elementData.config.sortable?.attributes.defaultValue, elementData.config.sortable);
                // if given order is not equal to the default order, then override
                if (!areArraysEqual(givenOrder, defaultOrder)) {
                    draftValue.sortable.order = givenOrder;
                }
            }
        });
        return newOrder;
    },
};

const wpEFormDateTimeConfigs = new Collections('DateTime Configs', item => {
    return {
        ...item,
        getFormattedValue(dt, pickerType, timeFormat) {
            let format;
            const timeFormatter = timeFormat === '12hrs' ? 'hh:mm:ss A' : 'HH:mm:ss';
            if (pickerType === 'time') {
                format = timeFormatter;
            }
            else if (pickerType === 'datetime') {
                format = `${item.format} ${timeFormatter}`;
            }
            else {
                format = item.format;
            }
            return dt.format(format);
        },
    };
});
wpEFormDateTimeConfigs.addItem('mm/dd/yyyy', {
    format: 'MM/DD/YYYY',
    dateType: 'MMDDYYYY',
    dateSeparator: '/',
    timeSeparator: ':',
});
wpEFormDateTimeConfigs.addItem('mm-dd-yyyy', {
    format: 'MM-DD-YYYY',
    dateType: 'MMDDYYYY',
    dateSeparator: '-',
    timeSeparator: ':',
});
wpEFormDateTimeConfigs.addItem('dd/mm/yyyy', {
    format: 'DD/MM/YYYY',
    dateType: 'DDMMYYYY',
    dateSeparator: '/',
    timeSeparator: ':',
});
wpEFormDateTimeConfigs.addItem('dd-mm-yyyy', {
    format: 'DD-MM-YYYY',
    dateType: 'DDMMYYYY',
    dateSeparator: '-',
    timeSeparator: ':',
});
wpEFormDateTimeConfigs.addItem('yyyy-mm-dd', {
    format: 'YYYY-MM-DD',
    dateType: 'YYYYMMDD',
    dateSeparator: '-',
    timeSeparator: ':',
});
wpEFormDateTimeConfigs.addItem('yyyy/mm/dd', {
    format: 'YYYY/MM/DD',
    dateType: 'YYYYMMDD',
    dateSeparator: '/',
    timeSeparator: ':',
});

const emptyMessages = {
    datetimeInput: __('No user input.', 'wp-eform'),
    matrixInput: __('', 'wp-eform'),
};

// calculate currentTime outside component in module scope
// so it is referenced when the module first loads.
const currentTime = dayjs().set('second', 0).unix();
const datetimeinput = {
    id: 'datetimeinput',
    hasSubmission: true,
    FormUi({ elementData, controlAlignment, hasError, controlType, id, setElementTouched, submissionData, updateSubmissionData, }) {
        const formatType = useMemo(() => {
            let format = elementData.config.datetimeinput?.interface?.format ?? '';
            if (!wpEFormDateTimeConfigs.hasItem(format)) {
                format = 'mm/dd/yyyy';
            }
            return wpEFormDateTimeConfigs.getItem(format);
        }, [elementData]);
        const pickerType = useMemo(() => {
            if (elementData.config.datetimeinput?.interface?.type === 'time') {
                return 'time';
            }
            if (elementData.config.datetimeinput?.interface?.type === 'datetime') {
                return 'datetime';
            }
            return 'date';
        }, [elementData]);
        // FS:PREMIUM-ONLY-START
        if (fsIsPlanOrHigher('starter')) {
            return (jsx(DateTimePicker, { dateTimeFormat: generalDateTimeParseFormat, onChange: nextValue => {
                    updateSubmissionData(produce(submissionData, draftValue => {
                        draftValue.value.datetimeinput.input = nextValue;
                    }));
                }, pickerType: pickerType, value: submissionData.value.datetimeinput.input, className: elementData.appearance?.className, controlAlignment: controlAlignment, controlType: controlType, dateSeparator: formatType.dateSeparator, dateTimeSeparator: elementData.config.datetimeinput?.interface?.dateTimeSeparator, dateType: formatType.dateType, readOnly: elementData.config.datetimeinput?.attributes.readonly, hasError: hasError, id: id, onBlur: () => {
                    setElementTouched(true);
                }, prefix: elementData.config.datetimeinput?.interface?.icon ? (jsx(Icon, { iconClass: elementData.config.datetimeinput.interface.icon }, void 0)) : undefined, showInputLabels: elementData.config.datetimeinput?.interface?.showInputLabels, timeSeparator: formatType.timeSeparator, timeType: elementData.config.datetimeinput?.interface?.timeType === '12hrs'
                    ? '12hrs'
                    : '24hrs', maxValue: parsePossibleDateTimeFormula(elementData.config.datetimeinput?.validation?.maxValue, currentTime), minValue: parsePossibleDateTimeFormula(elementData.config.datetimeinput?.validation?.minValue, currentTime), hideSeconds: elementData.config.datetimeinput?.interface?.hideSeconds }, void 0));
        }
        // FS:PREMIUM-ONLY-END
        return jsx("p", { children: "Not implemented in current plan" }, void 0);
    },
    getErrors(elementData, submissionDataValue) {
        const errors = [];
        // check for required
        const isRequired = !!elementData.config.datetimeinput?.validation?.required;
        const value = parsePossibleMySQLDateTimeString(submissionDataValue.datetimeinput?.input ?? '');
        if (isRequired && !value) {
            errors.push(validationMessages.requiredDateTimeInput);
        }
        // check for sanity
        if (value) {
            const dt = dayjs(value, mysqlFormat);
            if (!dt.isValid()) {
                errors.push(validationMessages.dateTimeInputInvalid);
            }
        }
        let format = elementData.config.datetimeinput?.interface?.format ?? '';
        if (!wpEFormDateTimeConfigs.hasItem(format)) {
            format = 'mm/dd/yyyy';
        }
        const formatItem = wpEFormDateTimeConfigs.getItem(format);
        // Now check for minValue
        const minValue = parsePossibleDateTimeFormula(elementData.config.datetimeinput?.validation?.minValue, currentTime);
        if (minValue && value) {
            const minResult = compareDates(value, minValue);
            if (minResult === -1) {
                errors.push(sprintf(validationMessages.dateTimeInputMustBeLess, formatItem.getFormattedValue(getDayjsFromMySQLInput(minValue), elementData.config.datetimeinput?.interface?.type, elementData.config.datetimeinput?.interface?.timeType)));
            }
        }
        // Check for maxValue
        const maxValue = parsePossibleDateTimeFormula(elementData.config.datetimeinput?.validation?.maxValue, currentTime);
        if (maxValue && value) {
            const maxResult = compareDates(value, maxValue);
            if (maxResult === 1) {
                errors.push(sprintf(validationMessages.dateTimeInputMustBeGreater, formatItem.getFormattedValue(getDayjsFromMySQLInput(maxValue), elementData.config.datetimeinput?.interface?.type, elementData.config.datetimeinput?.interface?.timeType)));
            }
        }
        return errors;
    },
    isQuestion: true,
    isRequired(elementData) {
        return !!elementData.config.datetimeinput?.validation?.required;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        if (newValue) {
            const parsedValue = parsePossibleDateTimeFormula(newValue, currentTime);
            if (parsedValue) {
                mutableSubmissionDataValue.datetimeinput.input = parsedValue;
            }
        }
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue, elementData) {
        let conditionStatus = false;
        // we support numeric comparison only
        const compareTo = parsePossibleDateTimeFormula(value, currentTime);
        const compareWith = parsePossibleMySQLDateTimeString(submissionDataValue.datetimeinput?.input ?? '');
        if (compareTo && compareWith) {
            const diff = compareDates(compareWith, compareTo);
            switch (comparison) {
                default:
                case EventComparisonEnum.EQUALS_TO:
                    conditionStatus = diff === 0;
                    break;
                case EventComparisonEnum.LESS_THAN:
                    conditionStatus = diff === -1;
                    break;
                case EventComparisonEnum.GREATER_THAN:
                    conditionStatus = diff === 1;
                    break;
            }
        }
        return getConditionStatusBasedOnOperation(operation, conditionStatus);
    },
    getDisplayValue(elementData, submissionDataValue) {
        let format = elementData.config.datetimeinput?.interface?.format ?? '';
        if (!wpEFormDateTimeConfigs.hasItem(format)) {
            format = 'mm/dd/yyyy';
        }
        const formatItem = wpEFormDateTimeConfigs.getItem(format);
        const value = parsePossibleMySQLDateTimeString(submissionDataValue.datetimeinput?.input ?? '');
        if (!value) {
            return undefined;
        }
        const dt = dayjs(value, mysqlFormat);
        if (!dt.isValid()) {
            return undefined;
        }
        return formatItem.getFormattedValue(dt, elementData.config.datetimeinput?.interface?.type, elementData.config.datetimeinput?.interface?.timeType);
    },
    getNumericValue(elementData, submissionDataValue) {
        const value = parsePossibleMySQLDateTimeString(submissionDataValue.datetimeinput?.input ?? '');
        if (!value) {
            return currentTime;
        }
        const dt = dayjs(value, mysqlFormat);
        if (!dt.isValid()) {
            return currentTime;
        }
        return dt.unix();
    },
    getAnswerValue(elementData, submissionDataValue) {
        let format = elementData.config.datetimeinput?.interface?.format ?? '';
        if (!wpEFormDateTimeConfigs.hasItem(format)) {
            format = 'mm/dd/yyyy';
        }
        const formatItem = wpEFormDateTimeConfigs.getItem(format);
        const value = parsePossibleMySQLDateTimeString(submissionDataValue.datetimeinput?.input ?? '');
        if (!value) {
            return emptyMessages.datetimeInput;
        }
        const dt = dayjs(value, mysqlFormat);
        if (!dt.isValid()) {
            return emptyMessages.datetimeInput;
        }
        return formatItem.getFormattedValue(dt, elementData.config.datetimeinput?.interface?.type, elementData.config.datetimeinput?.interface?.timeType);
    },
    neededPlan: 'starter',
    getPresetValue(elementData, defaultValue) {
        const newDefaultValue = produce(defaultValue, draftValue => {
            let possibleNewDateTimeValue = '';
            // If it has a set default value
            if (!isNullOrEmptyString(elementData.config.datetimeinput?.attributes.defaultValue)) {
                possibleNewDateTimeValue =
                    elementData.config.datetimeinput.attributes.defaultValue;
            }
            // override if URL query parameter is used
            if (elementData.config.datetimeinput?.attributes.prefilType ===
                PrefilEnum.URL) {
                const urlParameterValue = getUrlParameterValue(window.location.search, elementData.config.datetimeinput.attributes.prefilParameter);
                if (urlParameterValue && typeof urlParameterValue === 'string') {
                    possibleNewDateTimeValue = urlParameterValue;
                }
            }
            // override if meta based query is used
            if (elementData.config.datetimeinput?.attributes.prefilType ===
                PrefilEnum.META) {
                const decodedExtra = decodeJSONRecord(elementData.extras);
                if (decodedExtra &&
                    decodedExtra.metaValue &&
                    typeof decodedExtra.metaValue === 'string') {
                    possibleNewDateTimeValue = decodedExtra.metaValue;
                }
            }
            // finally set
            const parsedNewDateTimeValue = parsePossibleDateTimeFormula(possibleNewDateTimeValue);
            if (parsedNewDateTimeValue) {
                draftValue.datetimeinput.input = parsedNewDateTimeValue;
            }
        });
        return newDefaultValue;
    },
};

function getParsedJsonValue$1(value, config) {
    const matrixValue = [];
    let parsedJson;
    try {
        parsedJson = JSON.parse(typeof value === 'string' ? value : '');
        // verify the parsedJson datastructure
        if (verifyJsonDataStructureForStorage(parsedJson, 'matrixinputvalue') &&
            Array.isArray(parsedJson.data)) {
            config.interface?.rows.forEach(row => {
                config.interface?.columns.forEach(col => {
                    const rowColDataInJson = parsedJson.data.find(d => d.columnId === col.itemId && d.rowId === row.itemId);
                    if (rowColDataInJson) {
                        matrixValue.push(rowColDataInJson);
                    }
                    else {
                        matrixValue.push({
                            rowId: row.itemId,
                            columnId: col.itemId,
                            value: '',
                        });
                    }
                });
            });
        }
    }
    catch (e) {
        // do nothing and be happy with the default value
    }
    return matrixValue;
}

const matrixinput = {
    id: 'matrixinput',
    hasSubmission: true,
    FormUi({ elementData, id, setElementTouched, submissionData, updateSubmissionData, }) {
        // FS:PREMIUM-ONLY-START
        const columns = useMemo(() => {
            return (elementData.config.matrixinput?.interface?.columns.map(col => ({
                id: col.itemId,
                title: (jsx(SlateViewWithData, { nodes: getNodesFromJSON(col.label), mode: "singleline", currentElementId: elementData.id }, void 0)),
                width: col.width,
            })) ?? []);
        }, [elementData.id, elementData.config.matrixinput?.interface?.columns]);
        const rows = useMemo(() => {
            return (elementData.config.matrixinput?.interface?.rows.map(row => ({
                id: row.itemId,
                title: (jsx(SlateViewWithData, { nodes: getNodesFromJSON(row.label), mode: "singleline", currentElementId: elementData.id }, void 0)),
            })) ?? []);
        }, [elementData.id, elementData.config.matrixinput?.interface?.rows]);
        if (fsIsPlanOrHigher('starter')) {
            return (jsx(MatrixInput, { value: submissionData.value.matrixinput?.input ?? [], columns: columns, rows: rows, className: elementData.appearance?.className, disabled: elementData.config.matrixinput?.attributes.readonly, fixedLayout: true, onChange: (rowId, columnId, newVal) => {
                    const newValue = produce(submissionData, draftValue => {
                        const selectedItem = draftValue.value.matrixinput.input.find(df => df.rowId === rowId && df.columnId === columnId);
                        if (selectedItem) {
                            selectedItem.value = newVal;
                        }
                        else {
                            draftValue.value.matrixinput.input.push({
                                rowId,
                                columnId,
                                value: newVal,
                            });
                        }
                    });
                    updateSubmissionData(newValue);
                }, icon: elementData.config.matrixinput?.interface?.icon, highlightOnHover: true, multiline: elementData.config.matrixinput?.interface?.multiline, namePrefix: id, onBlur: () => {
                    setElementTouched(true);
                }, rowHeadingWidth: elementData.config.matrixinput?.interface?.rowHeadingWidth, tableType: elementData.config.matrixinput?.interface?.tableType === 'stripped'
                    ? 'stripped'
                    : 'regular' }, void 0));
        }
        // FS:PREMIUM-ONLY-END
        return jsx("p", { children: "Not implemented in curren tplan." }, void 0);
    },
    getErrors(elementData, submissionDataValue) {
        const isRequired = !!elementData.config.matrixinput?.validation?.required;
        const errors = [];
        if (!isRequired) {
            return errors;
        }
        const isValid = elementData.config.matrixinput?.interface?.rows.every(row => {
            return elementData.config.matrixinput?.interface?.columns.every(col => {
                const rowColVal = submissionDataValue.matrixinput?.input.find(val => val.columnId === col.itemId && val.rowId === row.itemId);
                if (rowColVal && rowColVal.value !== '') {
                    return true;
                }
                return false;
            });
        });
        if (!isValid) {
            errors.push(validationMessages.requiredMatrixInput);
        }
        return errors;
    },
    isQuestion: true,
    isRequired(elementData) {
        return !!elementData.config.matrixinput?.validation?.required;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        const parsedValue = getParsedJsonValue$1(newValue, elementData.config.matrixinput);
        mutableSubmissionDataValue.matrixinput.input = parsedValue;
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue, elementData) {
        let conditionStatus = false;
        if (has === EventHasEnum.LENGTH) {
            const selectedLength = submissionDataValue.matrixinput?.input.reduce((acc, item) => {
                if (item.value !== '') {
                    return acc + 1;
                }
                return acc;
            }, 0) ?? 0;
            conditionStatus = getLengthComparisonStatus(value, selectedLength, comparison);
        }
        else {
            const parsedValue = getParsedJsonValue$1(value, elementData.config.matrixinput);
            if (submissionDataValue.matrixinput?.input.length === 0) {
                conditionStatus = parsedValue.length === 0 ? true : false;
            }
            else {
                conditionStatus = parsedValue.every(itemInParsed => {
                    const itemInSubmission = submissionDataValue.matrixinput?.input.find(v => v.rowId === itemInParsed.rowId &&
                        v.columnId === itemInParsed.columnId);
                    if (!itemInSubmission) {
                        return false;
                    }
                    if (comparison === EventComparisonEnum.EQUALS_TO) {
                        return (itemInParsed.value.toLowerCase() ===
                            itemInSubmission.value.toLowerCase());
                    }
                    return itemInSubmission.value
                        .toLowerCase()
                        .includes(itemInParsed.value.toLowerCase());
                });
            }
        }
        return getConditionStatusBasedOnOperation(operation, conditionStatus);
    },
    getDisplayValue(elementData, submissionDataValue) {
        const rowsLabelMap = {};
        const columnsLabelMap = {};
        elementData.config.matrixinput?.interface?.rows.forEach(row => {
            rowsLabelMap[row.itemId] = (jsx(SlateViewWithoutMentions, { nodes: getNodesFromJSON(row.label), mode: "singleline" }, void 0));
        });
        elementData.config.matrixinput?.interface?.columns.forEach(column => {
            columnsLabelMap[column.itemId] = (jsx(SlateViewWithoutMentions, { nodes: getNodesFromJSON(column.label), mode: "singleline" }, void 0));
        });
        const rowsLength = elementData.config.matrixinput?.interface?.rows.length ?? 0;
        const colsLength = elementData.config.matrixinput?.interface?.columns.length ?? 0;
        return (jsx(Fragment, { children: elementData.config.matrixinput?.interface?.rows.map((row, rowIndex) => (jsx(React__default.Fragment, { children: elementData.config.matrixinput?.interface?.columns.map((column, colIndex) => {
                    const submissionVal = submissionDataValue.matrixinput?.input.find(val => val.rowId === row.itemId &&
                        val.columnId === column.itemId);
                    return (jsxs(React__default.Fragment, { children: [jsxs("strong", { children: [rowsLabelMap[row.itemId] ??
                                        __('Unknown Row', 'wp-eform'), _x(' / ', 'matrixinput-dislay-row-col-separator', 'wp-eform'), columnsLabelMap[column.itemId] ??
                                        __('Unknown column', 'wp-eform'), _x(': ', 'matrixinput-dislay-heading-separator', 'wp-eform')] }, void 0), jsx("span", { children: submissionVal?.value.length
                                    ? submissionVal.value
                                    : _x('', 'matrixinput-display-empty-value', 'wp-eform') }, void 0), rowIndex === rowsLength - 1 &&
                                colIndex === colsLength - 1
                                ? ''
                                : _x(', ', 'matrixinput-row-col-value-separator', 'wp-eform')] }, column.itemId));
                }) }, row.itemId))) }, void 0));
    },
    getNumericValue(elementData, submissionDataValue) {
        return (submissionDataValue.matrixinput?.input.reduce((acc, item) => {
            if (item.value !== '') {
                return acc + getFloatValue(item.value, 0);
            }
            return acc;
        }, 0) ?? 0);
    },
    getAnswerValue(elementData, submissionDataValue) {
        const rowsLabelMap = {};
        const columnsLabelMap = {};
        elementData.config.matrixinput?.interface?.rows.forEach(row => {
            rowsLabelMap[row.itemId] = (jsx(SlateViewWithData, { nodes: getNodesFromJSON(row.label), mode: "singleline", currentElementId: elementData.id }, void 0));
        });
        elementData.config.matrixinput?.interface?.columns.forEach(column => {
            columnsLabelMap[column.itemId] = (jsx(SlateViewWithData, { nodes: getNodesFromJSON(column.label), mode: "singleline", currentElementId: elementData.id }, void 0));
        });
        return (jsx(AnswerPreview.Generic, { children: elementData.config.matrixinput?.interface?.rows.map(row => (jsxs(React__default.Fragment, { children: [jsx("h4", { children: rowsLabelMap[row.itemId] ?? __('Unknown row', 'wp-eform') }, void 0), elementData.config.matrixinput?.interface?.columns.map(column => (jsxs(React__default.Fragment, { children: [jsx("h5", { children: columnsLabelMap[column.itemId] ??
                                    __('Unknown column', 'wp-eform') }, void 0), jsx("p", { children: submissionDataValue.matrixinput?.input.find(val => val.columnId === column.itemId && val.rowId === row.itemId)?.value ?? emptyMessages.matrixInput }, void 0)] }, column.itemId)))] }, row.itemId))) }, void 0));
    },
    getPresetValue(elementData, defaultValue) {
        const defaultData = [];
        elementData.config.matrixinput?.interface?.rows.forEach(row => {
            elementData.config.matrixinput?.interface?.columns.forEach(column => {
                defaultData.push({
                    rowId: row.itemId,
                    columnId: column.itemId,
                    value: '',
                });
            });
        });
        const newDefaultValue = produce(defaultValue, draftValue => {
            // assign the default data
            draftValue.matrixinput.input = defaultData;
            // If it has a set default value
            if (!isNullOrEmptyString(elementData.config.matrixinput?.attributes.defaultValue)) {
                draftValue.matrixinput.input = getParsedJsonValue$1(elementData.config.matrixinput?.attributes.defaultValue, elementData.config.matrixinput);
            }
        });
        return newDefaultValue;
    },
};

const COUNTRIES_DATASET = gql `
	query CountriesDataSet {
		dataSetAllItems(dataSetId: "country") {
			id
			label
			decoration
		}
	}
`;
const STATES_DATASET = gql `
	query StatesDataSet($countryId: ID!) {
		dataSetItem(dataSetId: "country", itemId: $countryId) {
			id
			extras
		}
	}
`;
function AddressWithDataSet(props) {
    const { fields, restrictCountries, onSelectCountry, ...addressProps } = props;
    const { data: countriesData, loading: countriesLoading, error: countriesError, } = useQuery(COUNTRIES_DATASET);
    const [queryState, { data: statesData, loading: statesLoading, error: statesError },] = useLazyQuery(STATES_DATASET);
    const initialStatesLoaded = useRef(false);
    useEffect(() => {
        // bail if initial one is loaded
        if (initialStatesLoaded.current) {
            return;
        }
        // load only if country is not empty
        if (fields.country !== '' && countriesData) {
            const countryData = countriesData?.dataSetAllItems.find(c => c.label === fields.country);
            if (countryData) {
                queryState({ variables: { countryId: countryData.id } });
            }
            initialStatesLoaded.current = true;
        }
    }, [countriesData, fields.country, queryState]);
    const countries = useMemo(() => {
        let countriesList = [];
        if (countriesData) {
            countriesData.dataSetAllItems.forEach(cd => {
                const decoration = JSON.parse(cd.decoration ?? '');
                countriesList.push({
                    icon: decoration?.emoji,
                    id: cd.id,
                    label: cd.label,
                    plain: cd.label,
                    // direct label goes for storage
                    value: cd.label,
                });
            });
        }
        if (restrictCountries && restrictCountries.length) {
            countriesList = countriesList.filter(cd => restrictCountries.includes(cd.id));
        }
        return countriesList;
    }, [countriesData, restrictCountries]);
    const states = useMemo(() => {
        const statesList = [];
        if (fields.country !== '' && statesData && !statesLoading && !statesError) {
            const statesJson = JSON.parse(statesData.dataSetItem?.extras ?? '');
            if (statesJson && Array.isArray(statesJson?.states)) {
                statesJson.states.forEach((st) => {
                    statesList.push({
                        id: st.id,
                        label: st.name,
                        plain: st.name,
                        value: st.name,
                    });
                });
            }
        }
        return statesList;
    }, [fields.country, statesData, statesError, statesLoading]);
    return (jsx(Address, Object.assign({}, addressProps, { fields: fields, countries: countries, countriesLoading: countriesLoading, countriesError: !!countriesError, states: states, statesLoading: statesLoading, statesError: !!statesError, onSelectCountry: country => {
            // find the country id by label
            const countryData = countriesData?.dataSetAllItems.find(c => c.label === country);
            if (countryData) {
                queryState({ variables: { countryId: countryData.id } });
            }
            onSelectCountry?.(country);
        } }), void 0));
}

function getParsedJsonValue(value, config) {
    const addressFields = {
        city: '',
        country: '',
        fieldOne: '',
        fieldTwo: '',
        state: '',
        zip: '',
    };
    let parsedJson;
    try {
        parsedJson = JSON.parse(typeof value === 'string' ? value : '');
        // verify the parsedJson datastructure
        if (verifyJsonDataStructureForStorage(parsedJson, 'addressvalue') &&
            typeof parsedJson.data === 'object') {
            // now make sure the parsed data is valid
            addressFieldsInOrder.forEach(key => {
                if (typeof parsedJson.data[key] === 'string') {
                    addressFields[key] = parsedJson.data[key];
                }
            });
        }
    }
    catch (e) {
        // do nothing
    }
    return addressFields;
}
function getAddressConfigurationFromElementConfig(config) {
    const configuration = {
        fieldOne: {
            enabled: !!config.interface?.fieldOne,
            placeholder: config.interface?.fieldOnePlaceholder,
        },
        fieldTwo: {
            enabled: !!config.interface?.fieldTwo,
            placeholder: config.interface?.fieldTwoPlaceholder,
        },
        country: {
            enabled: !!config.interface?.showCountry,
            placeholder: config.interface?.countryPlaceholder,
        },
        state: {
            enabled: !!config.interface?.showState,
            placeholder: config.interface?.statePlaceholder,
        },
        city: {
            enabled: !!config.interface?.showCity,
            placeholder: config.interface?.cityPlaceholder,
        },
        zip: {
            enabled: !!config.interface?.showZip,
            placeholder: config.interface?.zipPlaceholder,
        },
    };
    return configuration;
}
function getEnabledFields(config) {
    return addressFieldsInOrder.filter(field => {
        switch (field) {
            case 'city':
                return !!config.interface?.showCity;
            case 'country':
                return !!config.interface?.showCountry;
            case 'fieldOne':
                return !!config.interface?.fieldOne;
            case 'fieldTwo':
                return !!config.interface?.fieldTwo;
            case 'state':
                return !!config.interface?.showState;
            case 'zip':
                return !!config.interface?.showZip;
            default:
                return false;
        }
    });
}

const address = {
    id: 'address',
    hasSubmission: true,
    FormUi({ elementData, setElementTouched, submissionData, updateSubmissionData, id, controlAlignment, controlType, hasError, }) {
        const configuration = useMemo(() => getAddressConfigurationFromElementConfig(elementData.config.address), [elementData.config.address]);
        return (jsx(AddressWithDataSet, { fields: submissionData.value.address, configuration: configuration, updateField: newValue => {
                updateSubmissionData({
                    ...submissionData,
                    value: {
                        ...submissionData.value,
                        address: {
                            ...submissionData.value.address,
                            ...newValue,
                        },
                    },
                });
            }, className: elementData.appearance?.className, controlAlignment: controlAlignment, controlType: controlType, disableAllIcons: elementData.config.address?.interface?.disableIcons, hasError: hasError, id: id, name: id, restrictCountries: elementData.config.address?.interface?.restrictCountries, readOnly: elementData.config.address?.attributes.readonly, onBlur: () => {
                setElementTouched(true);
            } }, void 0));
    },
    getErrors(elementData, submissionDataValue) {
        const isRequired = elementData.config.address?.validation?.required;
        if (!isRequired) {
            return [];
        }
        const isValid = getEnabledFields(elementData.config.address)
            .filter(f => f !== 'fieldTwo')
            .every(field => !!submissionDataValue.address?.[field]);
        if (isValid) {
            return [];
        }
        return [validationMessages.requiredAddress];
    },
    isQuestion: true,
    isRequired(elementData) {
        return !!elementData.config.address?.validation?.required;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        const parsedValue = getParsedJsonValue(newValue, elementData.config.address);
        mutableSubmissionDataValue.address = parsedValue;
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue, elementData) {
        let conditionStatus = false;
        const parsedValue = getParsedJsonValue(value, elementData.config.address);
        const fieldsValidationStatus = [];
        getEnabledFields(elementData.config.address).forEach(field => {
            // dont do any comparison if parsed value has empty string
            if (parsedValue[field] === '') {
                return;
            }
            if (comparison === EventComparisonEnum.EQUALS_TO) {
                fieldsValidationStatus.push(submissionDataValue.address?.[field].toLowerCase() ===
                    parsedValue[field].toLowerCase());
            }
            else {
                fieldsValidationStatus.push(!!submissionDataValue.address?.[field]
                    .toLowerCase()
                    .includes(parsedValue[field].toLowerCase()));
            }
        });
        if (comparison === EventComparisonEnum.EQUALS_TO) {
            conditionStatus = fieldsValidationStatus.every(item => item === true);
        }
        else {
            conditionStatus = fieldsValidationStatus.some(item => item === true);
        }
        return getConditionStatusBasedOnOperation(operation, conditionStatus);
    },
    getDisplayValue(elementData, submissionDataValue) {
        const configuration = getAddressConfigurationFromElementConfig(elementData.config.address);
        const renders = addressFieldsInOrder.map(field => ({
            field,
            children: (jsx(Fragment$1, { children: configuration[field].enabled ? (jsxs(Fragment, { children: [configuration[field].placeholder ?? field, ' ', submissionDataValue.address?.[field]] }, void 0)) : null }, field)),
        }));
        return (jsx(Fragment, { children: renders.map((item, index) => (jsxs(Fragment$1, { children: [item.children, index !== renders.length - 1
                        ? _x(', ', 'address-item-separator', 'wp-eform')
                        : ''] }, item.field))) }, void 0));
    },
    getAnswerValue(elementData, submissionDataValue) {
        const configuration = getAddressConfigurationFromElementConfig(elementData.config.address);
        return (jsx(AnswerPreview.Generic, { children: addressFieldsInOrder.map(field => (jsx(Fragment$1, { children: configuration[field].enabled ? (jsxs("p", { children: [jsx("strong", { children: configuration[field].placeholder ?? field }, void 0), jsx("br", {}, void 0), submissionDataValue.address?.[field]] }, void 0)) : null }, field))) }, void 0));
    },
    getPresetValue(elementData, defaultValue) {
        const newValue = produce(defaultValue, draftValue => {
            // see if default is present
            if (!isNullOrEmptyString(elementData.config.address?.attributes.defaultValue)) {
                const parsedValue = getParsedJsonValue(elementData.config.address?.attributes.defaultValue, elementData.config.address);
                draftValue.address = parsedValue;
            }
            // see if URL parameter is present
            if (elementData.config.address?.attributes.prefilType === PrefilEnum.URL) {
                addressFieldsInOrder.forEach(field => {
                    const urlParamValue = getUrlParameterValue(window.location.search, `${elementData.config.address.attributes.prefilParameter}${field}`);
                    if (urlParamValue && typeof urlParamValue === 'string') {
                        draftValue.address[field] = urlParamValue;
                    }
                });
            }
            // finally override with user meta
            if (elementData.config.address?.attributes.prefilType === PrefilEnum.META) {
                const decodedExtra = decodeJSONRecord(elementData.extras);
                if (decodedExtra &&
                    decodedExtra.metaValue &&
                    typeof decodedExtra.metaValue === 'object') {
                    draftValue.address.city =
                        decodedExtra.metaValue.city ?? defaultValue.address?.city;
                    draftValue.address.country =
                        decodedExtra.metaValue.country ?? defaultValue.address?.country;
                    draftValue.address.fieldOne =
                        decodedExtra.metaValue.fieldOne ?? defaultValue.address?.fieldOne;
                    draftValue.address.fieldTwo =
                        decodedExtra.metaValue.fieldTwo ?? defaultValue.address?.fieldTwo;
                    draftValue.address.state =
                        decodedExtra.metaValue.state ?? defaultValue.address?.state;
                    draftValue.address.zip =
                        decodedExtra.metaValue.zip ?? defaultValue.address?.zip;
                }
            }
        });
        return newValue;
    },
};

const toggle = {
    id: 'toggle',
    hasSubmission: true,
    neededPlan: 'starter',
    FormUi({ elementData, id, setElementTouched, submissionData, updateSubmissionData, controlAlignment, hasError, }) {
        // FS:PREMIUM-ONLY-START
        if (fsIsPlanOrHigher('starter')) {
            return (jsx(Toggle, { id: id, onChange: val => {
                    updateSubmissionData(produce(submissionData, draftState => {
                        draftState.value.toggle.selected = val;
                    }));
                    setElementTouched(true);
                }, value: submissionData.value.toggle.selected, activeIcon: elementData.config.toggle?.interface?.activeIcon, inactiveIcon: elementData.config.toggle?.interface?.inactiveIcon, hasError: hasError, disabled: elementData.config.toggle?.attributes.readonly, label: jsx(SlateViewWithData, { mode: "singleline", nodes: getNodesFromJSON(elementData.appearance?.title), currentElementId: elementData.id }, void 0), controlAlignment: controlAlignment, name: id, className: elementData.appearance?.className, onBlur: () => {
                    setElementTouched(true);
                } }, void 0));
        }
        // FS:PREMIUM-ONLY-END
        return jsx("p", { children: "Not implemented." }, void 0);
    },
    getErrors(elementData, submissionDataValue) {
        const errors = [];
        const isRequired = !!elementData.config.toggle?.validation?.required;
        // if this is required
        if (isRequired && !submissionDataValue.toggle?.selected) {
            errors.push(validationMessages.requiredToggle);
        }
        return errors;
    },
    isQuestion: true,
    isQuestionTitleHidden: true,
    isRequired(elementData) {
        return !!elementData.config.toggle?.validation?.required;
    },
    setValue(newValue, elementData, mutableSubmissionDataValue) {
        if (newValue === 'true') {
            mutableSubmissionDataValue.toggle.selected = true;
        }
        else {
            mutableSubmissionDataValue.toggle.selected = false;
        }
    },
    isConditionTrue(has, operation, comparison, value, submissionDataValue) {
        let conditionStatus = false;
        const compareWith = value === 'true';
        // only EQUALS_TO is supported
        if (comparison === EventComparisonEnum.EQUALS_TO) {
            conditionStatus = compareWith === submissionDataValue.toggle.selected;
        }
        return operation === EventOperationEnum.IS
            ? conditionStatus
            : !conditionStatus;
    },
    getDisplayValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.toggle.selected;
        if (selected) {
            return (jsx(SlateViewWithoutMentions, { mode: "singleline", nodes: getNodesFromJSON(elementData.config.toggle?.interface?.activeLabel ??
                    __('Yes', 'wp-eform')) }, void 0));
        }
        return (jsx(SlateViewWithoutMentions, { mode: "singleline", nodes: getNodesFromJSON(elementData.config.toggle?.interface?.inactiveLabel ??
                __('No', 'wp-eform')) }, void 0));
    },
    getNumericValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.toggle.selected;
        return selected ? 1 : 0;
    },
    getAnswerValue(elementData, submissionDataValue) {
        const selected = submissionDataValue.toggle.selected;
        if (selected) {
            return (jsx(SlateViewWithData, { currentElementId: elementData.id, mode: "singleline", nodes: getNodesFromJSON(elementData.config.toggle?.interface?.activeLabel ??
                    __('Yes', 'wp-eform')) }, void 0));
        }
        return (jsx(SlateViewWithData, { currentElementId: elementData.id, mode: "singleline", nodes: getNodesFromJSON(elementData.config.toggle?.interface?.inactiveLabel ??
                __('No', 'wp-eform')) }, void 0));
    },
    getPresetValue(elementData, defaultValue) {
        const newDefaultValue = produce(defaultValue, draftValue => {
            // If it has a set default value
            if (!isNullOrEmptyString(elementData.config.toggle?.attributes.defaultValue)) {
                draftValue.toggle.selected =
                    elementData.config.toggle.attributes.defaultValue === 'true';
            }
            // override if URL query parameter is used
            if (elementData.config.toggle?.attributes.prefilType === PrefilEnum.URL) {
                const compareWith = getUrlParameterValue(window.location.search, elementData.config.toggle.attributes.prefilParameter);
                if (compareWith === 'true') {
                    draftValue.toggle.selected = true;
                }
                else if (compareWith === 'false') {
                    draftValue.toggle.selected = false;
                }
            }
            // override if meta based query is used
            if (elementData.config.toggle?.attributes.prefilType === PrefilEnum.META) {
                const decodedExtra = decodeJSONRecord(elementData.extras);
                if (decodedExtra && decodedExtra.metaValue) {
                    // metaValue would be a boolean
                    const metaValue = decodedExtra.metaValue;
                    if (typeof metaValue === 'boolean') {
                        draftValue.toggle.selected = metaValue;
                    }
                }
            }
        });
        return newDefaultValue;
    },
};

// This file contains all pro related imports and codes
wpEFormElementFrontCollection.addItem(range.id, range);
wpEFormElementFrontCollection.addItem(mathcalc.id, mathcalc);
wpEFormElementFrontCollection.addItem(mathcalcgroup.id, mathcalcgroup);
wpEFormElementFrontCollection.addItem(rating.id, rating);
wpEFormElementFrontCollection.addItem(ratinggroup.id, ratinggroup);
wpEFormElementFrontCollection.addItem(rangegroup.id, rangegroup);
wpEFormElementFrontCollection.addItem(slidergroup.id, slidergroup);
wpEFormElementFrontCollection.addItem(stackedgroup.id, stackedgroup);
wpEFormElementFrontCollection.addItem(matrixchoice.id, matrixchoice);
wpEFormElementFrontCollection.addItem(sortable.id, sortable);
wpEFormElementFrontCollection.addItem(datetimeinput.id, datetimeinput);
wpEFormElementFrontCollection.addItem(matrixinput.id, matrixinput);
wpEFormElementFrontCollection.addItem(address.id, address);
wpEFormElementFrontCollection.addItem(toggle.id, toggle);

// palette 1
const premCyan = makeTheme({
    primary: {
        '050': '#E0FCFF',
        '100': '#BEF8FD',
        '200': '#87EAF2',
        '300': '#54D1DB',
        '400': '#38BEC9',
        '500': '#2CB1BC',
        '600': '#14919B',
        '700': '#0E7C86',
        '800': '#0A6C74',
        '900': '#044E54',
    },
    neutrals: {
        '050': '#F0F4F8',
        '100': '#D9E2EC',
        '200': '#BCCCDC',
        '300': '#9FB3C8',
        '400': '#829AB1',
        '500': '#627D98',
        '600': '#486581',
        '700': '#334E68',
        '800': '#243B53',
        '900': '#102A43',
    },
    accent: {
        '700': '#35469C',
    },
});
// palette 2
const premBlue = makeTheme({
    primary: {
        '050': '#DCEEFB',
        '100': '#B6E0FE',
        '200': '#84C5F4',
        '300': '#62B0E8',
        '400': '#4098D7',
        '500': '#2680C2',
        '600': '#186FAF',
        '700': '#0F609B',
        '800': '#0A558C',
        '900': '#003E6B',
    },
    neutrals: {
        '050': '#F0F4F8',
        '100': '#D9E2EC',
        '200': '#BCCCDC',
        '300': '#9FB3C8',
        '400': '#829AB1',
        '500': '#627D98',
        '600': '#486581',
        '700': '#334E68',
        '800': '#243B53',
        '900': '#102A43',
    },
    accent: {
        '700': '#CB6E17',
    },
});
// palette 3
const premPurple = makeTheme({
    primary: {
        '050': '#E6E6FF',
        '100': '#C4C6FF',
        '200': '#A2A5FC',
        '300': '#8888FC',
        '400': '#7069FA',
        '500': '#5D55FA',
        '600': '#4D3DF7',
        '700': '#3525E6',
        '800': '#1D0EBE',
        '900': '#0C008C',
    },
    neutrals: {
        '050': '#F0F4F8',
        '100': '#D9E2EC',
        '200': '#BCCCDC',
        '300': '#9FB3C8',
        '400': '#829AB1',
        '500': '#627D98',
        '600': '#486581',
        '700': '#334E68',
        '800': '#243B53',
        '900': '#102A43',
    },
    accent: {
        '700': '#147D64',
    },
});
// palette 4
const premCyanTwo = makeTheme({
    primary: {
        '050': '#EFFCF6',
        '100': '#C6F7E2',
        '200': '#8EEDC7',
        '300': '#65D6AD',
        '400': '#3EBD93',
        '500': '#27AB83',
        '600': '#199473',
        '700': '#147D64',
        '800': '#0C6B58',
        '900': '#014D40',
    },
    neutrals: {
        '050': '#F0F4F8',
        '100': '#D9E2EC',
        '200': '#BCCCDC',
        '300': '#9FB3C8',
        '400': '#829AB1',
        '500': '#627D98',
        '600': '#486581',
        '700': '#334E68',
        '800': '#243B53',
        '900': '#102A43',
    },
    accent: {
        '700': '#0F609B',
    },
});
// palette 5
const premBlueGrey = makeTheme({
    primary: {
        '050': '#F0F4F8',
        '100': '#D9E2EC',
        '200': '#BCCCDC',
        '300': '#9FB3C8',
        '400': '#829AB1',
        '500': '#627D98',
        '600': '#486581',
        '700': '#334E68',
        '800': '#243B53',
        '900': '#102A43',
    },
    accent: {
        '700': '#127FBF',
    },
});
// palette 6
const premRed = makeTheme({
    primary: {
        '050': '#FFEEEE',
        '100': '#FACDCD',
        '200': '#F29B9B',
        '300': '#E66A6A',
        '400': '#D64545',
        '500': '#BA2525',
        '600': '#A61B1B',
        '700': '#911111',
        '800': '#780A0A',
        '900': '#610404',
    },
    neutrals: {
        '050': '#FAF9F7',
        '100': '#E8E6E1',
        '200': '#D3CEC4',
        '300': '#B8B2A7',
        '400': '#A39E93',
        '500': '#857F72',
        '600': '#625D52',
        '700': '#504A40',
        '800': '#423D33',
        '900': '#27241D',
    },
    accent: {
        '700': '#CB6E17',
    },
});
// palette 7
const premCyanThree = makeTheme({
    primary: {
        '050': '#E0FCFF',
        '100': '#BEF8FD',
        '200': '#87EAF2',
        '300': '#54D1DB',
        '400': '#38BEC9',
        '500': '#2CB1BC',
        '600': '#14919B',
        '700': '#0E7C86',
        '800': '#0A6C74',
        '900': '#044E54',
    },
    neutrals: {
        '050': '#FAF9F7',
        '100': '#E8E6E1',
        '200': '#D3CEC4',
        '300': '#B8B2A7',
        '400': '#A39E93',
        '500': '#857F72',
        '600': '#625D52',
        '700': '#504A40',
        '800': '#423D33',
        '900': '#27241D',
    },
    accent: {
        '700': '#0F609B',
    },
});
// palette 9 (8 is vivid blue)
const premLightBlue = makeTheme({
    primary: {
        '050': '#E3F8FF',
        '100': '#B3ECFF',
        '200': '#81DEFD',
        '300': '#5ED0FA',
        '400': '#40C3F7',
        '500': '#2BB0ED',
        '600': '#1992D4',
        '700': '#127FBF',
        '800': '#0B69A3',
        '900': '#035388',
    },
    neutrals: {
        '050': '#F5F7FA',
        '100': '#E4E7EB',
        '200': '#CBD2D9',
        '300': '#9AA5B1',
        '400': '#7B8794',
        '500': '#616E7C',
        '600': '#52606D',
        '700': '#3E4C59',
        '800': '#323F4B',
        '900': '#1F2933',
    },
    accent: {
        '700': '#A30664',
    },
});
// palette 10
const premIndigo = makeTheme({
    primary: {
        '050': '#E0E8F9',
        '100': '#BED0F7',
        '200': '#98AEEB',
        '300': '#7B93DB',
        '400': '#647ACB',
        '500': '#4C63B6',
        '600': '#4055A8',
        '700': '#35469C',
        '800': '#2D3A8C',
        '900': '#19216C',
    },
    neutrals: {
        '050': '#F5F7FA',
        '100': '#E4E7EB',
        '200': '#CBD2D9',
        '300': '#9AA5B1',
        '400': '#7B8794',
        '500': '#616E7C',
        '600': '#52606D',
        '700': '#3E4C59',
        '800': '#323F4B',
        '900': '#1F2933',
    },
    accent: {
        '700': '#127FBF',
    },
});
// palette 11
const premPink = makeTheme({
    primary: {
        '050': '#FFE3EC',
        '100': '#FFB8D2',
        '200': '#FF8CBA',
        '300': '#F364A2',
        '400': '#E8368F',
        '500': '#DA127D',
        '600': '#BC0A6F',
        '700': '#A30664',
        '800': '#870557',
        '900': '#620042',
    },
    neutrals: {
        '050': '#F5F7FA',
        '100': '#E4E7EB',
        '200': '#CBD2D9',
        '300': '#9AA5B1',
        '400': '#7B8794',
        '500': '#616E7C',
        '600': '#52606D',
        '700': '#3E4C59',
        '800': '#323F4B',
        '900': '#1F2933',
    },
    accent: {
        '700': '#690CB0',
    },
});

wpEFormThemes.addItem('premcyanthree', {
    config: premCyanThree,
    name: 'Premium Cyan Three',
}, 1);
wpEFormThemes.addItem('premcyantwo', {
    config: premCyanTwo,
    name: 'Premium Cyan Two',
}, 1);
wpEFormThemes.addItem('prempink', { config: premPink, name: 'Premium Pink' });
wpEFormThemes.addItem('prempurple', {
    config: premPurple,
    name: 'Premium Purple',
}, 1);
wpEFormThemes.addItem('premred', { config: premRed, name: 'Premium Red' }, 1);
wpEFormThemes.addItem('premblue', { config: premBlue, name: 'Premium Blue' }, 1);
wpEFormThemes.addItem('prembluegrey', {
    config: premBlueGrey,
    name: 'Premium Blue Grey',
});
wpEFormThemes.addItem('premcyan', { config: premCyan, name: 'Premium Cyan' }, 1);
wpEFormThemes.addItem('premindigo', {
    config: premIndigo,
    name: 'Premium Indigo',
}, 1);
wpEFormThemes.addItem('premlightblue', {
    config: premLightBlue,
    name: 'Premium Light Blue',
}, 1);

library.add(fab, fas, far);
function Form(props) {
    const { overrideDarkMode, 
    // default increaseViewCount to true because these libraries are in
    // headless mode
    increaseViewCount = true, ...networkFormProps } = props;
    return (jsx(OverrideDarkModeProvider, Object.assign({ darkMode: overrideDarkMode }, { children: jsx(ApolloProvider, Object.assign({ client: apolloClient }, { children: jsx(NetworkForm, Object.assign({}, networkFormProps, { increaseViewCount: increaseViewCount }), void 0) }), void 0) }), void 0));
}

export { Form as F, apolloClient as a };
