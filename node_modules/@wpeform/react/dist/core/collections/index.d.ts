/**
 * Determine whether an item is acceptable based on list of accepted and
 * unaccepted. This is used to determine element position acceptance at many
 * places.
 *
 * Most importantly, the logic resembles exactly that of PHP GraphQL API.
 *
 * @param item The item to determine.
 * @param accepted List of accepted items.
 * @param unaccepted List of unaccepted items.
 */
export declare function isAcceptable(item: string, accepted?: string[], unaccepted?: string[]): boolean;
declare type CollectorFnType<T extends K, K extends Record<string, any> = T> = (item: K) => T;
/**
 * A class to maintain collections in the same order as they are added.
 */
export declare class Collections<T extends K, K extends Record<string, any> = T> {
    /**
     * Dictionary of collections
     */
    private collections;
    private collectionOrder;
    /**
     * Name of the collection
     */
    private name;
    private changeCallbacks;
    /**
     * A collector function which runs on the given item.
     */
    private collector;
    constructor(name: string, collector?: CollectorFnType<T, K> | null);
    /**
     * Subscribe to changes called through replaceItem.
     *
     * @param callback Callback to execute.
     * @returns Id of the subscription, use it to unsubscribe.
     */
    subscribeToChanges(callback: (itemId: string) => void): string;
    unsubscribeFromChanges(id: string): void;
    addItem(id: string, item: K, order?: number): void;
    replaceItem(id: string, item: T): void;
    addWithoutCollector(id: string, item: T): void;
    getItem(id: string): T;
    hasItem(id: string): boolean;
    deleteItem(id: string): void;
    getItems(accepted?: string[], unaccepted?: string[], filterFn?: (item: T, name: string) => boolean): {
        id: string;
        item: T;
    }[];
    resetItems(): void;
}
export {};
