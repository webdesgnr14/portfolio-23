import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import * as React from 'react';
import React__default, { useRef, useLayoutEffect, useState, useEffect, useCallback, useMemo, createElement } from 'react';
import styled, { useTheme, keyframes } from 'styled-components';
import { animated, useTrail, useSpring } from '@react-spring/web';
import { Q as getBemClassName, ai as getBemElement, aj as cssReset, aS as useResponsiveClassNames, af as useContainerSize, aT as _default, aU as scrollParents, X as numToCssSize, aV as proseCss, Z as getMultipleTransitionsWithWillChange, t as SettingsAppearanceControlLayoutEnum, s as SettingsAppearanceControlAlignmentEnum, aL as useTimerCountDown, aW as getHoursMinutesSeconds, ab as sprintf, aX as _n, aY as useClampedSpringConfig, aZ as formatNumber, L as curriedLighten, a_ as scrollBarHorizontalCss, Y as curriedTransparentize, v as SettingsAppearanceProgressBarPositionEnum, a$ as componentSize, a3 as Icon, aa as classNames, a5 as _x, b0 as dayjs, _ as __, $ as useRipple, r as SettingsAppearanceContainerLayoutEnum, aE as ResponsiveContainer, b1 as curriedDarken, b2 as textEllipsisCss, b3 as CONTROLCLASS$g, W as WidthPresetsEnum, aA as Grid, a4 as Text, a2 as Select, q as SelectTypeEnum, b4 as inputCssReset, b5 as screenReaderTextCss, b6 as checkObjectPropertiesSomeHaveValue, b7 as checkObjectPropertiesAllHaveValue, u as SettingsAppearanceControlTypeEnum, b8 as useDebouncedCallback, aK as usePrevious, aJ as useIsMounted, al as getDefaultDateTimeFormatString, a0 as getIntValueGreaterThan, b9 as CONTROLCLASS$h, ba as CONTROLCLASS$i, bb as CONTROLCLASS$j, at as Checkbox, as as Radio$1, bc as deDupArray, bd as removeItemInArray, aI as Textarea, ak as useResponsiveOuterContainerRef, ap as roundNumber } from './index-chunk-wpeform-react-daf2eca0.js';
import { useGesture, useDrag } from '@use-gesture/react';
import * as ReactDOM from 'react-dom';

const CONTROLCLASS$f = 'wpeform-component-animatedsvg';
const CONTROLSVGCLASS = getBemElement(CONTROLCLASS$f, 'svg');
const AnimatedPathFill = styled(animated.path) `
	will-change: opacity, transform;
`;
const AnimatedPathStroke = styled(animated.path) `
	stroke-dasharray: 65 66;
	will-change: stroke-dashoffset;
`;
const Container$9 = styled.div `
	${cssReset};
	display: inline-flex;
	align-items: center;
	justify-content: center;
	.${CONTROLSVGCLASS} {
		height: 1em;
		width: 1em;
		display: block;
	}
`;
function useSvgAnimation(theme, trail = 2) {
    const [svgStrokeStyle] = useTrail(trail, i => ({
        from: { strokeDashoffset: 66 },
        strokeDashoffset: 0,
        config: i === trail - 1
            ? theme.springConfigSlow
            : { ...theme.springConfigGeneral, clamp: true },
    }));
    const svgFillStyle = useSpring({
        from: { opacity: 0, transform: 'translate(0px, 0px)' },
        opacity: 1,
        transform: 'translate(2px, 2px)',
        config: theme.springConfigSlow,
        delay: 500,
    });
    return [svgStrokeStyle, svgFillStyle];
}
function RoundChatCheck(props) {
    const { colorfulBg } = props;
    const theme = useTheme();
    const [svgStrokeStyle, svgFillStyle] = useSvgAnimation(theme, 2);
    return (jsx(Fragment, { children: jsxs("svg", Object.assign({ width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: CONTROLSVGCLASS }, { children: [jsx(AnimatedPathFill, { style: svgFillStyle, stroke: colorfulBg ? theme.successBackgroundColor : theme.successColor, fill: colorfulBg ? theme.successColor : theme.successBackgroundColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "0", d: "M14.5 2H9.5C5.36 2 2 5.36 2 9.5C2 12.76 4.09 15.53 7 16.56V22L12 17H14.5C18.64 17 22 13.64 22 9.5C22 5.36 18.64 2 14.5 2Z" }, void 0), jsx(AnimatedPathStroke, { strokeDashoffset: svgStrokeStyle[1].strokeDashoffset, stroke: colorfulBg ? theme.successBackgroundColor : theme.successColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "1", fill: "none", d: "M14.5 2H9.5C5.36 2 2 5.36 2 9.5C2 12.76 4.09 15.53 7 16.56V22L12 17H14.5C18.64 17 22 13.64 22 9.5C22 5.36 18.64 2 14.5 2Z" }, void 0), jsx(AnimatedPathStroke, { strokeDashoffset: svgStrokeStyle[0].strokeDashoffset, stroke: colorfulBg ? theme.successBackgroundColor : theme.successColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "1", fill: "none", d: "M8.25 9.5L10.75 12L15.75 7" }, void 0)] }), void 0) }, void 0));
}
function RoundChatExclamation(props) {
    const { colorfulBg } = props;
    const theme = useTheme();
    const [svgStrokeStyle, svgFillStyle] = useSvgAnimation(theme, 3);
    return (jsx(Fragment, { children: jsxs("svg", Object.assign({ width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: CONTROLSVGCLASS }, { children: [jsx(AnimatedPathFill, { style: svgFillStyle, stroke: colorfulBg ? theme.warningBackgroundColor : theme.warningColor, fill: colorfulBg ? theme.warningColor : theme.warningBackgroundColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "0", d: "M14.5 2H9.5C5.36 2 2 5.36 2 9.5C2 12.76 4.09 15.53 7 16.56V22L12 17H14.5C18.64 17 22 13.64 22 9.5C22 5.36 18.64 2 14.5 2Z" }, void 0), jsx(AnimatedPathStroke, { strokeDashoffset: svgStrokeStyle[2].strokeDashoffset, stroke: colorfulBg ? theme.warningBackgroundColor : theme.warningColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "1", fill: "none", d: "M14.5 2H9.5C5.36 2 2 5.36 2 9.5C2 12.76 4.09 15.53 7 16.56V22L12 17H14.5C18.64 17 22 13.64 22 9.5C22 5.36 18.64 2 14.5 2Z" }, void 0), jsx(AnimatedPathStroke, { strokeDashoffset: svgStrokeStyle[0].strokeDashoffset, stroke: colorfulBg ? theme.warningBackgroundColor : theme.warningColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "1", d: "M11.99 13H12.01" }, void 0), jsx(AnimatedPathStroke, { strokeDashoffset: svgStrokeStyle[1].strokeDashoffset, stroke: colorfulBg ? theme.warningBackgroundColor : theme.warningColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "1", d: "M12 6V10" }, void 0)] }), void 0) }, void 0));
}
function RoundChatRemove(props) {
    const { colorfulBg } = props;
    const theme = useTheme();
    const [svgStrokeStyle, svgFillStyle] = useSvgAnimation(theme, 3);
    return (jsx(Fragment, { children: jsxs("svg", Object.assign({ width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: CONTROLSVGCLASS }, { children: [jsx(AnimatedPathFill, { style: svgFillStyle, stroke: colorfulBg ? theme.errorBackgroundColor : theme.errorColor, fill: colorfulBg ? theme.errorColor : theme.errorBackgroundColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "0", d: "M14.5 2H9.5C5.36 2 2 5.36 2 9.5C2 12.76 4.09 15.53 7 16.56V22L12 17H14.5C18.64 17 22 13.64 22 9.5C22 5.36 18.64 2 14.5 2Z" }, void 0), jsx(AnimatedPathStroke, { strokeDashoffset: svgStrokeStyle[2].strokeDashoffset, stroke: colorfulBg ? theme.errorBackgroundColor : theme.errorColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "1", fill: "none", d: "M14.5 2H9.5C5.36 2 2 5.36 2 9.5C2 12.76 4.09 15.53 7 16.56V22L12 17H14.5C18.64 17 22 13.64 22 9.5C22 5.36 18.64 2 14.5 2Z" }, void 0), jsx(AnimatedPathStroke, { strokeDashoffset: svgStrokeStyle[0].strokeDashoffset, stroke: colorfulBg ? theme.errorBackgroundColor : theme.errorColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "1", d: "M14.5 7L9.5 12" }, void 0), jsx(AnimatedPathStroke, { strokeDashoffset: svgStrokeStyle[1].strokeDashoffset, stroke: colorfulBg ? theme.errorBackgroundColor : theme.errorColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "1", d: "M9.5 7L14.5 12" }, void 0)] }), void 0) }, void 0));
}
function RoundChatDot(props) {
    const { colorfulBg } = props;
    const theme = useTheme();
    const [svgStrokeStyle, svgFillStyle] = useSvgAnimation(theme, 3);
    return (jsx(Fragment, { children: jsxs("svg", Object.assign({ width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: CONTROLSVGCLASS }, { children: [jsx(AnimatedPathFill, { style: svgFillStyle, stroke: colorfulBg ? theme.primaryBackgroundColor : theme.primaryLightColor, fill: colorfulBg ? theme.primaryLightColor : theme.primaryBackgroundColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "0", d: "M14.5 2H9.5C5.36 2 2 5.36 2 9.5C2 12.76 4.09 15.53 7 16.56V22L12 17H14.5C18.64 17 22 13.64 22 9.5C22 5.36 18.64 2 14.5 2Z" }, void 0), jsx(AnimatedPathStroke, { strokeDashoffset: svgStrokeStyle[2].strokeDashoffset, stroke: colorfulBg ? theme.primaryBackgroundColor : theme.primaryLightColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "1", fill: "none", d: "M14.5 2H9.5C5.36 2 2 5.36 2 9.5C2 12.76 4.09 15.53 7 16.56V22L12 17H14.5C18.64 17 22 13.64 22 9.5C22 5.36 18.64 2 14.5 2Z" }, void 0), jsx(AnimatedPathStroke, { strokeDashoffset: svgStrokeStyle[0].strokeDashoffset, stroke: colorfulBg ? theme.primaryBackgroundColor : theme.primaryLightColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "1", d: "M16.99 13H17" }, void 0), jsx(AnimatedPathStroke, { strokeDashoffset: svgStrokeStyle[1].strokeDashoffset, stroke: colorfulBg ? theme.primaryBackgroundColor : theme.primaryLightColor, strokeLinejoin: "round", strokeLinecap: "round", strokeMiterlimit: "10", strokeWidth: "1", d: "M12.99 13H13" }, void 0)] }), void 0) }, void 0));
}
/**
 * Animated SVG for feedback and other attention purpose.
 */
function AnimatedSvg(props) {
    const { colorfulBg, type, className } = props;
    return (jsx(Container$9, Object.assign({ className: getBemClassName(CONTROLCLASS$f, {
            [`type-${type}`]: true,
            colorfulBg,
        }, className) }, { children: type === 'error' ? (jsx(RoundChatRemove, { colorfulBg: colorfulBg }, void 0)) : type === 'warning' ? (jsx(RoundChatExclamation, { colorfulBg: colorfulBg }, void 0)) : type === 'success' ? (jsx(RoundChatCheck, { colorfulBg: colorfulBg }, void 0)) : (jsx(RoundChatDot, { colorfulBg: colorfulBg }, void 0)) }), void 0));
}

const CONTROLCLASS$e = 'wpeform-component-actionfeedback';
const CONTROLTITLECLASS = getBemElement(CONTROLCLASS$e, 'title');
const CONTROLCONTENTCLASS = getBemElement(CONTROLCLASS$e, 'content');
const CONTROLFOOTERCLASS = getBemElement(CONTROLCLASS$e, 'footer');
const CONTROLICONCLASS = getBemElement(CONTROLCLASS$e, 'icon');
const IconContainer$1 = styled.div `
	font-size: ${props => numToCssSize(props.theme.fz.large8 * 1.25)};
	margin: 0 0 ${props => numToCssSize(props.theme.gutter * 2)} 0;
	will-change: opacity, transform;
	display: flex;
`;
const Title = styled(animated.h3) `
	color: ${props => props.theme.headingColor};
	font-size: ${props => numToCssSize(props.theme.fz.large3)};
	font-weight: bold;
	margin: 0 0 ${props => numToCssSize(props.theme.gutter)} 0;
	line-height: 1.2;
	will-change: opacity, transform;
`;
const Content = styled(animated.article) `
	${proseCss};
	will-change: opacity, transform;
`;
const Footer = styled(animated.footer) `
	color: ${props => props.theme.textColorSecondary};
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	margin: ${props => numToCssSize(props.theme.gutter)} 0 0 0;
	will-change: opacity, transform;
`;
const Container$8 = styled.aside `
	${cssReset};
	margin: ${props => numToCssSize(props.theme.gutter)} 0;
	padding: 0 ${props => numToCssSize(props.theme.gutter)};

	&.${CONTROLCLASS$e}--size-tablet {
		${IconContainer$1} {
			font-size: ${props => numToCssSize(props.theme.fz.large8 * 1.5)};
		}
		${Title} {
			font-size: ${props => numToCssSize(props.theme.fz.large4)};
		}
	}
`;
function ActionFeedback(props) {
    const { type, title, children, className, scrollOnMount = true, scrollOffset = -100, footer, } = props;
    const theme = useTheme();
    const [trails] = useTrail(footer ? 3 : 2, i => ({
        from: { opacity: 0, transform: 'translate(0px, 20px)' },
        opacity: 1,
        transform: 'translate(0px, 0px)',
        config: i === 0 ? theme.springConfigGeneral : theme.springConfigSlow,
        delay: 500,
    }));
    const containerClass = useResponsiveClassNames(useContainerSize(), CONTROLCLASS$e, {
        [`type-${type}`]: true,
    }, className);
    // Layout effect for scrolling
    const isFirstMount = useRef(true);
    const containerRef = useRef(null);
    useLayoutEffect(() => {
        // do it only during first mount
        if (isFirstMount.current) {
            isFirstMount.current = false;
            if (scrollOnMount && containerRef.current) {
                _default(containerRef.current, {
                    verticalOffset: scrollOffset,
                    cancelOnUserAction: true,
                    elementToScroll: scrollParents(containerRef.current)[0],
                });
            }
        }
    }, [scrollOnMount, scrollOffset]);
    return (jsxs(Container$8, Object.assign({ className: containerClass, ref: containerRef }, { children: [jsx(IconContainer$1, Object.assign({ className: CONTROLICONCLASS }, { children: jsx(AnimatedSvg, { type: type, colorfulBg: false }, void 0) }), void 0), jsx(Title, Object.assign({ style: trails[0], className: CONTROLTITLECLASS }, { children: title }), void 0), jsx(Content, Object.assign({ style: trails[1], className: CONTROLCONTENTCLASS }, { children: children }), void 0), footer ? (jsx(Footer, Object.assign({ style: trails[2], className: CONTROLFOOTERCLASS }, { children: footer }), void 0)) : null] }), void 0));
}

const CONTROLCLASS$d = 'wpeform-component-control-group';
const Control = styled.div `
	flex: 0 0 100%;
	padding: 0 0 0 ${props => numToCssSize(props.theme.gutter / 2)};
`;
const Heading = styled.div `
	color: ${props => props.theme.headingColor};
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	font-weight: ${props => (props.theme.boldHeading ? 'bold' : 'normal')};
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
	flex: 0 0 100%;
	text-align: left;
	padding: 0 ${props => numToCssSize(props.theme.gutter / 2)};
`;
const Item$2 = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter * 1.2)} 0;
	position: relative;
	margin: 0;
	display: flex;
	flex-flow: row wrap;
	align-items: center;
	justify-content: space-between;

	&::before,
	&::after {
		content: '';
		position: absolute;
		display: block;
		height: 1px;
		border-radius: 2px;
		left: 0;
		right: 0;
		background-color: ${props => props.theme.borderColorLight};
		transition: ${props => getMultipleTransitionsWithWillChange(['background-color'], props.theme.transitionControl)};
	}
	&::after {
		bottom: -1px;
	}
	&::before {
		top: 0;
	}

	&:last-child {
		margin-bottom: 0;
	}

	&:focus {
		&::after,
		&::before {
			background-color: ${props => props.theme.primaryColor};
		}
		&::after {
			bottom: 0;
		}
	}
`;
const Container$7 = styled.div `
	padding: 0 ${props => numToCssSize(props.theme.gutter * 0.75)};
	// Alignments
	&.${CONTROLCLASS$d}--alignment-CENTER {
		${Heading} {
			text-align: center;
		}
	}
	&.${CONTROLCLASS$d}--alignment-RIGHT {
		${Heading} {
			text-align: right;
		}
	}

	// LAYOUT
	&.${CONTROLCLASS$d}--layout-HORIZONTAL {
		&.${CONTROLCLASS$d}--size-tablet {
			${Control} {
				flex: 0 0
					calc(100% - ${props => numToCssSize(200 + props.theme.gutter)});
				margin-left: auto;
			}
			${Heading} {
				flex: 0 0 200px;
				margin: 0;
			}
		}
	}
	&.${CONTROLCLASS$d}--layout-INLINE {
		${Heading} {
			position: absolute;
			font-size: ${props => numToCssSize(props.theme.fz.small2)};
			color: ${props => props.theme.textColorSecondary};
			top: ${props => numToCssSize(props.theme.gutter * 0.25)};
			left: 0;
		}
	}

	> *:last-child {
		${Item$2} {
			&::after {
				display: none;
			}
		}
	}
	> *:first-child {
		${Item$2} {
			&::before {
				display: none;
			}
		}
	}
`;

function ControlGroup(props) {
    const { className, layout = SettingsAppearanceControlLayoutEnum.VERTICAL, alignment = SettingsAppearanceControlAlignmentEnum.LEFT, children, } = props;
    const responsiveClassNames = useResponsiveClassNames(useContainerSize(), CONTROLCLASS$d, {
        [`layout-${layout}`]: true,
        [`alignment-${alignment}`]: true,
    }, className);
    return jsx(Container$7, Object.assign({ className: responsiveClassNames }, { children: children }), void 0);
}
ControlGroup.Item = Item$2;
ControlGroup.Heading = Heading;
ControlGroup.Control = Control;

const CONTROLCLASS$c = 'wpeform-component-inlinecountdown';
function InlineCountDown(props) {
    const { time, onDone } = props;
    const secondsLeft = useTimerCountDown(time, onDone);
    const { hours, minutes, seconds } = getHoursMinutesSeconds(secondsLeft * 1000, 'number');
    return (jsxs("span", Object.assign({ className: CONTROLCLASS$c }, { children: [hours > 0
                ? sprintf(_n('%d hour, ', '%d hours, ', hours, 'wp-eform'), hours)
                : null, hours > 0 || minutes > 0
                ? sprintf(_n('%d minute, ', '%d minutes, ', minutes, 'wp-eform'), minutes)
                : null, sprintf(_n('%d second', '%d seconds', seconds, 'wp-eform'), seconds)] }), void 0));
}

const CONTROLCLASS$b = 'wpeform-component-math-output';
const LABELCLASS$1 = getBemElement(CONTROLCLASS$b, 'label');
const OUTPUTCLASS = getBemElement(CONTROLCLASS$b, 'output');
const PREFIXCLASS = getBemElement(CONTROLCLASS$b, 'prefix');
const SUFFIXCLASS = getBemElement(CONTROLCLASS$b, 'suffix');
getBemElement(CONTROLCLASS$b, 'value-output');
const Label$2 = styled.div `
	flex: 0 1 auto;
	color: ${props => props.theme.textColor};
	font-weight: ${props => (props.theme.boldHeading ? 'bold' : 'normal')};
`;
const Output = styled.output `
	flex: 0 0 140px;
	width: 140px;
	text-align: right;
	margin-left: ${props => numToCssSize(props.theme.gutter / 2)};
`;
const ValueOutput = styled.span `
	font-variant-numeric: tabular-nums;
	font-weight: bold;
	color: ${props => props.theme.headingColor};
`;
const Prefix$1 = styled.span `
	color: ${props => props.theme.textColorSecondary};
`;
const Suffix = styled.span `
	color: ${props => props.theme.textColorSecondary};
`;
const Container$6 = styled.div `
	display: flex;
	flex-flow: row nowrap;
	align-items: center;
	justify-content: space-between;
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	padding: 0;

	&.${CONTROLCLASS$b}--appearance-table {
		padding: ${props => numToCssSize(props.theme.gutter / 2)};
		border-top: 1px solid ${props => props.theme.borderColorSplit};
		border-bottom: 1px solid ${props => props.theme.borderColorSplit};
	}

	&.${CONTROLCLASS$b}--appearance-highlighted {
		${Label$2} {
			flex-basis: calc(
				100% - ${props => numToCssSize(140 + props.theme.controlHeightBase)}
			);
			max-width: calc(
				100% - ${props => numToCssSize(140 + props.theme.controlHeightBase)}
			);
		}
		${Output} {
			flex-basis: ${props => numToCssSize(140 + props.theme.gutter)};
			width: ${props => numToCssSize(140 + props.theme.gutter)};
			padding: 0 ${props => numToCssSize(props.theme.gutter / 2)};
			background-color: ${props => props.theme.primaryColor};
			height: ${props => numToCssSize(props.theme.controlHeightBase)};
			line-height: ${props => numToCssSize(props.theme.controlHeightBase)};
			border-top-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
			border-bottom-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
			position: relative;

			&::before {
				position: absolute;
				display: block;
				content: '';
				height: ${props => numToCssSize(props.theme.controlHeightBase / Math.sqrt(2))};
				width: ${props => numToCssSize(props.theme.controlHeightBase / Math.sqrt(2))};
				left: ${props => numToCssSize(props.theme.controlHeightBase / Math.sqrt(2) / -2)};
				top: ${props => numToCssSize((props.theme.controlHeightBase -
    props.theme.controlHeightBase / Math.sqrt(2)) /
    2)};
				background-color: ${props => props.theme.primaryColor};
				transform: rotate(-45deg);
				transform-origin: center center;
				border-top-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
			}

			${ValueOutput},
			${Prefix$1},
			${Suffix} {
				color: ${props => props.theme.primaryBgText};
				position: relative;
				z-index: 10;
			}
		}
	}
`;
const Group = styled.div `
	${Label$2} {
		font-weight: normal;
	}
	> ${Container$6}, > * ${Container$6} {
		padding: ${props => numToCssSize(props.theme.gutter / 2)};
	}
	> ${Container$6}.${CONTROLCLASS$b}--appearance-highlighted,
		> *
		${Container$6}.${CONTROLCLASS$b}--appearance-highlighted {
		padding-right: 0;
	}
	> ${Container$6} + ${Container$6}, > * + * ${Container$6} {
		border-top: 0 none;
	}
`;

function MathOutput(props) {
    const { value, appearance = 'simple', prefix = null, suffix = null, precision = 2, thousandsSeparator = ',', decimalSeparator = '.', className, label, } = props;
    const config = useClampedSpringConfig('slow');
    // FIXME: Remove this workaround when react-spring 9.3 releases
    // @link https://github.com/pmndrs/react-spring/issues/1461
    const [output, setOutput] = useState(() => formatNumber(0, precision, decimalSeparator, thousandsSeparator));
    useSpring({
        from: { value: 0 },
        to: { value },
        config,
        onChange({ value: num }) {
            setOutput(formatNumber(num.value, precision, decimalSeparator, thousandsSeparator));
        },
    });
    return (jsxs(Container$6, Object.assign({ className: getBemClassName(CONTROLCLASS$b, {
            [`appearance-${appearance}`]: true,
        }, className) }, { children: [jsx(Label$2, Object.assign({ className: LABELCLASS$1 }, { children: label }), void 0), jsxs(Output, Object.assign({ className: OUTPUTCLASS }, { children: [prefix ? jsx(Prefix$1, Object.assign({ className: PREFIXCLASS }, { children: prefix }), void 0) : null, jsx(ValueOutput, { children: output }, void 0), suffix ? jsx(Suffix, Object.assign({ className: SUFFIXCLASS }, { children: suffix }), void 0) : null] }), void 0)] }), void 0));
}
MathOutput.Group = Group;

const CONTROLCLASS$a = 'wpeform-component-progressbar';
const PROGRESSCLASS = getBemElement(CONTROLCLASS$a, 'bar');
const activeAnimation = keyframes `
	0% {
			width: 0;
			opacity: 0.1;
	}
	20% {
			width: 0;
			opacity: 0.5;
	}
	100% {
			width: 100%;
			opacity: 0;
	}
`;
const AnimatedTabsProgress = styled(animated.div) `
	will-change: width;
	background-color: ${props => props.theme.primaryColor};
	height: ${props => numToCssSize(props.theme.controlHeightBase * 0.25)};
	position: relative;

	&.${PROGRESSCLASS}--is-active {
		&::before {
			position: absolute;
			top: 0;
			right: 0;
			bottom: 0;
			left: 0;
			background: ${props => props.theme.primaryBgText};
			opacity: 0;
			animation: ${activeAnimation} 2.4s cubic-bezier(0.23, 1, 0.32, 1) infinite;
			content: '';
		}
	}
`;
const ProgressLabel = styled(animated.span) `
	margin: 0;
	padding: 0;
	color: ${props => props.theme.textColorSecondary};
	font-size: ${props => numToCssSize(props.theme.fz.small2)};
	line-height: 1;
	font-weight: bold;
	position: absolute;
	right: 0.2em;
`;
const ProgressContainer = styled.div `
	height: ${props => numToCssSize(props.theme.controlHeightBase * 0.25)};
	background-color: ${props => curriedLighten(0.05, props.theme.disabledColor)};
	overflow: hidden;
	width: 100%;
`;
const ProgressbarWrapper = styled.div `
	${cssReset};
	position: relative;

	/** Rounded corners */
	&.${CONTROLCLASS$a}--is-bottom-rounded {
		${ProgressContainer} {
			border-bottom-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
			border-bottom-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
		}
	}
	&.${CONTROLCLASS$a}--is-top-rounded {
		${ProgressContainer} {
			border-top-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
			border-top-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
		}
	}
	&.${CONTROLCLASS$a}--is-bottom-rounded.${CONTROLCLASS$a}--is-top-rounded {
		${ProgressContainer},
		${AnimatedTabsProgress},
		${AnimatedTabsProgress}::before {
			border-radius: ${props => numToCssSize(props.theme.controlHeightBase * 0.25)};
		}
	}

	/** Label positions */
	&.${CONTROLCLASS$a}--label-position-top {
		${ProgressLabel} {
			top: -1.2em;
		}
	}
	&.${CONTROLCLASS$a}--label-position-bottom {
		${ProgressLabel} {
			bottom: -1.2em;
		}
	}
`;
function Progressbar(props) {
    const { width, active = false, isBottomRounded = false, isTopRounded = false, showLabel = true, precision = 2, labelPosition = 'top', } = props;
    const theme = useTheme();
    const progressBarProps = useSpring({
        from: { width: '0%' },
        to: { width: `${width}%` },
        config: {
            ...theme.springConfigSlow,
            clamp: true,
        },
    });
    const numValue = useSpring({
        number: width,
        from: { number: 0 },
        config: {
            ...theme.springConfigSlow,
            clamp: true,
        },
    });
    return (jsxs(ProgressbarWrapper, Object.assign({ className: getBemClassName(CONTROLCLASS$a, {
            'is-bottom-rounded': isBottomRounded,
            'is-top-rounded': isTopRounded,
            'is-active': active,
            [`label-position-${labelPosition}`]: true,
        }) }, { children: [jsx(ProgressContainer, { children: jsx(AnimatedTabsProgress, { style: progressBarProps, className: getBemClassName(PROGRESSCLASS, {
                        'is-active': !!active,
                    }), "aria-valuenow": width, "aria-valuemin": 0, "aria-valuemax": 100 }, void 0) }, void 0), showLabel ? (jsx(ProgressLabel, { children: numValue.number.to(x => `${x.toFixed(precision)}%`) }, void 0)) : null] }), void 0));
}

/* eslint-disable no-else-return */
function arrayMove(array, from, to) {
    array = array.slice();
    array.splice(to < 0 ? array.length + to : to, 0, array.splice(from, 1)[0]);
    return array;
}
function getTranslateOffset(element) {
    const style = window.getComputedStyle(element);
    return (Math.max(parseInt(style['margin-top'], 10), parseInt(style['margin-bottom'], 10)) + element.getBoundingClientRect().height);
}
function isTouchEvent(event) {
    return ((event.touches && event.touches.length) ||
        (event.changedTouches && event.changedTouches.length));
}
function transformItem(element, offsetY = 0, offsetX = 0) {
    if (!element)
        return;
    if (offsetY === null || offsetX === null) {
        element.style.removeProperty('transform');
        return;
    }
    element.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
}
function setItemTransition(element, duration, timing) {
    if (element) {
        element.style['transition'] = `transform ${duration}ms${timing ? ` ${timing}` : ''}`;
    }
}
// returns the "slot" for the targetValue, aka where it should go
// in an ordered "array", it starts with -1 index
function binarySearch(array, targetValue) {
    let min = 0;
    let max = array.length - 1;
    let guess;
    while (min <= max) {
        guess = Math.floor((max + min) / 2);
        if (!array[guess + 1] ||
            (array[guess] <= targetValue && array[guess + 1] >= targetValue)) {
            return guess;
        }
        else if (array[guess] < targetValue && array[guess + 1] < targetValue) {
            min = guess + 1;
        }
        else {
            max = guess - 1;
        }
    }
    return -1;
}
// adapted from https://github.com/alexreardon/raf-schd
const schd = (fn) => {
    let lastArgs = [];
    let frameId = null;
    const wrapperFn = (...args) => {
        lastArgs = args;
        if (frameId) {
            return;
        }
        frameId = requestAnimationFrame(() => {
            frameId = null;
            fn(...lastArgs);
        });
    };
    return wrapperFn;
};
function checkIfInteractive(target, rootElement) {
    const DISABLED_ELEMENTS = [
        'input',
        'textarea',
        'select',
        'option',
        'optgroup',
        'video',
        'audio',
        'button',
        'a',
    ];
    const DISABLED_ROLES = ['button', 'link', 'checkbox', 'tab'];
    while (target !== rootElement) {
        if (target.getAttribute('data-movable-handle')) {
            return false;
        }
        if (DISABLED_ELEMENTS.includes(target.tagName.toLowerCase())) {
            return true;
        }
        const role = target.getAttribute('role');
        if (role && DISABLED_ROLES.includes(role.toLowerCase())) {
            return true;
        }
        if (target.tagName.toLowerCase() === 'label' &&
            target.hasAttribute('for')) {
            return true;
        }
        if (target.tagName)
            target = target.parentElement;
    }
    return false;
}

const AUTOSCROLL_ACTIVE_OFFSET = 200;
const AUTOSCROLL_SPEED_RATIO = 10;
class List$1 extends React.Component {
    listRef = React.createRef();
    ghostRef = React.createRef();
    topOffsets = [];
    itemTranslateOffsets = [];
    initialYOffset = 0;
    lastScroll = 0;
    lastYOffset = 0;
    lastListYOffset = 0;
    dropTimeout;
    needle = -1;
    afterIndex = -2;
    state = {
        itemDragged: -1,
        itemDraggedOutOfBounds: -1,
        selectedItem: -1,
        initialX: 0,
        initialY: 0,
        targetX: 0,
        targetY: 0,
        targetHeight: 0,
        targetWidth: 0,
        liveText: '',
        scrollingSpeed: 0,
        scrollWindow: false,
    };
    schdOnMouseMove;
    schdOnTouchMove;
    schdOnEnd;
    constructor(props) {
        super(props);
        this.schdOnMouseMove = schd(this.onMouseMove);
        this.schdOnTouchMove = schd(this.onTouchMove);
        this.schdOnEnd = schd(this.onEnd);
    }
    listener = document;
    componentDidMount() {
        setTimeout(() => {
            this.calculateOffsets();
            this.listener = this.props.container?.current || document;
            this.listener.addEventListener('touchstart', this.onMouseOrTouchStart, {
                passive: false,
                capture: false,
            });
            this.listener.addEventListener('mousedown', this.onMouseOrTouchStart);
        });
    }
    componentDidUpdate(_prevProps, prevState) {
        if (prevState.scrollingSpeed !== this.state.scrollingSpeed &&
            prevState.scrollingSpeed === 0) {
            this.doScrolling();
        }
    }
    componentWillUnmount() {
        this.listener.removeEventListener('touchstart', this.onMouseOrTouchStart);
        this.listener.removeEventListener('mousedown', this.onMouseOrTouchStart);
    }
    doScrolling = () => {
        const { scrollingSpeed, scrollWindow } = this.state;
        const listEl = this.listRef.current;
        window.requestAnimationFrame(() => {
            if (scrollWindow) {
                window.scrollTo(window.pageXOffset, window.pageYOffset + scrollingSpeed * 1.5);
            }
            else {
                listEl.scrollTop += scrollingSpeed;
            }
            if (scrollingSpeed !== 0) {
                this.doScrolling();
            }
        });
    };
    getChildren = () => {
        if (this.listRef && this.listRef.current) {
            return Array.from(this.listRef.current.children);
        }
        console.warn('No items found in the List container. Did you forget to pass & spread the `props` param in renderList?');
        return [];
    };
    static defaultProps = {
        transitionDuration: 300,
        lockVertically: false,
        removableByMove: false,
        voiceover: {
            item: (position) => `You are currently at a draggable item at position ${position}. Press space bar to lift.`,
            lifted: (position) => `You have lifted item at position ${position}. Press j to move down, k to move up, space bar to drop and escape to cancel.`,
            moved: (position, up) => `You have moved the lifted item ${up ? 'up' : 'down'} to position ${position}. Press j to move down, k to move up, space bar to drop and escape to cancel.`,
            dropped: (from, to) => `You have dropped the item. It has moved from position ${from} to ${to}.`,
            canceled: (position) => `You have cancelled the movement. The item has returned to its starting position of ${position}.`,
        },
    };
    calculateOffsets = () => {
        this.topOffsets = this.getChildren().map(item => item.getBoundingClientRect().top);
        this.itemTranslateOffsets = this.getChildren().map(item => getTranslateOffset(item));
    };
    getTargetIndex = (e) => {
        return this.getChildren().findIndex(child => child === e.target || child.contains(e.target));
    };
    onMouseOrTouchStart = (e) => {
        if (this.props.disabled === true) {
            return;
        }
        if (this.dropTimeout && this.state.itemDragged > -1) {
            window.clearTimeout(this.dropTimeout);
            this.finishDrop();
        }
        const isTouch = isTouchEvent(e);
        if (!isTouch && e.button !== 0)
            return;
        const index = this.getTargetIndex(e);
        if (index === -1 ||
            // @ts-ignore
            (this.props.values[index] && this.props.values[index].disabled)) {
            if (this.state.selectedItem !== -1) {
                this.setState({ selectedItem: -1 });
                this.finishDrop();
            }
            return;
        }
        const listItemTouched = this.getChildren()[index];
        const handle = listItemTouched.querySelector('[data-movable-handle]');
        if (handle && !handle.contains(e.target)) {
            return;
        }
        if (checkIfInteractive(e.target, listItemTouched)) {
            return;
        }
        e.preventDefault();
        this.props.beforeDrag &&
            this.props.beforeDrag({
                elements: this.getChildren(),
                index,
            });
        if (isTouch) {
            const opts = { passive: false };
            listItemTouched.style.touchAction = 'none';
            document.addEventListener('touchend', this.schdOnEnd, opts);
            document.addEventListener('touchmove', this.schdOnTouchMove, opts);
            document.addEventListener('touchcancel', this.schdOnEnd, opts);
        }
        else {
            document.addEventListener('mousemove', this.schdOnMouseMove);
            document.addEventListener('mouseup', this.schdOnEnd);
            const listItemDragged = this.getChildren()[this.state.itemDragged];
            if (listItemDragged && listItemDragged.style) {
                listItemDragged.style.touchAction = '';
            }
        }
        this.onStart(listItemTouched, isTouch ? e.touches[0].clientX : e.clientX, isTouch ? e.touches[0].clientY : e.clientY, index);
    };
    getYOffset = () => {
        const listScroll = this.listRef.current
            ? this.listRef.current.scrollTop
            : 0;
        return window.pageYOffset + listScroll;
    };
    onStart = (target, clientX, clientY, index) => {
        if (this.state.selectedItem > -1) {
            this.setState({ selectedItem: -1 });
            this.needle = -1;
        }
        const targetRect = target.getBoundingClientRect();
        const targetStyles = window.getComputedStyle(target);
        this.calculateOffsets();
        this.initialYOffset = this.getYOffset();
        this.lastYOffset = window.pageYOffset;
        this.lastListYOffset = this.listRef.current.scrollTop;
        this.setState({
            itemDragged: index,
            targetX: targetRect.left - parseInt(targetStyles['margin-left'], 10),
            targetY: targetRect.top - parseInt(targetStyles['margin-top'], 10),
            targetHeight: targetRect.height,
            targetWidth: targetRect.width,
            initialX: clientX,
            initialY: clientY,
        });
    };
    onMouseMove = (e) => {
        e.cancelable && e.preventDefault();
        this.onMove(e.clientX, e.clientY);
    };
    onTouchMove = (e) => {
        e.cancelable && e.preventDefault();
        this.onMove(e.touches[0].clientX, e.touches[0].clientY);
    };
    onWheel = (e) => {
        if (this.state.itemDragged < 0)
            return;
        this.lastScroll = this.listRef.current.scrollTop += e.deltaY;
        this.moveOtherItems();
    };
    onMove = (clientX, clientY) => {
        if (this.state.itemDragged === -1)
            return null;
        transformItem(this.ghostRef.current, clientY - this.state.initialY, this.props.lockVertically ? 0 : clientX - this.state.initialX);
        this.autoScrolling(clientY);
        this.moveOtherItems();
    };
    moveOtherItems = () => {
        const targetRect = this.ghostRef.current.getBoundingClientRect();
        const itemVerticalCenter = targetRect.top + targetRect.height / 2;
        const offset = getTranslateOffset(this.getChildren()[this.state.itemDragged]);
        const currentYOffset = this.getYOffset();
        // adjust offsets if scrolling happens during the item movement
        if (this.initialYOffset !== currentYOffset) {
            this.topOffsets = this.topOffsets.map(offset => offset - (currentYOffset - this.initialYOffset));
            this.initialYOffset = currentYOffset;
        }
        if (this.isDraggedItemOutOfBounds() && this.props.removableByMove) {
            this.afterIndex = this.topOffsets.length + 1;
        }
        else {
            this.afterIndex = binarySearch(this.topOffsets, itemVerticalCenter);
        }
        this.animateItems(this.afterIndex === -1 ? 0 : this.afterIndex, this.state.itemDragged, offset);
    };
    autoScrolling = (clientY) => {
        const { top, bottom, height } = this.listRef.current.getBoundingClientRect();
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
        // autoscrolling for the window (down)
        if (bottom > viewportHeight &&
            viewportHeight - clientY < AUTOSCROLL_ACTIVE_OFFSET) {
            this.setState({
                scrollingSpeed: Math.round((AUTOSCROLL_ACTIVE_OFFSET - (viewportHeight - clientY)) /
                    AUTOSCROLL_SPEED_RATIO),
                scrollWindow: true,
            });
            // autoscrolling for the window (up)
        }
        else if (top < 0 && clientY < AUTOSCROLL_ACTIVE_OFFSET) {
            this.setState({
                scrollingSpeed: Math.round((AUTOSCROLL_ACTIVE_OFFSET - clientY) / -AUTOSCROLL_SPEED_RATIO),
                scrollWindow: true,
            });
        }
        else {
            if (this.state.scrollWindow && this.state.scrollingSpeed !== 0) {
                this.setState({ scrollingSpeed: 0, scrollWindow: false });
            }
            // autoscrolling for containers with overflow
            if (height + 20 < this.listRef.current.scrollHeight) {
                let scrollingSpeed = 0;
                if (clientY - top < AUTOSCROLL_ACTIVE_OFFSET) {
                    scrollingSpeed = Math.round((AUTOSCROLL_ACTIVE_OFFSET - (clientY - top)) /
                        -AUTOSCROLL_SPEED_RATIO);
                }
                else if (bottom - clientY < AUTOSCROLL_ACTIVE_OFFSET) {
                    scrollingSpeed = Math.round((AUTOSCROLL_ACTIVE_OFFSET - (bottom - clientY)) /
                        AUTOSCROLL_SPEED_RATIO);
                }
                if (this.state.scrollingSpeed !== scrollingSpeed) {
                    this.setState({ scrollingSpeed });
                }
            }
        }
    };
    animateItems = (needle, movedItem, offset, animateMovedItem = false) => {
        this.getChildren().forEach((item, i) => {
            setItemTransition(item, this.props.transitionDuration);
            if (movedItem === i && animateMovedItem) {
                if (movedItem === needle) {
                    return transformItem(item, null);
                }
                transformItem(item, movedItem < needle
                    ? this.itemTranslateOffsets
                        .slice(movedItem + 1, needle + 1)
                        .reduce((a, b) => a + b, 0)
                    : this.itemTranslateOffsets
                        .slice(needle, movedItem)
                        .reduce((a, b) => a + b, 0) * -1);
            }
            else if (movedItem < needle && i > movedItem && i <= needle) {
                transformItem(item, -offset);
            }
            else if (i < movedItem && movedItem > needle && i >= needle) {
                transformItem(item, offset);
            }
            else {
                transformItem(item, null);
            }
        });
    };
    isDraggedItemOutOfBounds = () => {
        const initialRect = this.getChildren()[this.state.itemDragged].getBoundingClientRect();
        const targetRect = this.ghostRef.current.getBoundingClientRect();
        if (Math.abs(initialRect.left - targetRect.left) > targetRect.width) {
            if (this.state.itemDraggedOutOfBounds === -1) {
                this.setState({ itemDraggedOutOfBounds: this.state.itemDragged });
            }
            return true;
        }
        if (this.state.itemDraggedOutOfBounds > -1) {
            this.setState({ itemDraggedOutOfBounds: -1 });
        }
        return false;
    };
    onEnd = (e) => {
        e.cancelable && e.preventDefault();
        document.removeEventListener('mousemove', this.schdOnMouseMove);
        document.removeEventListener('touchmove', this.schdOnTouchMove);
        document.removeEventListener('mouseup', this.schdOnEnd);
        document.removeEventListener('touchup', this.schdOnEnd);
        document.removeEventListener('touchcancel', this.schdOnEnd);
        const removeItem = this.props.removableByMove && this.isDraggedItemOutOfBounds();
        if (!removeItem &&
            this.props.transitionDuration > 0 &&
            this.afterIndex !== -2) {
            // animate drop
            schd(() => {
                setItemTransition(this.ghostRef.current, this.props.transitionDuration, 'cubic-bezier(.2,1,.1,1)');
                if (this.afterIndex < 1 && this.state.itemDragged === 0) {
                    transformItem(this.ghostRef.current, 0, 0);
                }
                else {
                    transformItem(this.ghostRef.current, 
                    // compensate window scroll
                    -(window.pageYOffset - this.lastYOffset) +
                        // compensate container scroll
                        -(this.listRef.current.scrollTop - this.lastListYOffset) +
                        (this.state.itemDragged < this.afterIndex
                            ? this.itemTranslateOffsets
                                .slice(this.state.itemDragged + 1, this.afterIndex + 1)
                                .reduce((a, b) => a + b, 0)
                            : this.itemTranslateOffsets
                                .slice(this.afterIndex < 0 ? 0 : this.afterIndex, this.state.itemDragged)
                                .reduce((a, b) => a + b, 0) * -1), 0);
                }
            })();
        }
        this.dropTimeout = window.setTimeout(this.finishDrop, removeItem || this.afterIndex === -2 ? 0 : this.props.transitionDuration);
    };
    finishDrop = () => {
        const removeItem = this.props.removableByMove && this.isDraggedItemOutOfBounds();
        if (removeItem ||
            (this.afterIndex > -2 && this.state.itemDragged !== this.afterIndex)) {
            this.props.onChange({
                oldIndex: this.state.itemDragged,
                newIndex: removeItem ? -1 : Math.max(this.afterIndex, 0),
                targetRect: this.ghostRef.current.getBoundingClientRect(),
            });
        }
        this.getChildren().forEach(item => {
            setItemTransition(item, 0);
            transformItem(item, null);
            item.style.touchAction = '';
        });
        this.setState({ itemDragged: -1, scrollingSpeed: 0 });
        this.afterIndex = -2;
        // sometimes the scroll gets messed up after the drop, fix:
        if (this.lastScroll > 0) {
            this.listRef.current.scrollTop = this.lastScroll;
            this.lastScroll = 0;
        }
    };
    onKeyDown = (e) => {
        const selectedItem = this.state.selectedItem;
        const index = this.getTargetIndex(e);
        if (checkIfInteractive(e.target, e.currentTarget)) {
            return;
        }
        if (index === -1)
            return;
        if (e.key === ' ') {
            e.preventDefault();
            if (selectedItem === index) {
                if (selectedItem !== this.needle) {
                    this.getChildren().forEach(item => {
                        setItemTransition(item, 0);
                        transformItem(item, null);
                    });
                    this.props.onChange({
                        oldIndex: selectedItem,
                        newIndex: this.needle,
                        targetRect: this.getChildren()[this.needle].getBoundingClientRect(),
                    });
                    this.getChildren()[this.needle].focus();
                }
                this.setState({
                    selectedItem: -1,
                    liveText: this.props.voiceover.dropped(selectedItem + 1, this.needle + 1),
                });
                this.needle = -1;
            }
            else {
                this.setState({
                    selectedItem: index,
                    liveText: this.props.voiceover.lifted(index + 1),
                });
                this.needle = index;
                this.calculateOffsets();
            }
        }
        if ((e.key === 'ArrowDown' || e.key === 'j') &&
            selectedItem > -1 &&
            this.needle < this.props.values.length - 1) {
            e.preventDefault();
            const offset = getTranslateOffset(this.getChildren()[selectedItem]);
            this.needle++;
            this.animateItems(this.needle, selectedItem, offset, true);
            this.setState({
                liveText: this.props.voiceover.moved(this.needle + 1, false),
            });
        }
        if ((e.key === 'ArrowUp' || e.key === 'k') &&
            selectedItem > -1 &&
            this.needle > 0) {
            e.preventDefault();
            const offset = getTranslateOffset(this.getChildren()[selectedItem]);
            this.needle--;
            this.animateItems(this.needle, selectedItem, offset, true);
            this.setState({
                liveText: this.props.voiceover.moved(this.needle + 1, true),
            });
        }
        if (e.key === 'Escape' && selectedItem > -1) {
            this.getChildren().forEach(item => {
                setItemTransition(item, 0);
                transformItem(item, null);
            });
            this.setState({
                selectedItem: -1,
                liveText: this.props.voiceover.canceled(selectedItem + 1),
            });
            this.needle = -1;
        }
        if ((e.key === 'Tab' || e.key === 'Enter') && selectedItem > -1) {
            e.preventDefault();
        }
    };
    render() {
        const baseStyle = {
            userSelect: 'none',
            WebkitUserSelect: 'none',
            MozUserSelect: 'none',
            msUserSelect: 'none',
            boxSizing: 'border-box',
            position: 'relative',
        };
        const ghostStyle = {
            ...baseStyle,
            top: this.state.targetY,
            left: this.state.targetX,
            width: this.state.targetWidth,
            height: this.state.targetHeight,
            position: 'fixed',
            marginTop: 0,
        };
        return (jsxs(React.Fragment, { children: [this.props.renderList({
                    children: this.props.values.map((value, index) => {
                        const isHidden = index === this.state.itemDragged;
                        const isSelected = index === this.state.selectedItem;
                        const isDisabled = 
                        // @ts-ignore
                        (this.props.values[index] && this.props.values[index].disabled) ||
                            this.props.disabled === true;
                        const props = {
                            key: this.props.getKey ? this.props.getKey(value) : index,
                            tabIndex: isDisabled ? undefined : 0,
                            'aria-roledescription': this.props.voiceover.item(index + 1),
                            onKeyDown: this.onKeyDown,
                            style: {
                                ...baseStyle,
                                visibility: isHidden ? 'hidden' : undefined,
                                zIndex: isSelected ? 5000 : 0,
                            },
                        };
                        return this.props.renderItem({
                            value,
                            props,
                            index,
                            isDragged: false,
                            isSelected,
                            isOutOfBounds: false,
                        });
                    }),
                    isDragged: this.state.itemDragged > -1,
                    props: {
                        ref: this.listRef,
                    },
                }), this.state.itemDragged > -1 &&
                    ReactDOM.createPortal(this.props.renderItem({
                        value: this.props.values[this.state.itemDragged],
                        props: {
                            ref: this.ghostRef,
                            style: ghostStyle,
                            onWheel: this.onWheel,
                        },
                        index: this.state.itemDragged,
                        isDragged: true,
                        isSelected: false,
                        isOutOfBounds: this.state.itemDraggedOutOfBounds > -1,
                    }), this.props.container?.current || document.body), jsx("div", Object.assign({ "aria-live": "assertive", role: "log", "aria-atomic": "true", style: {
                        position: 'absolute',
                        width: '1px',
                        height: '1px',
                        margin: '-1px',
                        border: '0px',
                        padding: '0px',
                        overflow: 'hidden',
                        clip: 'rect(0px, 0px, 0px, 0px)',
                        clipPath: 'inset(100%)',
                    } }, { children: this.state.liveText }), void 0)] }, void 0));
    }
}

const kfRotate = (theme) => keyframes `
	0% {
		stroke: ${theme.accentColor};
		color: ${theme.accentColor};
		transform: rotate(0deg);
	}
	100% {
		stroke: ${theme.primaryColor};
		color: ${theme.primaryColor};
		transform: rotate(360deg);
	}
`;
const kfDash = keyframes `
	0% {
		stroke-dasharray: 1, 150;
		stroke-dashoffset: 0;
	}
	50% {
		stroke-dasharray: 90, 150;
		stroke-dashoffset: -35;
	}
	100% {
		stroke-dasharray: 90, 150;
		stroke-dashoffset: -124;
	}
`;
const StyledSpinnerSvg = styled.svg `
	animation: ${props => kfRotate(props.theme)} 1s linear infinite;
	height: ${props => (props.height ? numToCssSize(props.height) : '50px')};
	width: ${props => (props.width ? numToCssSize(props.width) : '50px')};

	& .path {
		stroke: currentColor;
		stroke-linecap: round;
		animation: ${kfDash} 1.5s ease-in-out infinite;
	}
`;
function SpinnerSvg(props) {
    const { height = 50, width = 50 } = props;
    return (jsx(StyledSpinnerSvg, Object.assign({ viewBox: `0 0 ${width} ${height}`, width: width, height: height }, { children: jsx("circle", { className: "path", cx: `${height / 2}`, cy: `${width / 2}`, r: `${width / 2 - 5}`, fill: "none", strokeWidth: "3" }, void 0) }), void 0));
}
const SpinnerWrap = styled.div `
	display: flex;
	justify-content: center;
	align-items: center;
	min-height: ${props => props.height};
	${StyledSpinnerSvg} {
		margin: 40px;
	}
`;
/**
 * Show a spinner with specified height. The spinner will be centered.
 *
 * @visibleName Spinner
 */
function Spinner({ height = '300px' }) {
    return (jsx(SpinnerWrap, Object.assign({ height: height }, { children: jsx(SpinnerSvg, {}, void 0) }), void 0));
}

const CONTROLCLASS$9 = 'wpeform-component-table';
const TABLECLASS = getBemElement(CONTROLCLASS$9, 'table');
const Container$5 = styled.div `
	${cssReset};
	max-width: 100%;
	${scrollBarHorizontalCss};
`;
const StyledTable = styled.table `
	border: 0 none;
	border-collapse: collapse;
	width: 100%;
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	text-align: left;

	&.${TABLECLASS}--fixedLayout {
		table-layout: fixed;
	}

	th,
	td {
		padding: ${props => numToCssSize(props.theme.gutter)}
			${props => numToCssSize(props.theme.gutter / 2)};
	}

	thead,
	tfoot {
		background-color: ${props => props.theme.backgroundShade};
		tr {
			border-bottom: 1px solid ${props => props.theme.borderColorBase};
		}
		th {
			font-size: ${props => numToCssSize(props.theme.fz.small1)};
			color: ${props => props.theme.textColorSecondary};
			padding-top: ${props => numToCssSize(props.theme.gutter / 2)};
			padding-bottom: ${props => numToCssSize(props.theme.gutter / 2)};
			font-family: ${props => props.theme.fontFamilyHeading};
			&:first-child {
				padding-left: ${props => numToCssSize(props.theme.gutter)};
			}
		}
	}
	tfoot {
		tr {
			border-top: 1px solid ${props => props.theme.borderColorBase};
			border-bottom: 0 none;
		}
	}

	th {
		color: ${props => props.theme.headingColor};
		font-weight: bold;
	}

	tbody {
		tr {
			border-bottom: 1px solid ${props => props.theme.borderColorSplit};
			transition: ${props => getMultipleTransitionsWithWillChange(['background-color'], props.theme.transitionControl)};
			background-color: ${props => props.theme.appBackgroundColor};
			th:first-child {
				padding-left: ${props => numToCssSize(props.theme.gutter)};
				color: ${props => props.theme.headingColor};
				font-family: ${props => props.theme.fontFamilyHeading};
			}
		}
	}

	&.${TABLECLASS}--type-stripped {
		tbody {
			tr {
				&:nth-child(2n) {
					background-color: ${props => props.theme.backgroundControl};
				}
			}
		}
	}

	&.${TABLECLASS}--highlightOnHover {
		tbody {
			tr {
				&:hover {
					background-color: ${props => props.theme.backgroundHover};
				}
			}
		}
	}

	&.${TABLECLASS}--isBodyCentered {
		tbody {
			td {
				text-align: center;
			}
		}
		thead,
		tfoot {
			th {
				text-align: center;
			}
		}
	}

	a {
		text-decoration: none;
		&:hover {
			text-decoration: underline;
		}
	}
`;

/**
 * A generic table component for printing styled tables.
 *
 * @param props Table props.
 */
function Table(props) {
    const { className, children, type = 'stripped', highlightOnHover = true, fixedLayout = false, isBodyCentered = false, } = props;
    return (jsx(Container$5, Object.assign({ className: getBemClassName(CONTROLCLASS$9, {
            [`type-${type}`]: true,
            fixedLayout,
            highlightOnHover,
            isBodyCentered,
        }, className) }, { children: jsx(StyledTable, Object.assign({ className: getBemClassName(TABLECLASS, {
                [`type-${type}`]: true,
                fixedLayout,
                highlightOnHover,
                isBodyCentered,
            }) }, { children: children }), void 0) }), void 0));
}

const CONTROLCLASS$8 = 'wpeform-component-tabs';
const NAVBUTTONCLASS = getBemElement(CONTROLCLASS$8, 'nav-button');
const BUTTONCLASS = getBemElement(CONTROLCLASS$8, 'button');
const BUTTONICONCLASS = getBemElement(CONTROLCLASS$8, 'button-icon');
const BUTTONLABELCLASS = getBemElement(CONTROLCLASS$8, 'button-label');
const BUTTONLABELTITLECLASS = getBemElement(CONTROLCLASS$8, 'button-label-title');
const BUTTONLABELSUBTITLECLASS = getBemElement(CONTROLCLASS$8, 'button-label-subtitle');
const TabsContainer = styled.div `
	${cssReset};
	box-shadow: ${props => props.theme.boxShadow4dp};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	/** Fixes weird jump on nav button clicks */
	/** it happens only with chrome and that too when clicking navigation button */
	/** check the example, maybe there's a bug with chrome  85.0.4183.102 */
	overflow-anchor: none;
	background-color: ${props => props.theme.appBackgroundColor};
`;
const TabsNavigation = styled.nav `
	background-color: ${props => props.theme.primaryLightColor};
	border-top-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-top-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	overflow: hidden;
	display: flex;
	flex-flow: row nowrap;
	align-items: stretch;
	width: 100%;
	position: relative;
	z-index: 2; /** So that inner nav left & right buttons do not bleed through */

	.${NAVBUTTONCLASS} {
		padding: 0;
		justify-content: center;
		position: absolute;
		left: 0;
		top: 0;
		flex: 0 0 ${props => numToCssSize(props.theme.gutter * 0.75)};
		width: ${props => numToCssSize(props.theme.gutter * 0.75)};
		height: 100%;
		z-index: 1;
		background-color: transparent;
		/** hack for safari to transparentize the last stop */
		background-image: linear-gradient(
			to right,
			${props => props.theme.primaryLightColor},
			${props => props.theme.primaryLightColor} 50%,
			${props => curriedTransparentize(1, props.theme.primaryLightColor)} 100%
		);
		&::before {
			position: absolute;
			pointer-events: none;
			content: '';
			display: block;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: ${props => props.theme.primaryColor};
			opacity: 0;
			transition: ${props => getMultipleTransitionsWithWillChange(['opacity'], props.theme.transitionControl)};
		}
		&:disabled {
			opacity: 0;
			pointer-events: none;
		}
		.${BUTTONLABELCLASS} {
			position: relative;
		}
		.${BUTTONLABELTITLECLASS} {
			font-size: ${props => numToCssSize(props.theme.fz.small2)};
		}
		&.right {
			background-image: linear-gradient(
				to left,
				${props => props.theme.primaryLightColor},
				${props => props.theme.primaryLightColor} 50%,
				${props => curriedTransparentize(1, props.theme.primaryLightColor)} 100%
			);
			left: auto;
			right: 0;
		}

		&:hover,
		&:focus {
			background-color: transparent;
			&::before {
				opacity: 1;
			}
		}
		&:active {
			.${BUTTONLABELCLASS} {
				transform: scale(0.8);
			}
		}
	}
`;
const TabsScroller = styled(animated.div) `
	flex: 1 0 auto;
	width: 100%;
	will-change: transform;
	touch-action: pan-y;
`;
styled(animated.div) `
	will-change: opacity, position, transform;
`;
const TabsNavButtonsContainer = styled.div `
	display: flex;
	flex-flow: row nowrap;
	touch-action: pan-y;
`;
const TabButton = styled.button `
	font-family: ${props => props.theme.fontFamilyHeading};
	position: relative;
	overflow: hidden;
	flex: 0 0 auto;
	display: flex;
	align-items: center;
	justify-content: flex-start;
	padding: ${props => numToCssSize(props.theme.gutter / 2)}
		${props => numToCssSize(props.theme.gutter)};
	min-height: ${props => numToCssSize(props.theme.controlHeightBase * 1.25)};
	border: 0 none;
	margin: 0;
	outline: none;
	border-radius: 0;
	background-color: ${props => props.theme.primaryLightColor};
	cursor: pointer;
	color: ${props => curriedTransparentize(0.3, props.theme.primaryBgText)};
	text-align: left;
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'color'], props.theme.transitionControl)};

	&.${BUTTONCLASS}--active {
		background-color: ${props => props.theme.primaryColor};
		color: ${props => props.theme.primaryBgText};
	}

	&:hover {
		background-color: ${props => props.theme.primaryColor};
	}

	&:focus {
		background-color: ${props => props.theme.primaryColor};
		color: ${props => props.theme.primaryBgText};
	}

	&:active {
		.${BUTTONLABELCLASS} {
			transform: scale(0.97);
			transform-origin: center center;
		}
	}

	.${BUTTONICONCLASS} {
		font-size: ${props => numToCssSize(props.theme.fz.large3)};
		margin: 0 ${props => numToCssSize(props.theme.gutter / 2)} 0 0;
		flex: 0 0 auto;
	}

	.${BUTTONLABELCLASS} {
		flex: 0 0 auto;
		display: flex;
		flex-flow: column nowrap;
	}
	.${BUTTONLABELTITLECLASS} {
		font-size: ${props => numToCssSize(props.theme.fz.large1)};
		font-weight: ${props => (props.theme.boldHeading ? '500' : 'normal')};
		line-height: 1;
		white-space: nowrap;
	}
	.${BUTTONLABELSUBTITLECLASS} {
		font-size: ${props => numToCssSize(props.theme.fz.small2)};
		font-style: ${props => (props.theme.italicHeading ? 'italic' : 'normal')};
		line-height: 1;
		white-space: nowrap;
		margin: 0;
	}
`;
const TabPanel = styled.div `
	position: relative;
	overflow: hidden;
	&:focus {
		outline: none;
	}
`;
const TabFooter = styled.footer `
	overflow: hidden;
	border-bottom-left-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border-bottom-right-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
`;
const StopwatchContainer = styled.aside `
	padding: 0 ${props => numToCssSize(props.theme.gutter * 1.5)}
		${props => numToCssSize(props.theme.gutter * 0.5)};
	/* text-align: right; */
`;
const StopwatchClock = styled.span `
	display: block;
	font-size: ${props => numToCssSize(props.theme.fz.large3)};
	color: ${props => props.theme.textColorSecondary};
	font-weight: bold;
	line-height: 1;
`;
const StopwatchStamp = styled.span `
	display: block;
	font-size: ${props => numToCssSize(props.theme.fz.small2)};
	line-height: 1;
	color: ${props => props.theme.textColorSecondary};
`;

const SCROLLOFFSET = 150;
const SCROLLGUTTER = 90;
function RippleTabButton(props) {
    const { title, subtitle, icon, onClick, active, className, id, disabled } = props;
    const [addRipple, ripples] = useRipple({ darkBg: true });
    return (jsxs(TabButton, Object.assign({ id: id, disabled: disabled, className: getBemClassName(BUTTONCLASS, { active: active ? true : false }, className), onClick: e => {
            e.preventDefault();
            addRipple(e);
            onClick();
        }, type: "button" }, { children: [ripples, icon ? (jsx("span", Object.assign({ className: BUTTONICONCLASS }, { children: jsx(Icon, { iconClass: icon }, void 0) }), void 0)) : null, jsxs("span", Object.assign({ className: BUTTONLABELCLASS }, { children: [jsx("span", Object.assign({ className: BUTTONLABELTITLECLASS }, { children: title }), void 0), subtitle ? (jsx("span", Object.assign({ className: BUTTONLABELSUBTITLECLASS }, { children: subtitle }), void 0)) : null] }), void 0)] }), void 0));
}
function TabLists(props) {
    const { currentTab, tabs, onTabChange } = props;
    // get the theme from styled-components
    const theme = useTheme();
    // all things scrolling
    // This is the ref to the main button container
    // since this has a set width, we can use it to calculate bound of buttons
    const buttonContainerRef = useRef(null);
    const buttonContainerSize = componentSize(buttonContainerRef);
    // The state to determine whether or not to show the nav buttons
    // and which button to keep disabled.
    const [tabNavState, setTabNavState] = useState({
        leftDisabled: true,
        rightDisabled: false,
        left: 0,
    });
    // the spring to animate translate left of the scroller.
    const [translateLeftProps, api] = useSpring(() => ({
        from: { transform: 'translateX(0px)' },
        to: { transform: `translateX(${tabNavState.left * -1}px)` },
        config: { ...theme.springConfigStiff, clamp: true },
    }));
    useEffect(() => {
        api.start({ transform: `translateX(${tabNavState.left * -1}px)` });
    }, [tabNavState.left, api]);
    const smoothScroller = (offset, updateState) => {
        if (!buttonContainerRef.current) {
            return;
        }
        // get the total button width and container width to determine position
        let totalButtonWidth = 0;
        buttonContainerRef.current.querySelectorAll('button').forEach(btn => {
            totalButtonWidth += btn.offsetWidth;
        });
        const containerWidth = buttonContainerRef.current.offsetWidth;
        let translateLeft = tabNavState.left - offset;
        if (totalButtonWidth < containerWidth) {
            translateLeft = 0;
        }
        else {
            // determine the left with a clamp to min and max
            if (translateLeft < 0) {
                translateLeft = 0;
            }
            if (translateLeft > totalButtonWidth - containerWidth) {
                translateLeft = totalButtonWidth - containerWidth;
            }
        }
        if (updateState) {
            let leftDisabled = false;
            let rightDisabled = false;
            // determine which buttons are disabled
            if (translateLeft === 0) {
                leftDisabled = true;
            }
            if (translateLeft + containerWidth >= totalButtonWidth) {
                rightDisabled = true;
            }
            setTabNavState({ left: translateLeft, leftDisabled, rightDisabled });
        }
        else {
            api.start({ transform: `translateX(${translateLeft * -1}px)` });
        }
    };
    const resetTabScroll = useCallback((left, leftDisabled, rightDisabled) => {
        setTabNavState({ left, leftDisabled, rightDisabled });
    }, []);
    useGesture({
        onDrag(state) {
            const { movement, down } = state;
            smoothScroller(movement[0], !down);
        },
        onWheel(state) {
            const { event, movement } = state;
            if (Math.abs(event.deltaX) <= Math.abs(event.deltaY)) {
                return;
            }
            // stop propagation
            event.preventDefault();
            event.stopPropagation();
            smoothScroller(movement[0], true);
        },
    }, {
        target: buttonContainerRef.current,
        eventOptions: { passive: false },
        drag: { filterTaps: true },
    });
    // the function to calculate the scroll/translate-left of the scroller
    const adjustTabScroll = useCallback((currentTabId) => {
        if (!buttonContainerRef.current) {
            return;
        }
        let offsetLeft = 0;
        let activeButtonWidth = 0;
        let calculationDone = false;
        let totalButtonWidth = 0;
        buttonContainerRef.current.querySelectorAll('button').forEach(btn => {
            totalButtonWidth += btn.offsetWidth;
            if (!calculationDone) {
                if (btn.getAttribute('id') === `tab-item-${currentTabId}`) {
                    calculationDone = true;
                    activeButtonWidth = btn.offsetWidth;
                }
                else {
                    offsetLeft += btn.offsetWidth;
                }
            }
        });
        // get the container width
        const containerWidth = buttonContainerRef.current.offsetWidth;
        // If total width is less containerWidth, then we don't need a scroller
        if (totalButtonWidth <= containerWidth) {
            resetTabScroll(0, true, true);
            return;
        }
        // if button is in view, then don't do anything, rather reset scroll
        if (offsetLeft + activeButtonWidth <= containerWidth) {
            resetTabScroll(0, true, false);
            return;
        }
        // button is not in view, so have it in view
        let translateLeft = offsetLeft + activeButtonWidth - containerWidth + SCROLLGUTTER;
        // if the beginning of the button won't fix inside the container, then
        // make sure we just position the button to the left most
        if (activeButtonWidth + SCROLLGUTTER > containerWidth) {
            translateLeft =
                offsetLeft -
                    theme.gutter *
                        0.75; /** 0.75 * gutter is the width of the nav buttons */
        }
        // determine the left with a clamp
        if (translateLeft < 0) {
            translateLeft = 0;
        }
        // determin the right with a clamp
        if (translateLeft > totalButtonWidth - containerWidth) {
            translateLeft = totalButtonWidth - containerWidth;
        }
        resetTabScroll(translateLeft, false, translateLeft + containerWidth >= totalButtonWidth);
    }, [theme.gutter, resetTabScroll]);
    // adjust it whenever the currentTab changes
    useLayoutEffect(() => {
        adjustTabScroll(currentTab);
    }, [currentTab, adjustTabScroll, buttonContainerSize.width]);
    return (jsxs(TabsNavigation, { children: [jsx(RippleTabButton, { className: NAVBUTTONCLASS, title: jsx(Icon, { iconClass: "fas fa-angle-left" }, void 0), onClick: () => {
                    smoothScroller(SCROLLOFFSET, true);
                }, disabled: tabNavState.leftDisabled }, void 0), jsx(TabsScroller, Object.assign({ style: translateLeftProps }, { children: jsx(TabsNavButtonsContainer, Object.assign({ ref: buttonContainerRef }, { children: tabs.map(tab => (jsx(RippleTabButton, { onClick: () => {
                            onTabChange(tab.id);
                        }, active: currentTab === tab.id, id: `tab-item-${tab.id}`, icon: tab.icon, subtitle: tab.subtitle, title: tab.title }, tab.id))) }), void 0) }), void 0), jsx(RippleTabButton, { className: classNames(NAVBUTTONCLASS, 'right'), title: jsx(Icon, { iconClass: "fas fa-angle-right" }, void 0), onClick: () => {
                    smoothScroller(SCROLLOFFSET * -1, true);
                }, disabled: tabNavState.rightDisabled }, void 0)] }, void 0));
}
function TabStopwatch(props) {
    const { stopwatchStartTime } = props;
    const [elapsed, setElapsed] = useState(0);
    useEffect(() => {
        const updater = () => {
            const timeDiff = Math.abs(Date.now() - stopwatchStartTime);
            setElapsed(timeDiff);
        };
        const timerId = setInterval(updater, 1000);
        updater();
        return () => {
            clearInterval(timerId);
        };
    }, [stopwatchStartTime]);
    const { hours, minutes, seconds } = getHoursMinutesSeconds(elapsed);
    return (jsxs(StopwatchContainer, { children: [jsx(StopwatchClock, { children: sprintf(_x('%s:%s:%s', 'timer', 'wp-eform'), hours, minutes, seconds) }, void 0), jsx(StopwatchStamp, { children: sprintf(__('time elapsed since %s', 'wp-eform'), dayjs(stopwatchStartTime).format('LTS')) }, void 0)] }, void 0));
}
/**
 * A Tab like component made with use-case of EForm in mind. It has the following
 * features.
 *
 * - 🔥 Animates on tab change.
 * - 🔥 Responsiveness in the tab list items.
 * - 🔥 Can scroll window to focus tab on change.
 */
function Tabs(props) {
    const { currentTab, onTabChange, tabs, children, className, scrollOnTabChange = true, tabScrollOffset = -100, footer, showProgressBar = true, showProgressLabel = true, showTabs = true, progressBarPosition = SettingsAppearanceProgressBarPositionEnum.TOP, progressBarPrecision = 2, forceProgress, stopwatchStartTime, } = props;
    // scroll to the tab on change and focus the panel
    const containerRef = useRef(null);
    const panelRef = useRef(null);
    const isFirstMount = useRef(true);
    // spring to animate progress bar
    let currentTabIndex = tabs.findIndex(t => t.id === currentTab);
    // if it is not in the provided list, then just fall back to 0
    if (currentTabIndex === -1) {
        currentTabIndex = 0;
    }
    // calculate the width, also don't increase the currentTabIndex
    // because current tab is not a part of finished tab.
    const toWidth = forceProgress
        ? forceProgress
        : (currentTabIndex / (tabs.length || 1)) * 100;
    useLayoutEffect(() => {
        // don't do anything if this is during first mount
        if (isFirstMount.current) {
            isFirstMount.current = false;
            return;
        }
        // now focus the panel
        if (panelRef.current) {
            panelRef.current.focus({
                preventScroll: true,
            });
        }
        if (scrollOnTabChange && containerRef.current) {
            _default(containerRef.current, {
                verticalOffset: tabScrollOffset,
                cancelOnUserAction: true,
                elementToScroll: scrollParents(containerRef.current)[0],
            });
        }
    }, [currentTab, scrollOnTabChange, tabScrollOffset]);
    return (jsxs(TabsContainer, Object.assign({ ref: containerRef, className: getBemClassName(CONTROLCLASS$8, {
            'has-footer': !!footer,
        }, className) }, { children: [showTabs ? (jsx(TabLists, { currentTab: currentTab, onTabChange: onTabChange, tabs: tabs }, void 0)) : null, showProgressBar &&
                progressBarPosition === SettingsAppearanceProgressBarPositionEnum.TOP ? (jsx(Progressbar, { width: toWidth, labelPosition: "bottom", isTopRounded: !showTabs, precision: progressBarPrecision, showLabel: showProgressLabel }, void 0)) : null, jsx(TabPanel, Object.assign({ tabIndex: 0, ref: panelRef }, { children: children }), void 0), stopwatchStartTime ? (jsx(TabStopwatch, { stopwatchStartTime: stopwatchStartTime }, void 0)) : null, showProgressBar &&
                progressBarPosition ===
                    SettingsAppearanceProgressBarPositionEnum.BOTTOM ? (jsx(Progressbar, { width: toWidth, isBottomRounded: !footer, labelPosition: "top", precision: progressBarPrecision, showLabel: showProgressLabel }, void 0)) : null, footer ? jsx(TabFooter, { children: footer }, void 0) : null] }), void 0));
}

const CONTROLCLASS$7 = 'wpeform-component-timer';
const TimerProgressContainer = styled(animated.div) `
	position: absolute;
	left: 0;
	right: 0;
	top: 0;
	height: ${props => numToCssSize(props.theme.controlHeightBase / 8)};
	will-change: background-color;
`;
const TimerProgressAnimator = styled(animated.div) `
	will-change: width;
	position: absolute;
	right: 0;
	top: 0;
	height: ${props => numToCssSize(props.theme.controlHeightBase / 8)};
	background-color: ${props => curriedDarken(0.1, props.theme.backgroundShade)};
	max-width: 100%;
`;
const TimerIconContainer = styled.div `
	flex: 0 0 ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
	margin: 0 ${props => numToCssSize(props.theme.gutter / 2)} 0 0;
	height: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
	width: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
	font-size: ${props => numToCssSize(props.theme.controlHeightBase * 0.8)};
	line-height: 1;
	display: flex;
	align-items: center;
	justify-content: center;
	color: ${props => curriedDarken(0.1, props.theme.backgroundShade)};
`;
function TimerIcon() {
    return (jsx(TimerIconContainer, { children: jsx(Icon, { iconClass: "fas fa-clock" }, void 0) }, void 0));
}
const TimerMainContainer = styled.div `
	width: calc(
		100% - ${props => numToCssSize(props.theme.controlHeightBase * 0.8)}
	);
	flex: 0 0
		calc(100% - ${props => numToCssSize(props.theme.controlHeightBase * 0.8)});
`;
const TimerClockContainer = styled.div `
	display: flex;
	flex-flow: row nowrap;
	align-items: center;
`;
const TimeContainer = styled.div `
	font-size: ${props => numToCssSize(props.theme.fz.large2)};
	font-weight: bold;
	line-height: 1.2;
	color: ${props => props.theme.headingColor};
	font-variant-numeric: tabular-nums;
	small {
		font-size: ${props => numToCssSize(props.theme.fz.small2)};
		font-weight: normal;
	}
`;
const TickContainer = styled.div `
	font-size: ${props => numToCssSize(props.theme.fz.large1)};
	margin: 0 ${props => numToCssSize(props.theme.gutter / 5)};
	line-height: 1.2;
`;
const TimerMessage = styled.div `
	font-size: ${props => numToCssSize(props.theme.fz.small2)};
	color: ${props => props.theme.textColorSecondary};
	margin: 0;
	padding: 0;
	${textEllipsisCss};
	.${CONTROLCLASS$g} {
		${textEllipsisCss};
	}
`;
const TimerWrapper = styled.div `
	display: flex;
	align-items: center;
	flex-flow: row nowrap;
	padding: ${props => numToCssSize(props.theme.gutter / 2)};
	padding-top: ${props => numToCssSize(props.theme.gutter / 2 + props.theme.controlHeightBase / 8)};
`;
const TimerContainer = styled.div `
	${cssReset};
	font-family: ${props => props.theme.fontFamilyBody};
	background-color: ${props => props.theme.backgroundShade};
	position: relative;

	&.${CONTROLCLASS$7}--hidden {
		display: none;
	}

	/** RESPONSIVENESS */
	/**
	 * We don't respond from the responsive container, because this would be used
	 * through a portal with a fixed position.
	 */
	@media screen and (min-width: ${props => numToCssSize(props.theme.breakpoints.tablet)}) {
		${TimerWrapper} {
			padding: ${props => numToCssSize(props.theme.gutter)};
			padding-top: ${props => numToCssSize(props.theme.gutter + props.theme.controlHeightBase / 8)};
		}
		${TimerIconContainer} {
			flex-basis: ${props => numToCssSize(props.theme.controlHeightBase * 1.2)};
			margin-right: ${props => numToCssSize(props.theme.gutter)};
			height: ${props => numToCssSize(props.theme.controlHeightBase * 1.2)};
			width: ${props => numToCssSize(props.theme.controlHeightBase * 1.2)};
			font-size: ${props => numToCssSize(props.theme.controlHeightBase * 1.2)};
		}
		${TimerMainContainer} {
			width: calc(
				100% - ${props => numToCssSize(props.theme.controlHeightBase * 1.2)}
			);
			flex-basis: calc(
				100% - ${props => numToCssSize(props.theme.controlHeightBase * 1.2)}
			);
		}
		${TimeContainer} {
			font-size: ${props => numToCssSize(props.theme.fz.large3)};
			small {
				font-size: ${props => numToCssSize(props.theme.fz.small1)};
			}
		}
		${TickContainer} {
			font-size: ${props => numToCssSize(props.theme.fz.large2)};
		}
		${TimerMessage} {
			font-size: ${props => numToCssSize(props.theme.fz.small1)};
		}
	}
`;
const Placeholder = styled.div `
	height: ${props => numToCssSize(props.theme.gutter +
    props.theme.controlHeightBase / 8 +
    props.theme.fz.large2 * 1.2 +
    props.theme.fz.small2 * 1.2 +
    10)};
	@media screen and (min-width: ${props => numToCssSize(props.theme.breakpoints.tablet)}) {
		height: ${props => numToCssSize(props.theme.gutter * 2 +
    props.theme.controlHeightBase / 8 +
    props.theme.fz.large3 * 1.2 +
    props.theme.fz.small1 * 1.2 +
    10)};
	}
`;
const Portal = styled.div `
	position: fixed;
	bottom: 0;
	left: 0;
	width: 100%;
	z-index: 999995; /** 1 less than Dropdown z-index */
`;
function Timer(props) {
    const { time, onDone, message, showUI, width = '100%', containerLayout = SettingsAppearanceContainerLayoutEnum.FIXED, } = props;
    const secondsLeft = useTimerCountDown(time, onDone);
    // we need background color and width for the animated progressbar
    const theme = useTheme();
    const percentComplete = (secondsLeft / time) * 100;
    const backgroundColorStyle = useSpring({
        from: { backgroundColor: theme.successColor },
        to: {
            backgroundColor: percentComplete > 60
                ? theme.successColor
                : percentComplete > 20
                    ? theme.warningColor
                    : theme.errorColor,
        },
        config: theme.springConfigSlow,
    });
    const widthStyle = useSpring({
        from: { width: '0%' },
        to: { width: `${numToCssSize(100 - percentComplete, '%')}` },
        config: theme.springConfigSlow,
    });
    const { hours, minutes, seconds } = getHoursMinutesSeconds(secondsLeft * 1000, 'string');
    const className = getBemClassName(CONTROLCLASS$7, {
        hidden: !showUI,
    });
    const { hours: initialHours } = useMemo(() => getHoursMinutesSeconds(time * 1000, 'number'), [time]);
    return (jsx(TimerContainer, Object.assign({ className: className }, { children: jsx(ResponsiveContainer, Object.assign({ width: width, containerLayout: containerLayout, noHorizontalPadding: true, noVerticalPadding: true }, { children: jsxs(TimerWrapper, { children: [jsx(TimerProgressContainer, Object.assign({ style: backgroundColorStyle }, { children: jsx(TimerProgressAnimator, { style: widthStyle }, void 0) }), void 0), jsx(TimerIcon, {}, void 0), jsxs(TimerMainContainer, { children: [jsxs(TimerClockContainer, { children: [initialHours > 0 ? (jsxs(Fragment, { children: [jsxs(TimeContainer, { children: [hours, jsx("small", { children: _x('h', 'hours short form', 'wp-eform') }, void 0)] }, void 0), jsx(TickContainer, { children: ":" }, void 0)] }, void 0)) : null, jsxs(TimeContainer, { children: [minutes, jsx("small", { children: _x('m', 'minutes short form', 'wp-eform') }, void 0)] }, void 0), jsx(TickContainer, { children: ":" }, void 0), jsxs(TimeContainer, { children: [seconds, jsx("small", { children: _x('s', 'seconds short form', 'wp-eform') }, void 0)] }, void 0)] }, void 0), message ? jsx(TimerMessage, { children: message }, void 0) : null] }, void 0)] }, void 0) }), void 0) }), void 0));
}
Timer.Placeholder = Placeholder;
Timer.Portal = Portal;

const CONTROLCLASS$6 = 'wpeform-control-address';
const Container$4 = styled.div `
	padding: ${props => numToCssSize(props.theme.gutter * (0.75 / 2))};
`;
const addressFieldsInOrder = [
    'fieldOne',
    'fieldTwo',
    'country',
    'state',
    'city',
    'zip',
];
const iconsMap = {
    city: jsx(Icon, { iconClass: "fas fa-city" }, void 0),
    country: jsx(Icon, { iconClass: "fas fa-globe-africa" }, void 0),
    fieldOne: jsx(Icon, { iconClass: "fas fa-road" }, void 0),
    fieldTwo: jsx(Icon, { iconClass: "fas fa-map-signs" }, void 0),
    state: jsx(Icon, { iconClass: "fas fa-map-marker-alt" }, void 0),
    zip: jsx(Icon, { iconClass: "fas fa-asterisk" }, void 0),
};
const addressFieldsRendererInOrder = addressFieldsInOrder.map(field => ({
    field,
    width: field === 'fieldOne' || field === 'fieldTwo'
        ? WidthPresetsEnum.FULL
        : WidthPresetsEnum.HALF,
    icon: iconsMap[field],
}));
function Address(props) {
    const { fields, updateField, className, hasError, id, name, configuration, countries, states, countriesLoading, statesLoading, disableAllIcons = false, controlAlignment, controlType, countriesError, onSelectCountry, statesError, readOnly, onBlur, } = props;
    const containerRef = useRef(null);
    const [isDropdownActive, setDropdownActive] = useState(false);
    const onSelectOpen = useCallback(() => {
        setDropdownActive(true);
    }, []);
    const onSelectClose = useCallback(() => {
        setDropdownActive(false);
    }, []);
    return (jsx(Container$4, Object.assign({ className: classNames(CONTROLCLASS$6, className), onBlur: () => {
            if (!containerRef.current?.matches(':focus-within') &&
                !isDropdownActive) {
                onBlur?.();
            }
        }, ref: containerRef }, { children: jsx(Grid, Object.assign({ noPadding: true }, { children: addressFieldsRendererInOrder
                .filter(item => configuration[item.field].enabled)
                .map(item => (jsx(Grid.Item, Object.assign({ columnSize: item.width }, { children: jsx(Grid.Gutter, Object.assign({ dense: true }, { children: (function () {
                        if (item.field === 'fieldOne' ||
                            item.field === 'fieldTwo' ||
                            item.field === 'city' ||
                            item.field === 'zip') {
                            return (jsx(Text, { value: fields[item.field], onChange: newValue => {
                                    updateField({
                                        [item.field]: newValue,
                                    });
                                }, hasError: hasError, id: id ? `${id}_${item.field}` : undefined, name: name ? `${name}_${item.field}` : undefined, placeholder: configuration[item.field].placeholder, ariaLabel: configuration[item.field].placeholder, controlAlignment: controlAlignment, controlType: controlType, prefix: !disableAllIcons ? item.icon : undefined, readOnly: readOnly }, void 0));
                        }
                        if (item.field === 'country') {
                            return countriesError ? (jsx(Text, { value: fields[item.field], onChange: newValue => {
                                    updateField({
                                        [item.field]: newValue,
                                    });
                                }, hasError: hasError, id: id ? `${id}_${item.field}` : undefined, name: name ? `${name}_${item.field}` : undefined, placeholder: jsx(Fragment, { children: __('Count not load countries, please enter manually', 'wp-eform') }, void 0), ariaLabel: configuration[item.field].placeholder, controlAlignment: controlAlignment, controlType: controlType, prefix: !disableAllIcons ? (jsx(Icon, { iconClass: "fas fa-exclamation" }, void 0)) : undefined, readOnly: readOnly }, void 0)) : (jsx(Select, { value: fields.country ? [fields.country] : [], items: countries, loading: countriesLoading, disabled: readOnly, mode: SelectTypeEnum.SINGLE, placeholder: configuration.country.placeholder ??
                                    __('Country', 'wp-eform'), ariaLabel: configuration.country.placeholder ??
                                    __('Country', 'wp-eform'), onChange: newValue => {
                                    // reset state on country change
                                    if (newValue.length) {
                                        updateField({
                                            country: newValue[0],
                                            state: '',
                                        });
                                        onSelectCountry?.(newValue[0]);
                                    }
                                    else {
                                        updateField({
                                            country: '',
                                            state: '',
                                        });
                                        onSelectCountry?.('');
                                    }
                                }, prefix: !disableAllIcons
                                    ? countries.find(c => c.value === fields.country)
                                        ?.icon ?? item.icon
                                    : undefined, onOpen: onSelectOpen, onClose: onSelectClose }, void 0));
                        }
                        return statesError || states.length === 0 ? (jsx(Text, { value: fields[item.field], onChange: newValue => {
                                updateField({ [item.field]: newValue });
                            }, hasError: hasError, id: id ? `${id}_${item.field}` : undefined, name: name ? `${name}_${item.field}` : undefined, placeholder: jsx(Fragment, { children: statesError
                                    ? __('could not load states, please enter manually', 'wp-eform')
                                    : configuration.state.placeholder ??
                                        __('State', 'wp-eform') }, void 0), ariaLabel: configuration[item.field].placeholder, controlAlignment: controlAlignment, controlType: controlType, prefix: !disableAllIcons ? (statesError ? (jsx(Icon, { iconClass: "fas fa-exclamation" }, void 0)) : (item.icon)) : undefined, readOnly: readOnly }, void 0)) : (jsx(Select, { value: fields.state ? [fields.state] : [], items: states, disabled: readOnly, loading: statesLoading, mode: SelectTypeEnum.SINGLE, ariaLabel: configuration.state.placeholder ??
                                __('State', 'wp-eform'), placeholder: configuration.state.placeholder ??
                                __('State', 'wp-eform'), onChange: newValue => {
                                if (newValue.length) {
                                    updateField({ state: newValue[0] });
                                }
                                else {
                                    updateField({ state: '' });
                                }
                            }, prefix: !disableAllIcons ? item.icon : undefined, onOpen: onSelectOpen, onClose: onSelectClose }, void 0));
                    })() }), void 0) }), item.field))) }), void 0) }), void 0));
}

const CONTROLCLASS$5 = 'wpeform-control-datetimepicker';
const GENERICGROUPCLASS = getBemElement(CONTROLCLASS$5, 'group');
const DATECONTAINERCLASS = getBemElement(CONTROLCLASS$5, 'date-container', GENERICGROUPCLASS);
const GENERICINPUTCLASS = getBemElement(CONTROLCLASS$5, 'input');
const DAYINPUTCLASS = getBemElement(CONTROLCLASS$5, 'day', GENERICINPUTCLASS);
const MONTHINPUTCLASS = getBemElement(CONTROLCLASS$5, 'month', GENERICINPUTCLASS);
const YEARINPUTCLASS = getBemElement(CONTROLCLASS$5, 'year', GENERICINPUTCLASS);
const TIMECONTAINERCLASS = getBemElement(CONTROLCLASS$5, 'time-container', GENERICGROUPCLASS);
const HOURINPUTCLASS = getBemElement(CONTROLCLASS$5, 'hour', GENERICINPUTCLASS);
const MINUTEINPUTCLASS = getBemElement(CONTROLCLASS$5, 'minute', GENERICINPUTCLASS);
const SECONDINPUTCLASS = getBemElement(CONTROLCLASS$5, 'second', GENERICINPUTCLASS);
const AMPMSELECTCLASS = getBemElement(CONTROLCLASS$5, 'ampm', GENERICINPUTCLASS);
const AmPmSelect = styled.select `
	border: 2px solid ${props => props.theme.borderColorSplit};
	border-radius: 0;
	padding: ${props => numToCssSize(props.theme.controlHeightBase / 20)};
	padding-right: ${props => numToCssSize(props.theme.controlHeightBase / 10)};
	outline: none;
	font-size: ${props => numToCssSize(props.theme.fz.small2)};
	height: ${props => numToCssSize(props.theme.controlHeightBase * 0.6)};
	color: ${props => props.theme.textColor};
	background-color: ${props => props.theme.appBackgroundColor};

	&:hover {
		border-color: ${props => props.theme.borderColorBase};
	}
	&:active,
	&:focus {
		border-color: ${props => props.theme.primaryColor};
	}

	&:disabled {
		background-color: ${props => props.theme.disabledBackgroundColor};
	}
	&:disabled {
		cursor: not-allowed;
	}

	option {
		background-color: ${props => props.theme.appBackgroundColor};
		color: ${props => props.theme.textColor};
	}
`;
const MonthSelect = styled.select `
	border-radius: 0;
	padding: 0 ${props => numToCssSize(props.theme.controlHeightBase / 10)};
	border: 0 none;
	border-bottom: 2px solid ${props => props.theme.borderColorSplit};
	color: ${props => props.theme.textColor};
	background-color: ${props => props.theme.appBackgroundColor};
	width: 100%;
	height: ${props => numToCssSize(props.theme.controlHeightBase * (1.25 - 0.25) - props.theme.fz.small2 - 2)};
	line-height: ${props => numToCssSize(props.theme.controlHeightBase * (1.25 - 0.25) - props.theme.fz.small2 - 2)};
	transition: ${props => getMultipleTransitionsWithWillChange(['border-color'], props.theme.transitionControl)};
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	color: ${props => props.theme.textColor};
	&.is-empty {
		color: ${props => props.theme.disabledColor};
	}

	&:hover {
		border-bottom-color: ${props => props.theme.borderColorBase};
	}
	&:active,
	&:focus {
		border-bottom-color: ${props => props.theme.primaryColor};
		outline: none;
	}

	&:disabled {
		background-color: ${props => props.theme.disabledBackgroundColor};
	}
	&:disabled {
		cursor: not-allowed;
	}

	option {
		background-color: ${props => props.theme.appBackgroundColor};
		color: ${props => props.theme.textColor};
		font-size: ${props => numToCssSize(props.theme.fz.base)};
	}
`;
const Input$1 = styled.input `
	${inputCssReset};
	border: 0 none;
	outline: none;
	appearance: none;
	border-radius: 0;
	text-align: right;
	font-variant-numeric: tabular-nums;
	&::-webkit-inner-spin-button,
	&::-webkit-outer-spin-button {
		margin: 0;
		-webkit-appearance: none;
	}
	height: ${props => numToCssSize(props.theme.controlHeightBase * (1.25 - 0.25) - props.theme.fz.small2 - 2)};
	line-height: ${props => numToCssSize(props.theme.controlHeightBase * (1.25 - 0.25) - props.theme.fz.small2 - 2)};
	margin: 0;
	padding: 0 ${props => numToCssSize(props.theme.controlHeightBase / 10)};

	&::placeholder {
		color: ${props => props.theme.disabledColor};
		font-size: ${props => numToCssSize(props.theme.fz.small2)};
		font-weight: bold;
	}

	font-size: ${props => numToCssSize(props.theme.fz.base)};
	width: 100%;
	color: ${props => props.theme.textColor};
	background-color: transparent;

	border-bottom: 2px solid ${props => props.theme.borderColorSplit};
	transition: ${props => getMultipleTransitionsWithWillChange(['border-color'], props.theme.transitionControl)};

	&:hover {
		border-bottom-color: ${props => props.theme.borderColorBase};
	}
	&:active,
	&:focus {
		border-bottom-color: ${props => props.theme.primaryColor};
	}

	&:disabled,
	&:read-only {
		background-color: ${props => props.theme.disabledBackgroundColor};
	}
	&:disabled {
		cursor: not-allowed;
	}
`;
const InputLabel = styled.span `
	position: absolute;
	font-size: ${props => numToCssSize(props.theme.fz.small2)};
	line-height: 1;
	bottom: ${props => numToCssSize(props.theme.controlHeightBase / 8)};
	left: 0;
	width: 100%;
	color: ${props => props.theme.textColorSecondary};
	font-weight: bold;
	text-align: right;
	${textEllipsisCss};
`;
const Label$1 = styled.label `
	display: block;
	padding: 0;
	padding-bottom: ${props => numToCssSize(props.theme.fz.small2 + props.theme.controlHeightBase / 4)};
	margin: ${props => numToCssSize(props.theme.controlHeightBase / 8)};
	height: ${props => numToCssSize(props.theme.controlHeightBase * 1.25)};
	position: relative;
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	width: 4em;

	&.${CONTROLCLASS$5}__year {
		width: 3em;
	}
	&.${CONTROLCLASS$5}__month {
		width: 4.8em;
	}
	&.${CONTROLCLASS$5}__day {
		width: 2em;
	}
	&.${CONTROLCLASS$5}__hour {
		width: 2em;
	}
	&.${CONTROLCLASS$5}__minute {
		width: 2em;
	}
	&.${CONTROLCLASS$5}__second {
		width: 2em;
	}
	&.${CONTROLCLASS$5}__ampm {
		width: auto;
		padding-bottom: 0;
		display: flex;
		align-items: center;
		justify-content: flex-start;
	}
`;
const Separator = styled.span `
	margin: 0 ${props => numToCssSize(props.theme.controlHeightBase / 8)};
	font-size: ${props => numToCssSize(props.theme.controlHeightBase * 0.5)};
	font-weight: bold;
	line-height: 1;
`;
const GroupContainer = styled.div `
	display: flex;
	flex: 0 0 auto;
	align-items: center;
	flex-flow: row nowrap;
	max-width: 100%;
	overflow-x: auto;
`;
const Prefix = styled.div `
	position: absolute;
	top: 0;
	left: ${props => numToCssSize(props.theme.controlHeightBase / 4)};
	bottom: 0;
	display: flex;
	align-items: center;
	justify-content: center;
	/** So that we can click through it to the input */
	pointer-events: none;
	color: ${props => props.theme.greyLightColor};
`;
const MaterialBorder = styled.div `
	position: absolute;
	height: 2px;
	bottom: -2px;
	left: 0;
	right: 0;
	transform-origin: 50% 50%;
	background-color: ${props => props.theme.primaryColor};
	pointer-events: none;
	transform: scaleX(0);
	transition: ${props => getMultipleTransitionsWithWillChange(['transform'], props.theme.transitionBeizer)};
`;
const Container$3 = styled.div `
	${cssReset};
	position: relative;

	display: flex;
	flex-flow: row wrap;
	align-items: center;
	justify-content: flex-start;
	width: 100%;
	min-height: ${props => numToCssSize(props.theme.controlHeightBase * 1.5)};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	box-shadow: 0 0 0 0 transparent;
	color: ${props => props.theme.textColor};
	padding: 0 ${props => numToCssSize(props.theme.controlHeightBase / 4)};
	border: 1px solid ${props => props.theme.borderColorBase};
	background-color: ${props => props.theme.appBackgroundColor};
	box-shadow: ${props => props.theme.boxShadowNoneFocus};
	transition: ${props => getMultipleTransitionsWithWillChange(['border-color', 'box-shadow'], props.theme.transitionControl)};

	&:hover {
		color: ${props => props.theme.textColor};
		border-color: ${props => props.theme.primaryColor};
	}

	&.${CONTROLCLASS$5}--is-focused {
		color: ${props => props.theme.textColor};
		border-color: ${props => props.theme.primaryColor};
		box-shadow: ${props => props.theme.boxShadowControlFocus};
	}

	&.${CONTROLCLASS$5}--has-error {
		border-color: ${props => props.theme.borderColorError};

		&:hover {
			border-color: ${props => props.theme.borderColorError};
		}

		&.${CONTROLCLASS$5}--is-focused {
			border-color: ${props => props.theme.borderColorError};
			box-shadow: ${props => props.theme.boxShadowControlFocusError};
		}
	}

	&.${CONTROLCLASS$5}--disabled {
		background-color: ${props => props.theme.disabledBackgroundColor};
		color: ${props => props.theme.disabledColor};
		border-color: ${props => props.theme.disabledColor};
		cursor: not-allowed;
		box-shadow: none;
		${Input$1} {
			border-bottom-color: ${props => props.theme.disabledColor};
		}
	}

	&.${CONTROLCLASS$5}--readonly {
		background-color: ${props => props.theme.disabledBackgroundColor};
		border-color: ${props => props.theme.disabledColor};
		box-shadow: none;
		${Input$1} {
			border-bottom-color: ${props => props.theme.disabledColor};
		}
	}

	&.${CONTROLCLASS$5}--type-MATERIAL {
		border: 0 none;
		border-bottom: 2px solid ${props => props.theme.borderColorBase};
		border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)}
			${props => numToCssSize(props.theme.borderRadiusBase)} 0 0;
		box-shadow: none;
		background-color: ${props => props.theme.backgroundControl};
		transition: ${props => getMultipleTransitionsWithWillChange(['background-color'], props.theme.transitionControl)};

		&:hover {
			border-color: ${props => props.theme.borderColorBase};
		}

		&.${CONTROLCLASS$5}--is-focused {
			background-color: ${props => curriedTransparentize(0.5, props.theme.backgroundControl)};
			border-color: ${props => props.theme.borderColorBase};
			box-shadow: none;
		}

		&:hover
			> ${MaterialBorder},
			&.${CONTROLCLASS$5}--is-focused
			> ${MaterialBorder} {
			transform: scaleX(1);
		}

		&.${CONTROLCLASS$5}--has-error {
			border-bottom-color: ${props => props.theme.borderColorError};

			&:hover {
				border-bottom-color: ${props => props.theme.borderColorError};
			}

			&.${CONTROLCLASS$5}--is-focused {
				border-bottom-color: ${props => props.theme.borderColorError};
			}

			> ${MaterialBorder} {
				background-color: ${props => props.theme.borderColorError};
			}
		}

		&.${CONTROLCLASS$5}--disabled {
			background-color: ${props => props.theme.disabledBackgroundColor};
			color: ${props => props.theme.disabledColor};
			border-color: ${props => props.theme.disabledColor};
			cursor: not-allowed;

			> ${MaterialBorder} {
				transform: scaleX(0);
				background-color: ${props => props.theme.disabledColor};
			}
		}

		&.${CONTROLCLASS$5}--readonly {
			background-color: ${props => props.theme.disabledBackgroundColor};
			border-color: ${props => props.theme.disabledColor};
			> ${MaterialBorder} {
				transform: scaleX(0);
				background-color: ${props => props.theme.disabledColor};
			}
		}
	}

	&.${CONTROLCLASS$5}--align-LEFT {
		justify-content: flex-start;
	}
	&.${CONTROLCLASS$5}--align-CENTER {
		justify-content: center;
	}
	&.${CONTROLCLASS$5}--align-RIGHT {
		justify-content: flex-end;
	}

	&.${CONTROLCLASS$5}--has-prefix {
		/** [gutter + prefix + gutter] where gutter is controlHeightBase / 4 & prefix is fz.base */
		padding-left: ${props => numToCssSize(props.theme.fz.base + (props.theme.controlHeightBase / 4) * 2)};
	}

	/** LABELS */
	&.${CONTROLCLASS$5}--hide-labels {
		min-height: ${props => numToCssSize(props.theme.controlHeightBase)};

		${InputLabel} {
			${screenReaderTextCss};
		}

		${Label$1} {
			padding-bottom: 0;
			height: ${props => numToCssSize(props.theme.controlHeightBase * 0.75 - 2)};
			&.${CONTROLCLASS$5}__month {
				width: 2em;
			}
		}

		${Input$1} {
			height: ${props => numToCssSize(props.theme.controlHeightBase * 0.75 - 2 - 2)};
			line-height: ${props => numToCssSize(props.theme.controlHeightBase * 0.75 - 2 - 2)};
		}
	}
`;

const generalDateTimeParseFormat = 'YYYY-MM-DD HH:mm:ss';
function getStateFromDayjsObj(dayjsObj, pickerType, timeType, hideSeconds) {
    let hour = null;
    let am = null;
    if (pickerType === 'datetime' || pickerType === 'time') {
        hour = dayjsObj.hour();
        // modify further if timeType is 12hrs
        if (timeType === '12hrs') {
            if (hour === 0) {
                // at 00 hour, we say 12:00AM
                hour = 12;
                am = true;
            }
            else if (hour === 12) {
                // at 12 hour, we say 12:00PM
                hour = 12;
                am = false;
            }
            else if (hour > 12) {
                // at 12+ hour, we say (hour-12)PM
                am = false;
                hour = hour - 12;
            }
            else {
                // at all hours, we say hourAM
                am = true;
            }
        }
    }
    const state = {
        year: pickerType === 'date' || pickerType === 'datetime'
            ? dayjsObj.year()
            : null,
        month: pickerType === 'date' || pickerType === 'datetime'
            ? dayjsObj.month() + 1
            : null,
        day: pickerType === 'date' || pickerType === 'datetime'
            ? dayjsObj.date()
            : null,
        hour,
        minute: pickerType === 'time' || pickerType === 'datetime'
            ? dayjsObj.minute()
            : null,
        second: pickerType === 'time' || pickerType === 'datetime'
            ? dayjsObj.second()
            : null,
        am,
    };
    if (hideSeconds) {
        state.second = 0;
    }
    return state;
}
function getStateFromValue(value, pickerType, format, timeType, hideSeconds) {
    const emptyState = {
        year: null,
        month: null,
        day: null,
        hour: null,
        minute: null,
        second: hideSeconds ? 0 : null,
        am: timeType === '24hrs' ? null : true,
    };
    if (value === '') {
        return emptyState;
    }
    const parsedValue = dayjs(value, format, true);
    if (!parsedValue.isValid()) {
        return emptyState;
    }
    return getStateFromDayjsObj(parsedValue, pickerType, timeType, hideSeconds);
}
function getDayJsObjFromState(state, pickerType, timeType, hideSeconds) {
    let dayjsObj = dayjs();
    if (pickerType === 'date' || pickerType === 'datetime') {
        if (state.day && state.month && state.year) {
            dayjsObj = dayjsObj
                .set('year', state.year)
                .set('month', state.month - 1)
                .set('date', state.day);
        }
        else {
            dayjsObj = dayjsObj.set('year', 0).set('month', 0).set('date', 0);
        }
    }
    if (pickerType === 'time' || pickerType === 'datetime') {
        let hour = state.hour ?? 0;
        if (timeType === '12hrs') {
            // hour set in state, cannot be greater than 12
            if (hour >= 12) {
                hour = 12;
            }
            if (state.am) {
                // when AM, if it is 12:00AM, it means 0000hours
                hour = hour === 12 ? 0 : hour;
            }
            else {
                // when PM, if it is 12:00PM, it means 1200hours
                hour = hour === 12 ? 12 : hour + 12;
            }
        }
        dayjsObj = dayjsObj
            .set('hour', hour)
            .set('minute', state.minute ?? 0)
            .set('second', state.second ?? 0);
    }
    else {
        dayjsObj = dayjsObj.set('hour', 0).set('minute', 0).set('second', 0);
    }
    if (hideSeconds) {
        dayjsObj.set('second', 0);
    }
    return dayjsObj;
}
function isStateErroneous(state, pickerType, timeType) {
    let erroneous = true;
    const isDateInValid = checkObjectPropertiesSomeHaveValue(state, ['day', 'month', 'year'], [null, 0]);
    const isTimeInValid = checkObjectPropertiesSomeHaveValue(state, ['hour', 'minute', 'second'], [null]);
    if (pickerType === 'datetime') {
        erroneous = isDateInValid || isTimeInValid;
    }
    else if (pickerType === 'date') {
        erroneous = isDateInValid;
    }
    else {
        erroneous = isTimeInValid;
    }
    // further erroneous if timeType is 12hrs and hour value is 0
    if ((pickerType === 'datetime' || pickerType === 'time') &&
        timeType === '12hrs' &&
        state.hour === 0) {
        erroneous = true;
    }
    return erroneous;
}
function isStateEmpty(state, pickerType) {
    let isEmpty = false;
    const isDateEmpty = checkObjectPropertiesAllHaveValue(state, ['day', 'month', 'year'], [null]);
    const isTimeEmpty = checkObjectPropertiesAllHaveValue(state, ['hour', 'minute', 'second'], [null]);
    if (pickerType === 'datetime') {
        isEmpty = isDateEmpty && isTimeEmpty;
    }
    else if (pickerType === 'date') {
        isEmpty = isDateEmpty;
    }
    else {
        isEmpty = isTimeEmpty;
    }
    return isEmpty;
}
function getUpdateValueFromState(state, pickerType, format, timeType, hideSeconds) {
    if (isStateErroneous(state, pickerType, timeType)) {
        return '';
    }
    const dayjsObj = getDayJsObjFromState(state, pickerType, timeType, hideSeconds);
    return dayjsObj.format(format);
}

const months = {
    1: __('Jan', 'wp-eform'),
    2: __('Feb', 'wp-eform'),
    3: __('Mar', 'wp-eform'),
    4: __('Apr', 'wp-eform'),
    5: __('May', 'wp-eform'),
    6: __('Jun', 'wp-eform'),
    7: __('Jul', 'wp-eform'),
    8: __('Aug', 'wp-eform'),
    9: __('Sep', 'wp-eform'),
    10: __('Oct', 'wp-eform'),
    11: __('Nov', 'wp-eform'),
    12: __('Dec', 'wp-eform'),
};
function DateTimePicker(props) {
    const { className, prefix, value, controlType = SettingsAppearanceControlTypeEnum.BOXY, controlAlignment = SettingsAppearanceControlAlignmentEnum.LEFT, hasError = false, pickerType, dateSeparator = '/', timeSeparator = ':', dateTimeSeparator = ',', onChange, onBlur, readOnly = false, disabled = false, minValue = '', maxValue = '', dateType = 'MMDDYYYY', timeType = '12hrs', showInputLabels = true, hideSeconds = false, id, } = props;
    // figure out the dateTimeFormat
    let dateTimeFormat;
    if (props.dateTimeFormat) {
        dateTimeFormat = props.dateTimeFormat;
    }
    else {
        dateTimeFormat = getDefaultDateTimeFormatString(pickerType);
    }
    const [focused, setFocused] = useState(false);
    // hold the parts locally
    const [localValue, setLocalValue] = useState(() => {
        return getStateFromValue(value, pickerType, dateTimeFormat, timeType, hideSeconds);
    });
    // refs to focus next inputs
    const focusTimerRef = useRef(null);
    const canFocusShiftRef = useRef(true);
    const focusNext = (event) => {
        // clear the previous focus queue
        if (focusTimerRef.current) {
            window.clearTimeout(focusTimerRef.current);
        }
        // if cannot shift focus, then bail
        if (!canFocusShiftRef.current) {
            return;
        }
        // now try to find the next focusable element
        let focusContainer = event.target.closest(`.${GENERICINPUTCLASS}`)?.nextElementSibling;
        // if the next one is a separator
        if (focusContainer?.tagName === 'SPAN') {
            focusContainer = focusContainer.nextElementSibling;
        }
        if (!focusContainer) {
            // try to find in the next group
            focusContainer = event.target
                .closest(`.${GENERICGROUPCLASS}`)
                ?.nextElementSibling?.querySelector(`.${GENERICINPUTCLASS}`);
        }
        if (focusContainer) {
            const focusElement = focusContainer.querySelector('input, select');
            if (focusElement) {
                focusTimerRef.current = window.setTimeout(() => {
                    focusElement.focus();
                }, 50);
            }
        }
    };
    // create updater functions for each part
    const updateYear = (event) => {
        if (event.target.value === '') {
            setLocalValue(currentValue => ({ ...currentValue, year: null }));
            return;
        }
        // don't do anything if input value is greater than 9999
        const newValue = getIntValueGreaterThan(event.target.value, 1, 0);
        setLocalValue(currentValue => {
            const currentYear = currentValue.year;
            return {
                ...currentValue,
                year: newValue > 9999 ? currentYear ?? 9999 : newValue,
            };
        });
        if (event.target.value.length >= 4) {
            focusNext(event);
        }
    };
    const updateMonth = (event) => {
        if (event.target.value === '') {
            setLocalValue(currentValue => ({ ...currentValue, month: null }));
            return;
        }
        let newValue = getIntValueGreaterThan(event.target.value, 0, 0);
        if (newValue > 12) {
            newValue = 12;
        }
        setLocalValue(currentValue => ({ ...currentValue, month: newValue }));
        if (event.target.value.length >= 2) {
            focusNext(event);
        }
    };
    const updateDay = (event) => {
        if (event.target.value === '') {
            setLocalValue(currentValue => ({ ...currentValue, day: null }));
            return;
        }
        let newValue = getIntValueGreaterThan(event.target.value, 0, 0);
        setLocalValue(currentValue => {
            const currentMonth = currentValue.month;
            const currentYear = currentValue.year;
            let maxDate = 31;
            if (currentMonth && currentYear) {
                const dayjsObj = dayjs()
                    .set('month', currentMonth - 1)
                    .set('year', currentYear)
                    .set('date', 1);
                maxDate = dayjsObj.daysInMonth();
            }
            if (newValue > maxDate) {
                newValue = maxDate;
            }
            return {
                ...currentValue,
                day: newValue,
            };
        });
        if (event.target.value.length >= 2) {
            focusNext(event);
        }
    };
    const updateHour = (event) => {
        if (event.target.value === '') {
            setLocalValue(currentValue => ({ ...currentValue, hour: null }));
            return;
        }
        let newValue = getIntValueGreaterThan(event.target.value, 0, 0);
        const maxHrValue = timeType === '12hrs' ? 12 : 23;
        if (newValue > maxHrValue) {
            newValue = maxHrValue;
        }
        setLocalValue(currentValue => ({ ...currentValue, hour: newValue }));
        if (event.target.value.length >= 2) {
            focusNext(event);
        }
    };
    const updateMinute = (event) => {
        if (event.target.value === '') {
            setLocalValue(currentValue => ({ ...currentValue, minute: null }));
            return;
        }
        let newValue = getIntValueGreaterThan(event.target.value, 0, 0);
        if (newValue > 59) {
            newValue = 59;
        }
        setLocalValue(currentValue => ({ ...currentValue, minute: newValue }));
        if (event.target.value.length >= 2) {
            focusNext(event);
        }
    };
    const updateSecond = (event) => {
        if (event.target.value === '') {
            setLocalValue(currentValue => ({ ...currentValue, second: null }));
            return;
        }
        let newValue = getIntValueGreaterThan(event.target.value, 0, 0);
        if (newValue > 59) {
            newValue = 59;
        }
        setLocalValue(currentValue => ({ ...currentValue, second: newValue }));
        if (event.target.value.length >= 2) {
            focusNext(event);
        }
    };
    const updateAmPm = (event) => {
        if (event.target.value === 'am') {
            setLocalValue(currentValue => ({ ...currentValue, am: true }));
        }
        else {
            setLocalValue(currentValue => ({ ...currentValue, am: false }));
        }
    };
    // update parent state
    const debouncedOnChange = useDebouncedCallback((newValue, typeOfPicker, updater, format, timeTypeValue) => {
        // make sure the state is not erroneous
        const erroneous = isStateErroneous(newValue, typeOfPicker, timeTypeValue);
        if (erroneous) {
            // if it is empty, then pass along an empty string
            if (isStateEmpty(newValue, typeOfPicker)) {
                updater('');
            }
            return;
        }
        const updateValue = getUpdateValueFromState(newValue, typeOfPicker, format, timeTypeValue, hideSeconds);
        updater(updateValue);
    }, 300);
    // adjuster function to be called in onBlur event only
    const adjuster = () => {
        let isChangeNeeded = false;
        let changedValue = { ...localValue };
        if (isStateErroneous(changedValue, pickerType, timeType)) {
            // but do change 0 month, 0 year and 0 day to something feasible
            if (changedValue.year === 0) {
                isChangeNeeded = true;
                changedValue.year = 1;
            }
            if (changedValue.month === 0) {
                isChangeNeeded = true;
                changedValue.month = 1;
            }
            if (changedValue.day === 0) {
                isChangeNeeded = true;
                changedValue.day = 1;
            }
            if ((pickerType === 'time' || pickerType === 'datetime') &&
                timeType === '12hrs' &&
                changedValue.hour === 0) {
                isChangeNeeded = true;
                changedValue.hour = 1;
            }
        }
        else {
            if (pickerType === 'date' || pickerType === 'datetime') {
                // check for max days in a month
                if (changedValue.month && changedValue.year && changedValue.day) {
                    const dayjsObj = dayjs()
                        .set('month', changedValue.month - 1)
                        .set('year', changedValue.year);
                    const maxDay = dayjsObj.daysInMonth();
                    if (changedValue.day > maxDay) {
                        isChangeNeeded = true;
                        changedValue.day = maxDay;
                    }
                }
            }
            if (pickerType === 'datetime' ||
                (pickerType === 'time' && timeType === '12hrs')) {
                if (changedValue.hour === 0) {
                    isChangeNeeded = true;
                    changedValue.hour = 1;
                }
            }
            const currentDayJsObj = getDayJsObjFromState(localValue, pickerType, timeType, hideSeconds);
            let minDayJsObj = minValue === '' ? false : dayjs(minValue, dateTimeFormat);
            let maxDayJsObj = maxValue === '' ? false : dayjs(maxValue, dateTimeFormat);
            // if min and max checks out
            if (minDayJsObj &&
                maxDayJsObj &&
                minDayJsObj.isValid() &&
                maxDayJsObj.isValid()) {
                if (!minDayJsObj.isBefore(maxDayJsObj) &&
                    !minDayJsObj.isSame(maxDayJsObj)) {
                    console.warn('Invalid min and max value passed to DateTimePicker. Omitting.', minValue, maxValue);
                    minDayJsObj = false;
                    maxDayJsObj = false;
                }
            }
            // check for minValue
            if (minDayJsObj) {
                if (minDayJsObj.isValid() && minDayJsObj.isAfter(currentDayJsObj)) {
                    isChangeNeeded = true;
                    changedValue = getStateFromDayjsObj(minDayJsObj, pickerType, timeType, hideSeconds);
                }
            }
            // check for maxValue
            if (maxDayJsObj) {
                if (maxDayJsObj.isValid() && maxDayJsObj.isBefore(currentDayJsObj)) {
                    isChangeNeeded = true;
                    changedValue = getStateFromDayjsObj(maxDayJsObj, pickerType, timeType, hideSeconds);
                }
            }
        }
        if (isChangeNeeded) {
            setLocalValue(changedValue);
        }
        // queue an update to parent
        if (!isStateErroneous(changedValue, pickerType, timeType)) {
            debouncedOnChange(changedValue, pickerType, onChange, dateTimeFormat, timeType);
        }
        else if (isStateEmpty(changedValue, pickerType)) {
            debouncedOnChange(changedValue, pickerType, onChange, dateTimeFormat, timeType);
        }
    };
    // sync back from parent
    const previousValue = usePrevious(value);
    useEffect(() => {
        if (value === previousValue) {
            return;
        }
        const newValue = getUpdateValueFromState(localValue, pickerType, dateTimeFormat, timeType, hideSeconds);
        if (newValue !== value) {
            setLocalValue(getStateFromValue(value, pickerType, dateTimeFormat, timeType, hideSeconds));
        }
    }, [
        value,
        pickerType,
        localValue,
        dateTimeFormat,
        previousValue,
        timeType,
        hideSeconds,
    ]);
    const containerClasses = getBemClassName(CONTROLCLASS$5, {
        'has-prefix': !!prefix,
        'is-not-empty': value !== '',
        'is-focused': focused,
        [`type-${controlType}`]: true,
        'has-error': hasError,
        [`align-${controlAlignment}`]: true,
        readonly: readOnly,
        disabled,
        'hide-labels': !showInputLabels,
    }, className);
    const isMounted = useIsMounted();
    const commonInputProps = {
        onFocus: () => {
            setFocused(true);
        },
        onBlur: (event) => {
            adjuster();
            canFocusShiftRef.current = true;
            setFocused(false);
            setTimeout(() => {
                const container = event.target.closest(`.${CONTROLCLASS$5}`);
                if (isMounted.current &&
                    container &&
                    container.querySelectorAll(':focus').length === 0 &&
                    onBlur) {
                    onBlur();
                }
            }, 200);
        },
        readOnly,
        disabled,
        onKeyDown: (event) => {
            if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                canFocusShiftRef.current = false;
            }
            else {
                canFocusShiftRef.current = true;
            }
        },
    };
    const dateSeparatorChild = dateSeparator ? (jsx(Separator, { children: dateSeparator }, void 0)) : null;
    const timeSeparatorChild = timeSeparator ? (jsx(Separator, { children: timeSeparator }, void 0)) : null;
    const dateTimeSeparatorChild = dateTimeSeparator ? (jsx(Separator, { children: dateTimeSeparator }, void 0)) : null;
    const currentTime = useRef(dayjs());
    const datePickerParts = {
        yy: (jsxs(Label$1, Object.assign({ className: YEARINPUTCLASS }, { children: [jsx(InputLabel, { children: __('YEAR', 'wp-eform') }, void 0), jsx(Input$1, Object.assign({ value: localValue.year ?? '', type: "number", min: 0, max: 9999, step: 1, onChange: updateYear, title: __('YEAR', 'wp-eform'), placeholder: showInputLabels
                        ? currentTime.current.format('YYYY')
                        : __('YYYY', 'wp-eform') }, commonInputProps), void 0)] }), void 0)),
        mm: (jsxs(Label$1, Object.assign({ className: MONTHINPUTCLASS }, { children: [jsx(InputLabel, { children: __('MONTH', 'wp-eform') }, void 0), jsxs(MonthSelect, Object.assign({ value: localValue.month?.toString() ?? '', onChange: updateMonth, title: __('MONTH', 'wp-eform'), className: classNames({ 'is-empty': localValue.month === null }) }, commonInputProps, { children: [jsx("option", Object.assign({ value: "", disabled: true, hidden: true }, { children: showInputLabels
                                ? _x('----', 'month-select-placeholder', 'wp-eform')
                                : __('MONTH', 'wp-eform') }), void 0), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map(m => (jsx("option", Object.assign({ value: m.toString() }, { children: months[m] }), m)))] }), void 0)] }), void 0)),
        dd: (jsxs(Label$1, Object.assign({ className: DAYINPUTCLASS }, { children: [jsx(InputLabel, { children: __('DAY', 'wp-eform') }, void 0), jsx(Input$1, Object.assign({ value: localValue.day ?? '', type: "number", min: 0, step: 1, max: 31, onChange: updateDay, title: __('DAY', 'wp-eform'), placeholder: showInputLabels
                        ? currentTime.current.format('DD')
                        : __('DD', 'wp-eform') }, commonInputProps), void 0)] }), void 0)),
    };
    let datePickerOrder = ['yy', 'mm', 'dd'];
    if (dateType === 'DDMMYYYY') {
        datePickerOrder = ['dd', 'mm', 'yy'];
    }
    else if (dateType === 'MMDDYYYY') {
        datePickerOrder = ['mm', 'dd', 'yy'];
    }
    else if (dateType === 'YYYYDDMM') {
        datePickerOrder = ['yy', 'dd', 'mm'];
    }
    else if (dateType === 'YYYYMMDD') {
        datePickerOrder = ['yy', 'mm', 'dd'];
    }
    return (jsxs(Container$3, Object.assign({ className: containerClasses, id: id }, { children: [prefix ? jsx(Prefix, { children: prefix }, void 0) : null, pickerType === 'date' || pickerType === 'datetime' ? (jsxs(GroupContainer, Object.assign({ className: DATECONTAINERCLASS }, { children: [datePickerOrder.map((order, index) => (jsxs(React__default.Fragment, { children: [datePickerParts[order], index !== 2 ? dateSeparatorChild : null] }, order))), pickerType === 'datetime' ? dateTimeSeparatorChild : null] }), void 0)) : null, pickerType === 'time' || pickerType === 'datetime' ? (jsxs(GroupContainer, Object.assign({ className: TIMECONTAINERCLASS }, { children: [jsxs(Label$1, Object.assign({ className: HOURINPUTCLASS }, { children: [jsx(InputLabel, { children: __('HR', 'wp-eform') }, void 0), jsx(Input$1, Object.assign({ value: localValue.hour ?? '', type: "number", min: timeType === '12hrs' ? 1 : 0, step: 1, max: timeType === '12hrs' ? 12 : 23, onChange: updateHour, title: __('HOUR', 'wp-eform'), placeholder: showInputLabels
                                    ? currentTime.current.format(timeType === '12hrs' ? 'hh' : 'HH')
                                    : __('HR', 'wp-eform') }, commonInputProps), void 0)] }), void 0), timeSeparatorChild, jsxs(Label$1, Object.assign({ className: MINUTEINPUTCLASS }, { children: [jsx(InputLabel, { children: __('MIN', 'wp-eform') }, void 0), jsx(Input$1, Object.assign({ value: localValue.minute ?? '', type: "number", min: 0, step: 1, max: 59, onChange: updateMinute, title: __('MINUTE', 'wp-eform'), placeholder: showInputLabels ? '00' : __('MIN', 'wp-eform') }, commonInputProps), void 0)] }), void 0), !hideSeconds ? (jsxs(Fragment, { children: [timeSeparatorChild, jsxs(Label$1, Object.assign({ className: SECONDINPUTCLASS }, { children: [jsx(InputLabel, { children: __('SEC', 'wp-eform') }, void 0), jsx(Input$1, Object.assign({ value: localValue.second ?? '', type: "number", min: 0, step: 1, max: 59, onChange: updateSecond, title: __('SECOND', 'wp-eform'), placeholder: showInputLabels ? '00' : __('SEC', 'wp-eform') }, commonInputProps), void 0)] }), void 0)] }, void 0)) : null, timeType === '12hrs' ? (jsx(Label$1, Object.assign({ className: AMPMSELECTCLASS }, { children: jsxs(AmPmSelect, Object.assign({ value: localValue.am ? 'am' : 'pm', onChange: updateAmPm, onBlur: () => {
                                adjuster();
                                setFocused(false);
                                canFocusShiftRef.current = true;
                            }, onFocus: () => {
                                setFocused(true);
                            }, disabled: disabled || readOnly }, { children: [jsx("option", Object.assign({ value: "am" }, { children: __('AM', 'wp-eform') }), void 0), jsx("option", Object.assign({ value: "pm" }, { children: __('PM', 'wp-eform') }), void 0)] }), void 0) }), void 0)) : null] }), void 0)) : null, controlType === SettingsAppearanceControlTypeEnum.MATERIAL ? (jsx(MaterialBorder, {}, void 0)) : null] }), void 0));
}

const CONTROLCLASS$4 = 'wpeform-control-matrix-choice';
// We need this centerer because text-align center kinda breaks the radio appearance
const Centerer = styled.div `
	width: 100%;
	display: flex;
	align-items: center;
	justify-content: center;
	text-align: left;
	transform: translate3d(0, 0, 0);
	@media (-webkit-min-device-pixel-ratio: 1.25), (min-resolution: 120dpi) {
		.${CONTROLCLASS$h}, .${CONTROLCLASS$i} {
			.${CONTROLCLASS$j} {
				position: relative;
				top: 0.5px;
				left: 0.5px;
			}
		}
	}
`;
function MatrixChoice(props) {
    const { className, rows, columns, value, onChange, fixedLayout = true, highlightOnHover = true, tableType = 'stripped', rowHeadingWidth = '180px', namePrefix, multiple = false, icon = 'fas fa-check', ...inputProps } = props;
    const theme = useTheme();
    const colWidth = useMemo(() => numToCssSize(theme.controlHeightBase + theme.gutter), [theme]);
    return (jsxs(Table, Object.assign({ className: getBemClassName(CONTROLCLASS$4, undefined, className), fixedLayout: fixedLayout, highlightOnHover: highlightOnHover, type: tableType, isBodyCentered: true }, { children: [jsx("thead", { children: jsxs("tr", { children: [jsx("th", { style: { width: rowHeadingWidth } }, void 0), columns.map(col => (jsx("th", Object.assign({ style: { width: col.width ?? colWidth }, id: `col-${col.id}` }, { children: col.title }), col.id)))] }, void 0) }, void 0), jsx("tbody", { children: rows.map(row => {
                    const rowValue = value.find(v => v.rowId === row.id);
                    return (jsxs("tr", { children: [jsx("th", Object.assign({ style: { width: rowHeadingWidth }, id: `row-${row.id}` }, { children: row.title }), void 0), columns.map(col => {
                                const checked = rowValue?.columns.length && rowValue.columns.includes(col.id)
                                    ? true
                                    : false;
                                const changeHandler = (chked) => {
                                    if (!multiple) {
                                        if (chked) {
                                            onChange(row.id, [col.id]);
                                        }
                                    }
                                    else {
                                        const existingColumns = rowValue?.columns ?? [];
                                        const newColumns = chked
                                            ? deDupArray([...existingColumns, col.id])
                                            : removeItemInArray(existingColumns, col.id);
                                        onChange(row.id, newColumns);
                                    }
                                };
                                return (jsx("td", Object.assign({ style: { width: col.width ?? colWidth } }, { children: jsx(Centerer, { children: multiple ? (jsx(Checkbox, Object.assign({ checked: checked, onChange: changeHandler, icon: icon }, inputProps, { name: namePrefix ? `${namePrefix}[${row.id}]` : undefined, ariaLabelledby: `row-${row.id} col-${col.id}` }), void 0)) : (jsx(Radio$1, Object.assign({ checked: checked, onChange: changeHandler, icon: icon }, inputProps, { name: namePrefix ? `${namePrefix}[${row.id}]` : undefined, ariaLabelledby: `row-${row.id} col-${col.id}` }), void 0)) }, void 0) }), col.id));
                            })] }, row.id));
                }) }, void 0), jsx("tfoot", { children: jsxs("tr", { children: [jsx("th", { style: { width: rowHeadingWidth } }, void 0), columns.map(col => (jsx("th", Object.assign({ style: { width: colWidth } }, { children: col.title }), col.id)))] }, void 0) }, void 0)] }), void 0));
}

const CONTROLCLASS$3 = 'wpeform-control-matrix-input';
function MatrixInput(props) {
    const { className, rows, columns, value, onChange, fixedLayout = true, highlightOnHover = true, tableType = 'stripped', multiline = false, rowHeadingWidth = '180px', namePrefix, icon = '', ...inputProps } = props;
    const theme = useTheme();
    const colWidth = useMemo(() => numToCssSize(theme.controlHeightBase * 8 + theme.gutter), [theme]);
    return (jsxs(Table, Object.assign({ className: getBemClassName(CONTROLCLASS$3, undefined, className), fixedLayout: fixedLayout, highlightOnHover: highlightOnHover, type: tableType }, { children: [jsx("thead", { children: jsxs("tr", { children: [jsx("th", { style: { width: rowHeadingWidth } }, void 0), columns.map(col => (jsx("th", Object.assign({ style: { width: col.width ?? colWidth }, id: `col-${col.id}` }, { children: col.title }), col.id)))] }, void 0) }, void 0), jsx("tbody", { children: rows.map(row => (jsxs("tr", { children: [jsx("th", Object.assign({ style: { width: rowHeadingWidth }, id: `row-${row.id}` }, { children: row.title }), void 0), columns.map(col => {
                            const commonProps = {
                                value: value.find(val => val.rowId === row.id && val.columnId === col.id)?.value ?? '',
                                onChange: (newVal) => {
                                    onChange(row.id, col.id, newVal);
                                },
                                name: namePrefix
                                    ? `${namePrefix}[${row.id}][${col.id}]`
                                    : undefined,
                                ariaLabelledby: `row-${row.id} col-${col.id}`,
                                prefix: icon === '' ? undefined : jsx(Icon, { iconClass: icon }, void 0),
                            };
                            return (jsx("td", Object.assign({ style: { width: col.width ?? colWidth } }, { children: multiline ? (jsx(Textarea, Object.assign({}, inputProps, commonProps, { minRows: 4, maxRows: 4 }), void 0)) : (jsx(Text, Object.assign({}, inputProps, commonProps), void 0)) }), col.id));
                        })] }, row.id))) }, void 0), jsx("tfoot", { children: jsxs("tr", { children: [jsx("th", { style: { width: rowHeadingWidth } }, void 0), columns.map(col => (jsx("th", Object.assign({ style: { width: col.width ?? colWidth } }, { children: col.title }), col.id)))] }, void 0) }, void 0)] }), void 0));
}

const CONTROLCLASS$2 = 'wpeform-control-rating';
const RATINGITEMCLASS = getBemElement(CONTROLCLASS$2, 'item');
const RATINGICONCLASS = getBemElement(CONTROLCLASS$2, 'icon');
const RATINGINPUTCLASS = getBemElement(CONTROLCLASS$2, 'input');
const IconContainer = styled.div `
	position: relative;
	z-index: 10;
	font-size: ${props => numToCssSize(props.theme.controlHeightBase)};
	padding: ${props => numToCssSize(props.theme.gutter / 4)};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	border: 1px solid ${props => curriedTransparentize(1, props.theme.primaryColor)};
	box-shadow: ${props => props.theme.boxShadowNoneFocus};
	transition: ${props => getMultipleTransitionsWithWillChange(['border', 'box-shadow'], props.theme.transitionControl)};
	display: flex;
	align-items: center;
	justify-content: center;
`;
const selectedAnimation = (color1, color2, color3) => keyframes `
	0% {
		color: ${color1};
	}
	50%,
	70%,
	90% {
		color: ${color2};
	}
	60%,
	80%,
	100% {
		color: ${color3};
	}
`;
const RatingItemContainer = styled.label `
	height: ${props => numToCssSize(props.theme.controlHeightBase + props.theme.gutter / 2)};
	width: ${props => numToCssSize(props.theme.controlHeightBase + props.theme.gutter / 2)};
	flex: 0 0
		${props => numToCssSize(props.theme.controlHeightBase + props.theme.gutter / 2)};
	color: ${props => props.theme.borderColorBase};
	position: relative;
	cursor: pointer;
	transition: ${props => getMultipleTransitionsWithWillChange(['color', 'transform'], props.theme.transitionControl)};
	transform: scale(1, 1);
	transform-origin: bottom center;

	&.${RATINGITEMCLASS}--isActive {
		color: ${props => props.theme.primaryColor};
	}
	&.${RATINGITEMCLASS}--isHovered {
		color: ${props => props.theme.primaryColor};
		z-index: 10;
		transform: scale(1.1, 1.1);
	}
	&.${RATINGITEMCLASS}--isSelected {
		color: ${props => props.theme.primaryColor};
		animation: ${props => selectedAnimation(curriedLighten(0.05, props.theme.primaryColor), props.theme.primaryColor, curriedDarken(0.05, props.theme.primaryColor))}
			1000ms ease-in forwards;
	}
	&.${RATINGITEMCLASS}--disabled {
		cursor: not-allowed;
		transform: scale(1, 1);
	}
`;
const Radio = styled.input `
	position: absolute;
	top: 0;
	left: 0;
	margin: 0;
	opacity: 0;

	&:focus-visible:not(:disabled) {
		+ ${IconContainer} {
			box-shadow: ${props => props.theme.boxShadowControlFocus};
			border-color: ${props => props.theme.primaryColor};
		}
	}

	&:disabled {
		+ ${IconContainer} {
			color: ${props => props.theme.disabledColor};
		}
		&:checked {
			+ ${IconContainer} {
				color: ${props => props.theme.borderColorBase};
			}
		}
	}
`;
const Container$2 = styled.div `
	width: 100%;
	display: flex;
	flex-flow: row wrap;
	justify-content: flex-start;

	&.${CONTROLCLASS$2}--align-CENTER {
		justify-content: center;
	}
	&.${CONTROLCLASS$2}--align-RIGHT {
		justify-content: flex-end;
	}
`;

function Item$1(props) {
    const { index, selected, onChange, hoverIndex, setHoverIndex, item, ...inputProps } = props;
    return (jsxs(RatingItemContainer, Object.assign({ className: getBemClassName(RATINGITEMCLASS, {
            isActive: hoverIndex === null
                ? selected !== null && selected >= index
                : hoverIndex >= index,
            isSelected: selected === index,
            isHovered: hoverIndex === index,
            disabled: inputProps.disabled ?? false,
        }), onMouseOver: () => {
            setHoverIndex(index);
        } }, { children: [jsx(Radio, Object.assign({}, inputProps, { checked: index === selected, onChange: e => {
                    if (e.target.checked) {
                        onChange(index);
                    }
                }, className: RATINGINPUTCLASS, type: "radio" }), void 0), jsx(IconContainer, Object.assign({ className: RATINGICONCLASS }, { children: jsx(Icon, { iconClass: item.icon }, void 0) }), void 0)] }), void 0));
}

function Rating(props) {
    const { className, value, onChange, items, controlAlignment = SettingsAppearanceControlAlignmentEnum.LEFT, disabled = false, id, hasError = false, ...inputProps } = props;
    const [hoverIndex, setHoverIndex] = useState(null);
    return (jsx(Container$2, Object.assign({ className: getBemClassName(CONTROLCLASS$2, {
            hasError,
            disabled,
            [`align-${controlAlignment}`]: true,
        }, className), onMouseOut: () => {
            setHoverIndex(null);
        } }, { children: items.map((item, index) => (createElement(Item$1, { id: `${id ?? ''}${item.id}`, index: index, selected: value, onChange: onChange, item: item, hoverIndex: hoverIndex, setHoverIndex: setHoverIndex, ...inputProps, disabled: disabled, key: item.id }))) }), void 0));
}

const CONTROLCLASS$1 = 'wpeform-control-sortable';
const LISTCLASS = getBemElement(CONTROLCLASS$1, 'list');
const LISTITEMCLASS = getBemElement(CONTROLCLASS$1, 'list-item');
const ITEMCONTAINERLCASS = getBemElement(CONTROLCLASS$1, 'list-item-container');
const ITEMICONCLASS = getBemElement(CONTROLCLASS$1, 'list-item-icon');
const ITEMLABELCLASS = getBemElement(CONTROLCLASS$1, 'list-item-label');
const List = styled.ul `
	list-style: none;
	margin: 0;
	padding: ${props => numToCssSize(props.theme.gutter / 2)};
	background-color: ${props => props.theme.appBackgroundColor};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color'], props.theme.transitionControl)};
	&.${LISTCLASS}--isDragged {
		background-color: ${props => props.theme.backgroundShade};
	}
`;
const ItemIcon = styled.span `
	flex: 0 0 ${props => numToCssSize(props.theme.fz.base * 1.5)};
	width: ${props => numToCssSize(props.theme.fz.base * 1.5)};
	height: ${props => numToCssSize(props.theme.fz.base * 1.5)};
	font-size: ${props => numToCssSize(props.theme.fz.small1)};
	color: ${props => props.theme.borderColorBase};
	display: flex;
	align-items: center;
	justify-content: flex-start;
	margin: 0 0 0 ${props => numToCssSize(props.theme.gutter / 2)};
`;
const ItemLabel = styled.div `
	flex: 0 0
		calc(
			100% -
				${props => numToCssSize(props.theme.fz.base * 1.5 + props.theme.gutter / 2)}
		);
	width: calc(
		100% -
			${props => numToCssSize(props.theme.fz.base * 1.5 + props.theme.gutter / 2)}
	);
	color: ${props => props.theme.textColor};
`;
const ItemContainer = styled.div `
	color: ${props => props.theme.textColor};
	padding: ${props => numToCssSize(props.theme.gutter / 2)};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
	line-height: 1.2;
	border: 1px solid ${props => props.theme.borderColorLight};
	border-radius: ${props => numToCssSize(props.theme.borderRadiusBase)};
	margin: 0;
	font-family: ${props => props.theme.fontFamilyBody};
	background-color: ${props => props.theme.appBackgroundColor};
	display: flex;
	align-items: center;
	justify-content: flex-start;
	box-shadow: ${props => props.theme.boxShadowBottom},
		${props => props.theme.boxShadowNoneFocus};
	transition: ${props => getMultipleTransitionsWithWillChange(['background-color', 'border-color', 'box-shadow'], props.theme.transitionControl)};
`;
const Item = styled.li `
	list-style: none;
	margin: 0 0 ${props => numToCssSize(props.theme.gutter / 2)} 0;
	padding: 0;
	cursor: grab;
	z-index: 9999999;

	&:hover {
		${ItemContainer} {
			border-color: ${props => props.theme.borderColorSplit};
		}
	}

	&:focus {
		outline: none;
		${ItemContainer} {
			box-shadow: ${props => props.theme.boxShadowBottom},
				${props => props.theme.boxShadowControlFocus};
			border-color: ${props => props.theme.primaryColor};
		}
	}

	&.${LISTITEMCLASS}--isSelected {
		outline: none;
		${ItemContainer} {
			background-color: ${props => props.theme.backgroundSelected};
			box-shadow: ${props => props.theme.boxShadowBottom},
				${props => props.theme.boxShadowControlFocus};
			border-color: ${props => props.theme.primaryColor};
		}
	}

	&.${LISTITEMCLASS}--isDragged {
		cursor: grabbing;
		${ItemContainer} {
			background-color: ${props => props.theme.backgroundControl};
			border-color: ${props => props.theme.borderColorBase};
		}
	}

	&.${LISTITEMCLASS}--isOutOfBounds {
		cursor: not-allowed;
		${ItemContainer} {
			background-color: ${props => props.theme.errorBackgroundColor};
			border-color: ${props => props.theme.errorColor};
		}
	}
`;
const Container$1 = styled.div `
	${cssReset};
`;

function Sortable(props) {
    const { currentOrder, updateOrder, items, className, lockVertically = false, } = props;
    const container = useResponsiveOuterContainerRef();
    return (jsx(Container$1, Object.assign({ className: getBemClassName(CONTROLCLASS$1, undefined, className) }, { children: jsx(List$1, { lockVertically: lockVertically, values: currentOrder, onChange: ({ oldIndex, newIndex }) => {
                updateOrder(arrayMove(currentOrder, oldIndex, newIndex));
            }, getKey: item => item, renderList: ({ children, isDragged, props: listProps }) => (jsx(List, Object.assign({ className: getBemClassName(LISTCLASS, { isDragged }) }, listProps, { children: children }), void 0)), renderItem: ({ isDragged, isOutOfBounds, isSelected, props: itemProps, value, }) => (jsx(Item, Object.assign({ className: getBemClassName(LISTITEMCLASS, {
                    isDragged,
                    isOutOfBounds,
                    isSelected,
                }) }, itemProps, { children: jsxs(ItemContainer, Object.assign({ className: ITEMCONTAINERLCASS }, { children: [jsx(ItemLabel, Object.assign({ className: ITEMLABELCLASS }, { children: items.find(i => i.id === value)?.label ??
                                __('UNKNOWN ITEM', 'wp-eform') }), void 0), jsx(ItemIcon, Object.assign({ className: ITEMICONCLASS }, { children: jsx(Icon, { iconClass: "fas fa-grip-lines" }, void 0) }), void 0)] }), void 0) }), void 0)), container: container }, void 0) }), void 0));
}

const CONTROLCLASS = 'wpeform-control-toggle';
const CONTROLWRAPPERCLASS = getBemElement(CONTROLCLASS, 'control-wrapper');
const LABELCLASS = getBemElement(CONTROLCLASS, 'label');
const SWITCHCONTAINERCLASS = getBemElement(CONTROLCLASS, 'switch');
const INPUTCLASS = getBemElement(CONTROLCLASS, 'input');
const TOGGLETRACKCLASS = getBemElement(CONTROLCLASS, 'toggle-wrap');
const TOGGLEKNOBCLASS = getBemElement(CONTROLCLASS, 'toggle-thumb');
const TOGGLEACTIVEICONCLASS = getBemElement(CONTROLCLASS, 'icon-active');
const TOGGLEINACTIVEICONCLASS = getBemElement(CONTROLCLASS, 'icon-inactive');
const TOGGLETRACKWIDTH = 1.4;
const TOGGLETRACKHEIGHT = 0.7;
const TOGGLEKNOBHEIGHT = 0.6;
const TOGGLEKNOBGUTTER = (TOGGLETRACKHEIGHT - TOGGLEKNOBHEIGHT) / 2;
const TOGGLEKNOBACTIVELEFT = TOGGLETRACKWIDTH - TOGGLEKNOBHEIGHT - TOGGLEKNOBGUTTER;
const TOGGLEKNOBINACTIVELEFT = TOGGLEKNOBGUTTER;
const Label = styled.label `
	width: calc(
		100% -
			${props => numToCssSize(props.theme.controlHeightBase * TOGGLETRACKWIDTH + props.theme.gutter)}
	);
	flex: 0 0
		calc(
			100% -
				${props => numToCssSize(props.theme.controlHeightBase * TOGGLETRACKWIDTH +
    props.theme.gutter)}
		);
	margin: 0 0 0 ${props => numToCssSize(props.theme.gutter)};
	/* color: ${props => props.theme.textColor}; */
`;
const SwitchContainer = styled.div `
	width: ${props => numToCssSize(props.theme.controlHeightBase * TOGGLETRACKWIDTH)};
	flex: 0 0
		${props => numToCssSize(props.theme.controlHeightBase * TOGGLETRACKWIDTH)};
	position: relative;
`;
const ControlWrapper = styled.div `
	display: flex;
	flex-flow: row nowrap;
	line-height: ${props => numToCssSize(props.theme.controlHeightBase * TOGGLETRACKHEIGHT)};
	font-size: ${props => numToCssSize(props.theme.fz.base)};
`;
const ToggleKnob = styled(animated.div) `
	touch-action: pan-y;
	position: absolute;
	top: ${props => numToCssSize(props.theme.controlHeightBase * TOGGLEKNOBGUTTER)};
	height: ${props => numToCssSize(props.theme.controlHeightBase * TOGGLEKNOBHEIGHT)};
	width: ${props => numToCssSize(props.theme.controlHeightBase * TOGGLEKNOBHEIGHT)};
	border-radius: ${props => numToCssSize(props.theme.controlHeightBase * TOGGLEKNOBHEIGHT)};
	background-color: ${props => props.theme.appBackgroundColor};
	box-shadow: ${props => props.theme.boxShadow2dp},
		${props => props.theme.boxShadowNoneFocus};
	transition: ${props => getMultipleTransitionsWithWillChange(['box-shadow', 'background-color', 'transform', 'width'], props.theme.transitionControl, ['left'])};
	cursor: grab;
	z-index: 10;
`;
const ToggleTrack = styled(animated.div) `
	user-select: none;
	position: relative;
	height: ${props => numToCssSize(props.theme.controlHeightBase * TOGGLETRACKHEIGHT)};
	width: ${props => numToCssSize(props.theme.controlHeightBase * TOGGLETRACKWIDTH)};
	background-color: ${props => props.theme.borderColorBase};
	border-radius: ${props => numToCssSize(props.theme.controlHeightBase * (TOGGLETRACKHEIGHT / 2))};
	box-shadow: ${props => props.theme.boxShadowInset};
	will-change: background-color;
	z-index: 9;
	cursor: pointer;

	&:active:not(.${TOGGLETRACKCLASS}--disabled) {
		${ToggleKnob} {
			width: ${props => numToCssSize(props.theme.controlHeightBase * TOGGLEKNOBHEIGHT + 4)};
			cursor: grabbing;
		}
	}
	&.${TOGGLETRACKCLASS}--checked:not(.${TOGGLETRACKCLASS}--disabled) {
		&:active {
			${ToggleKnob} {
				transform: translateX(-4px) !important;
			}
		}
	}
`;
const ToggleIcon = styled(animated.span) `
	pointer-events: none;
	position: absolute;
	display: flex;
	height: ${props => numToCssSize(props.theme.controlHeightBase * TOGGLETRACKHEIGHT)};
	width: ${props => numToCssSize(props.theme.controlHeightBase *
    (TOGGLETRACKWIDTH - TOGGLEKNOBHEIGHT - TOGGLEKNOBGUTTER))};
	top: 0;
	left: ${props => numToCssSize(props.theme.controlHeightBase * (TOGGLEKNOBHEIGHT + TOGGLEKNOBGUTTER))};
	align-items: center;
	justify-content: center;
	font-size: ${props => numToCssSize(props.theme.fz.small2)};
	color: ${props => props.theme.primaryBgText};
	will-change: opacity;

	&.${TOGGLEACTIVEICONCLASS} {
		left: ${props => numToCssSize(props.theme.controlHeightBase * TOGGLEKNOBGUTTER)};
	}
`;
const Input = styled.input `
	position: absolute;
	left: 2px;
	top: 2px;
	margin: 0;
	padding: 0;
	opacity: 0;

	&:hover:not(:disabled) {
		+ ${ToggleTrack} {
			${ToggleKnob} {
				box-shadow: ${props => props.theme.boxShadow4dp},
					0 0 0 ${props => numToCssSize(props.theme.controlHeightBase * 0.2)}
						${props => curriedTransparentize(0.8, props.theme.textColor)};
			}
		}
	}

	&:focus {
		outline: none;
	}

	&:focus:not(:disabled) {
		+ ${ToggleTrack} {
			${ToggleKnob} {
				box-shadow: ${props => props.theme.boxShadow4dp},
					0 0 0 ${props => numToCssSize(props.theme.controlHeightBase * 0.3)}
						${props => curriedTransparentize(0.8, props.theme.textColor)};
			}
		}
	}

	&:active:not(:disabled),
	&:active:focus:not(:disabled),
	&:active:focus:hover:not(:disabled),
	&:active:hover:not(:disabled) {
		+ ${ToggleTrack} {
			${ToggleKnob} {
				width: ${props => numToCssSize(props.theme.controlHeightBase * TOGGLEKNOBHEIGHT + 4)};
				box-shadow: ${props => props.theme.boxShadow4dp},
					0 0 0 ${props => numToCssSize(props.theme.controlHeightBase * 0.25)}
						${props => curriedTransparentize(0.8, props.theme.textColor)};
				cursor: grabbing;
			}
		}
	}

	&:checked {
		&:hover:not(:disabled) {
			+ ${ToggleTrack} {
				${ToggleKnob} {
					box-shadow: ${props => props.theme.boxShadow4dp},
						0 0 0 ${props => numToCssSize(props.theme.controlHeightBase * 0.2)}
							${props => curriedTransparentize(0.8, props.theme.primaryColor)};
				}
			}
		}

		&:focus:not(:disabled) {
			+ ${ToggleTrack} {
				${ToggleKnob} {
					box-shadow: ${props => props.theme.boxShadow4dp},
						0 0 0 ${props => numToCssSize(props.theme.controlHeightBase * 0.3)}
							${props => curriedTransparentize(0.8, props.theme.primaryColor)};
				}
			}
		}

		&:active:not(:disabled),
		&:active:focus:not(:disabled),
		&:active:focus:hover:not(:disabled),
		&:active:hover:not(:disabled) {
			+ ${ToggleTrack} {
				${ToggleKnob} {
					transform: translateX(-4px);
					box-shadow: ${props => props.theme.boxShadow4dp},
						0 0 0 ${props => numToCssSize(props.theme.controlHeightBase * 0.25)}
							${props => curriedTransparentize(0.8, props.theme.primaryColor)};
				}
			}
		}
	}

	&:disabled {
		+ ${ToggleTrack} {
			cursor: not-allowed;
			background-color: ${props => props.theme.disabledColor} !important;
			${ToggleKnob} {
				box-shadow: ${props => props.theme.boxShadow2dp},
					${props => props.theme.boxShadowNoneFocus};
				background-color: ${props => props.theme.disabledBackgroundColor};
				cursor: not-allowed;
			}
		}
	}
`;
const Container = styled.div `
	width: ${props => numToCssSize(props.theme.controlHeightBase * TOGGLETRACKWIDTH)};
	&.${CONTROLCLASS}--hasLabel {
		width: 100%;
	}

	&.${CONTROLCLASS}--align-CENTER {
		margin: 0 auto;

		&.${CONTROLCLASS}--hasLabel {
			${ControlWrapper} {
				flex-flow: row wrap;
				align-items: center;
				justify-content: center;
			}
			${Label} {
				margin: ${props => numToCssSize(props.theme.gutter / 2)} 0 0 0;
				flex: 0 0 100%;
				width: 100%;
				text-align: center;
			}
		}
	}
	&.${CONTROLCLASS}--align-RIGHT {
		margin: 0 0 0 auto;
		&.${CONTROLCLASS}--hasLabel {
			${Label} {
				margin: 0 ${props => numToCssSize(props.theme.gutter)} 0 0;
				text-align: right;
			}
			${SwitchContainer} {
				order: 1;
			}
		}
	}
`;

function Toggle(props) {
    const { className, value, onChange, hasError = false, label, disabled = false, activeIcon, inactiveIcon, controlAlignment = SettingsAppearanceControlAlignmentEnum.LEFT, ...inputProps } = props;
    const theme = useTheme();
    const [spring, api] = useSpring(() => ({
        from: {
            left: value
                ? `${theme.controlHeightBase * TOGGLEKNOBACTIVELEFT}px`
                : `${theme.controlHeightBase * TOGGLEKNOBINACTIVELEFT}px`,
            interpolator: value ? 1 : 0,
        },
        to: {
            left: value
                ? `${theme.controlHeightBase * TOGGLEKNOBACTIVELEFT}px`
                : `${theme.controlHeightBase * TOGGLEKNOBINACTIVELEFT}px`,
            interpolator: value ? 1 : 0,
        },
        config: theme.springConfigStiff,
    }));
    useEffect(() => {
        api.start({
            left: value
                ? `${theme.controlHeightBase * TOGGLEKNOBACTIVELEFT}px`
                : `${theme.controlHeightBase * TOGGLEKNOBINACTIVELEFT}px`,
            interpolator: value ? 1 : 0,
        });
    }, [value, api, theme.controlHeightBase]);
    const trackRef = useRef(null);
    const toggleKnobRef = useRef(null);
    const bind = useDrag(state => {
        if (disabled) {
            return;
        }
        const { movement, down, last, tap } = state;
        if (tap) {
            onChange(!value);
            return;
        }
        const movementX = movement[0];
        const left = value
            ? theme.controlHeightBase * TOGGLEKNOBACTIVELEFT + movementX
            : movementX;
        // set state based on current position
        const width = theme.controlHeightBase * TOGGLETRACKWIDTH;
        const meanPosition = Math.ceil(left + theme.controlHeightBase * (TOGGLEKNOBHEIGHT / 2));
        let interpolator = roundNumber(meanPosition / width, 2);
        if (interpolator < 0.5) {
            interpolator = interpolator - 0.2;
        }
        else {
            interpolator = interpolator + 0.2;
        }
        if (interpolator < 0) {
            interpolator = 0;
        }
        else if (interpolator > 1) {
            interpolator = 1;
        }
        let newVal;
        api.start({ left: `${left}px`, interpolator });
        if (!down || last) {
            if (meanPosition < width / 2) {
                newVal = false;
            }
            else {
                newVal = true;
            }
            if (value === newVal) {
                api.start({
                    left: newVal
                        ? `${theme.controlHeightBase * TOGGLEKNOBACTIVELEFT}px`
                        : `${theme.controlHeightBase * TOGGLEKNOBINACTIVELEFT}px`,
                    interpolator: newVal ? 1 : 0,
                });
            }
            else {
                onChange(newVal);
            }
            toggleKnobRef.current?.focus();
        }
    }, {
        bounds: trackRef,
        rubberband: [0.15, 0.15],
        filterTaps: false,
    });
    return (jsx(Container, Object.assign({ className: getBemClassName(CONTROLCLASS, {
            hasError,
            disabled,
            hasLabel: !!label,
            [`align-${controlAlignment}`]: true,
        }, className) }, { children: jsxs(ControlWrapper, Object.assign({ className: CONTROLWRAPPERCLASS }, { children: [jsxs(SwitchContainer, Object.assign({ className: SWITCHCONTAINERCLASS }, { children: [jsx(Input, Object.assign({ type: "checkbox", className: INPUTCLASS, checked: value, onChange: e => {
                                onChange(e.target.checked);
                            }, disabled: disabled, value: "true" }, inputProps), void 0), jsxs(ToggleTrack, Object.assign({ className: getBemClassName(TOGGLETRACKCLASS, {
                                checked: value,
                                disabled,
                            }), ref: trackRef, style: {
                                backgroundColor: spring.interpolator.to({
                                    range: [0, 1],
                                    output: [theme.borderColorBase, theme.primaryColor],
                                    extrapolate: 'clamp',
                                }),
                            }, onClick: e => {
                                e.preventDefault();
                                if (disabled ||
                                    e.target.isEqualNode(toggleKnobRef.current)) {
                                    return;
                                }
                                onChange(!value);
                            } }, { children: [activeIcon ? (jsx(ToggleIcon, Object.assign({ className: TOGGLEACTIVEICONCLASS, style: {
                                        opacity: spring.interpolator.to({
                                            range: [0, 1],
                                            output: [0, 1],
                                            extrapolate: 'clamp',
                                        }),
                                    } }, { children: jsx(Icon, { iconClass: activeIcon }, void 0) }), void 0)) : null, jsx(ToggleKnob, Object.assign({ style: { left: spring.left }, className: TOGGLEKNOBCLASS, ref: toggleKnobRef }, bind()), void 0), inactiveIcon ? (jsx(ToggleIcon, Object.assign({ className: TOGGLEINACTIVEICONCLASS, style: {
                                        opacity: spring.interpolator.to({
                                            range: [0, 1],
                                            output: [1, 0],
                                            extrapolate: 'clamp',
                                        }),
                                    } }, { children: jsx(Icon, { iconClass: inactiveIcon }, void 0) }), void 0)) : null] }), void 0)] }), void 0), label ? (jsx(Label, Object.assign({ className: LABELCLASS, htmlFor: inputProps.id }, { children: label }), void 0)) : null] }), void 0) }), void 0));
}

export { ActionFeedback as A, CONTROLCLASS$5 as C, DateTimePicker as D, InlineCountDown as I, List$1 as L, MathOutput as M, Progressbar as P, Rating as R, Spinner as S, Table as T, arrayMove as a, AnimatedSvg as b, ControlGroup as c, Tabs as d, Timer as e, Address as f, MatrixChoice as g, MatrixInput as h, Sortable as i, Toggle as j, generalDateTimeParseFormat as k, addressFieldsInOrder as l };
